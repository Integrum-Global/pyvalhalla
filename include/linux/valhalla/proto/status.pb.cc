// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: status.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "status.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace valhalla {

void protobuf_ShutdownFile_status_2eproto() {
  delete Status::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_status_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_status_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_status_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  Status::default_instance_ = new Status();
  Status::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_status_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_status_2eproto_once_);
void protobuf_AddDesc_status_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_status_2eproto_once_,
                 &protobuf_AddDesc_status_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_status_2eproto {
  StaticDescriptorInitializer_status_2eproto() {
    protobuf_AddDesc_status_2eproto();
  }
} static_descriptor_initializer_status_2eproto_;
#endif

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Status::kHasTilesFieldNumber;
const int Status::kHasAdminsFieldNumber;
const int Status::kHasTimezonesFieldNumber;
const int Status::kHasLiveTrafficFieldNumber;
const int Status::kBboxFieldNumber;
const int Status::kVersionFieldNumber;
const int Status::kTilesetLastModifiedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Status::Status()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:valhalla.Status)
}

void Status::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Status::Status(const Status& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:valhalla.Status)
}

void Status::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  clear_has_has_has_tiles();
  clear_has_has_has_admins();
  clear_has_has_has_timezones();
  clear_has_has_has_live_traffic();
  clear_has_has_bbox();
  clear_has_has_version();
  clear_has_has_tileset_last_modified();
}

Status::~Status() {
  // @@protoc_insertion_point(destructor:valhalla.Status)
  SharedDtor();
}

void Status::SharedDtor() {
  if (has_has_has_tiles()) {
    clear_has_has_tiles();
  }
  if (has_has_has_admins()) {
    clear_has_has_admins();
  }
  if (has_has_has_timezones()) {
    clear_has_has_timezones();
  }
  if (has_has_has_live_traffic()) {
    clear_has_has_live_traffic();
  }
  if (has_has_bbox()) {
    clear_has_bbox();
  }
  if (has_has_version()) {
    clear_has_version();
  }
  if (has_has_tileset_last_modified()) {
    clear_has_tileset_last_modified();
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Status::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Status& Status::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_status_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_status_2eproto();
#endif
  return *default_instance_;
}

Status* Status::default_instance_ = NULL;

Status* Status::New(::google::protobuf::Arena* arena) const {
  Status* n = new Status;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Status::clear_has_has_tiles() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Status)
  switch(has_has_tiles_case()) {
    case kHasTiles: {
      // No need to clear
      break;
    }
    case HAS_HAS_TILES_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = HAS_HAS_TILES_NOT_SET;
}

void Status::clear_has_has_admins() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Status)
  switch(has_has_admins_case()) {
    case kHasAdmins: {
      // No need to clear
      break;
    }
    case HAS_HAS_ADMINS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = HAS_HAS_ADMINS_NOT_SET;
}

void Status::clear_has_has_timezones() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Status)
  switch(has_has_timezones_case()) {
    case kHasTimezones: {
      // No need to clear
      break;
    }
    case HAS_HAS_TIMEZONES_NOT_SET: {
      break;
    }
  }
  _oneof_case_[2] = HAS_HAS_TIMEZONES_NOT_SET;
}

void Status::clear_has_has_live_traffic() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Status)
  switch(has_has_live_traffic_case()) {
    case kHasLiveTraffic: {
      // No need to clear
      break;
    }
    case HAS_HAS_LIVE_TRAFFIC_NOT_SET: {
      break;
    }
  }
  _oneof_case_[3] = HAS_HAS_LIVE_TRAFFIC_NOT_SET;
}

void Status::clear_has_bbox() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Status)
  switch(has_bbox_case()) {
    case kBbox: {
      has_bbox_.bbox_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case HAS_BBOX_NOT_SET: {
      break;
    }
  }
  _oneof_case_[4] = HAS_BBOX_NOT_SET;
}

void Status::clear_has_version() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Status)
  switch(has_version_case()) {
    case kVersion: {
      has_version_.version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case HAS_VERSION_NOT_SET: {
      break;
    }
  }
  _oneof_case_[5] = HAS_VERSION_NOT_SET;
}

void Status::clear_has_tileset_last_modified() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Status)
  switch(has_tileset_last_modified_case()) {
    case kTilesetLastModified: {
      // No need to clear
      break;
    }
    case HAS_TILESET_LAST_MODIFIED_NOT_SET: {
      break;
    }
  }
  _oneof_case_[6] = HAS_TILESET_LAST_MODIFIED_NOT_SET;
}


void Status::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Status)
  clear_has_has_tiles();
  clear_has_has_admins();
  clear_has_has_timezones();
  clear_has_has_live_traffic();
  clear_has_bbox();
  clear_has_version();
  clear_has_tileset_last_modified();
}

bool Status::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:valhalla.Status)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool has_tiles = 1;
      case 1: {
        if (tag == 8) {
          clear_has_has_tiles();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_has_tiles_.has_tiles_)));
          set_has_has_tiles();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_has_admins;
        break;
      }

      // optional bool has_admins = 2;
      case 2: {
        if (tag == 16) {
         parse_has_admins:
          clear_has_has_admins();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_has_admins_.has_admins_)));
          set_has_has_admins();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_has_timezones;
        break;
      }

      // optional bool has_timezones = 3;
      case 3: {
        if (tag == 24) {
         parse_has_timezones:
          clear_has_has_timezones();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_has_timezones_.has_timezones_)));
          set_has_has_timezones();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_has_live_traffic;
        break;
      }

      // optional bool has_live_traffic = 4;
      case 4: {
        if (tag == 32) {
         parse_has_live_traffic:
          clear_has_has_live_traffic();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_has_live_traffic_.has_live_traffic_)));
          set_has_has_live_traffic();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_bbox;
        break;
      }

      // optional string bbox = 5;
      case 5: {
        if (tag == 42) {
         parse_bbox:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_bbox()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->bbox().data(), this->bbox().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "valhalla.Status.bbox"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_version;
        break;
      }

      // optional string version = 6;
      case 6: {
        if (tag == 50) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "valhalla.Status.version"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_tileset_last_modified;
        break;
      }

      // optional uint32 tileset_last_modified = 7;
      case 7: {
        if (tag == 56) {
         parse_tileset_last_modified:
          clear_has_tileset_last_modified();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_tileset_last_modified_.tileset_last_modified_)));
          set_has_tileset_last_modified();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:valhalla.Status)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:valhalla.Status)
  return false;
#undef DO_
}

void Status::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:valhalla.Status)
  // optional bool has_tiles = 1;
  if (has_has_tiles()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->has_tiles(), output);
  }

  // optional bool has_admins = 2;
  if (has_has_admins()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->has_admins(), output);
  }

  // optional bool has_timezones = 3;
  if (has_has_timezones()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->has_timezones(), output);
  }

  // optional bool has_live_traffic = 4;
  if (has_has_live_traffic()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->has_live_traffic(), output);
  }

  // optional string bbox = 5;
  if (has_bbox()) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->bbox().data(), this->bbox().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "valhalla.Status.bbox");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->bbox(), output);
  }

  // optional string version = 6;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "valhalla.Status.version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->version(), output);
  }

  // optional uint32 tileset_last_modified = 7;
  if (has_tileset_last_modified()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->tileset_last_modified(), output);
  }

  // @@protoc_insertion_point(serialize_end:valhalla.Status)
}

int Status::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.Status)
  int total_size = 0;

  switch (has_has_tiles_case()) {
    // optional bool has_tiles = 1;
    case kHasTiles: {
      total_size += 1 + 1;
      break;
    }
    case HAS_HAS_TILES_NOT_SET: {
      break;
    }
  }
  switch (has_has_admins_case()) {
    // optional bool has_admins = 2;
    case kHasAdmins: {
      total_size += 1 + 1;
      break;
    }
    case HAS_HAS_ADMINS_NOT_SET: {
      break;
    }
  }
  switch (has_has_timezones_case()) {
    // optional bool has_timezones = 3;
    case kHasTimezones: {
      total_size += 1 + 1;
      break;
    }
    case HAS_HAS_TIMEZONES_NOT_SET: {
      break;
    }
  }
  switch (has_has_live_traffic_case()) {
    // optional bool has_live_traffic = 4;
    case kHasLiveTraffic: {
      total_size += 1 + 1;
      break;
    }
    case HAS_HAS_LIVE_TRAFFIC_NOT_SET: {
      break;
    }
  }
  switch (has_bbox_case()) {
    // optional string bbox = 5;
    case kBbox: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->bbox());
      break;
    }
    case HAS_BBOX_NOT_SET: {
      break;
    }
  }
  switch (has_version_case()) {
    // optional string version = 6;
    case kVersion: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
      break;
    }
    case HAS_VERSION_NOT_SET: {
      break;
    }
  }
  switch (has_tileset_last_modified_case()) {
    // optional uint32 tileset_last_modified = 7;
    case kTilesetLastModified: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tileset_last_modified());
      break;
    }
    case HAS_TILESET_LAST_MODIFIED_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Status::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Status*>(&from));
}

void Status::MergeFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Status)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  switch (from.has_has_tiles_case()) {
    case kHasTiles: {
      set_has_tiles(from.has_tiles());
      break;
    }
    case HAS_HAS_TILES_NOT_SET: {
      break;
    }
  }
  switch (from.has_has_admins_case()) {
    case kHasAdmins: {
      set_has_admins(from.has_admins());
      break;
    }
    case HAS_HAS_ADMINS_NOT_SET: {
      break;
    }
  }
  switch (from.has_has_timezones_case()) {
    case kHasTimezones: {
      set_has_timezones(from.has_timezones());
      break;
    }
    case HAS_HAS_TIMEZONES_NOT_SET: {
      break;
    }
  }
  switch (from.has_has_live_traffic_case()) {
    case kHasLiveTraffic: {
      set_has_live_traffic(from.has_live_traffic());
      break;
    }
    case HAS_HAS_LIVE_TRAFFIC_NOT_SET: {
      break;
    }
  }
  switch (from.has_bbox_case()) {
    case kBbox: {
      set_bbox(from.bbox());
      break;
    }
    case HAS_BBOX_NOT_SET: {
      break;
    }
  }
  switch (from.has_version_case()) {
    case kVersion: {
      set_version(from.version());
      break;
    }
    case HAS_VERSION_NOT_SET: {
      break;
    }
  }
  switch (from.has_tileset_last_modified_case()) {
    case kTilesetLastModified: {
      set_tileset_last_modified(from.tileset_last_modified());
      break;
    }
    case HAS_TILESET_LAST_MODIFIED_NOT_SET: {
      break;
    }
  }
}

void Status::CopyFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Status)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Status::IsInitialized() const {

  return true;
}

void Status::Swap(Status* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Status::InternalSwap(Status* other) {
  std::swap(has_has_tiles_, other->has_has_tiles_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(has_has_admins_, other->has_has_admins_);
  std::swap(_oneof_case_[1], other->_oneof_case_[1]);
  std::swap(has_has_timezones_, other->has_has_timezones_);
  std::swap(_oneof_case_[2], other->_oneof_case_[2]);
  std::swap(has_has_live_traffic_, other->has_has_live_traffic_);
  std::swap(_oneof_case_[3], other->_oneof_case_[3]);
  std::swap(has_bbox_, other->has_bbox_);
  std::swap(_oneof_case_[4], other->_oneof_case_[4]);
  std::swap(has_version_, other->has_version_);
  std::swap(_oneof_case_[5], other->_oneof_case_[5]);
  std::swap(has_tileset_last_modified_, other->has_tileset_last_modified_);
  std::swap(_oneof_case_[6], other->_oneof_case_[6]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Status::GetTypeName() const {
  return "valhalla.Status";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Status

// optional bool has_tiles = 1;
bool Status::has_has_tiles() const {
  return has_has_tiles_case() == kHasTiles;
}
void Status::set_has_has_tiles() {
  _oneof_case_[0] = kHasTiles;
}
void Status::clear_has_tiles() {
  if (has_has_tiles()) {
    has_has_tiles_.has_tiles_ = false;
    clear_has_has_has_tiles();
  }
}
 bool Status::has_tiles() const {
  // @@protoc_insertion_point(field_get:valhalla.Status.has_tiles)
  if (has_has_tiles()) {
    return has_has_tiles_.has_tiles_;
  }
  return false;
}
 void Status::set_has_tiles(bool value) {
  if (!has_has_tiles()) {
    clear_has_has_tiles();
    set_has_has_tiles();
  }
  has_has_tiles_.has_tiles_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Status.has_tiles)
}

// optional bool has_admins = 2;
bool Status::has_has_admins() const {
  return has_has_admins_case() == kHasAdmins;
}
void Status::set_has_has_admins() {
  _oneof_case_[1] = kHasAdmins;
}
void Status::clear_has_admins() {
  if (has_has_admins()) {
    has_has_admins_.has_admins_ = false;
    clear_has_has_has_admins();
  }
}
 bool Status::has_admins() const {
  // @@protoc_insertion_point(field_get:valhalla.Status.has_admins)
  if (has_has_admins()) {
    return has_has_admins_.has_admins_;
  }
  return false;
}
 void Status::set_has_admins(bool value) {
  if (!has_has_admins()) {
    clear_has_has_admins();
    set_has_has_admins();
  }
  has_has_admins_.has_admins_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Status.has_admins)
}

// optional bool has_timezones = 3;
bool Status::has_has_timezones() const {
  return has_has_timezones_case() == kHasTimezones;
}
void Status::set_has_has_timezones() {
  _oneof_case_[2] = kHasTimezones;
}
void Status::clear_has_timezones() {
  if (has_has_timezones()) {
    has_has_timezones_.has_timezones_ = false;
    clear_has_has_has_timezones();
  }
}
 bool Status::has_timezones() const {
  // @@protoc_insertion_point(field_get:valhalla.Status.has_timezones)
  if (has_has_timezones()) {
    return has_has_timezones_.has_timezones_;
  }
  return false;
}
 void Status::set_has_timezones(bool value) {
  if (!has_has_timezones()) {
    clear_has_has_timezones();
    set_has_has_timezones();
  }
  has_has_timezones_.has_timezones_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Status.has_timezones)
}

// optional bool has_live_traffic = 4;
bool Status::has_has_live_traffic() const {
  return has_has_live_traffic_case() == kHasLiveTraffic;
}
void Status::set_has_has_live_traffic() {
  _oneof_case_[3] = kHasLiveTraffic;
}
void Status::clear_has_live_traffic() {
  if (has_has_live_traffic()) {
    has_has_live_traffic_.has_live_traffic_ = false;
    clear_has_has_has_live_traffic();
  }
}
 bool Status::has_live_traffic() const {
  // @@protoc_insertion_point(field_get:valhalla.Status.has_live_traffic)
  if (has_has_live_traffic()) {
    return has_has_live_traffic_.has_live_traffic_;
  }
  return false;
}
 void Status::set_has_live_traffic(bool value) {
  if (!has_has_live_traffic()) {
    clear_has_has_live_traffic();
    set_has_has_live_traffic();
  }
  has_has_live_traffic_.has_live_traffic_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Status.has_live_traffic)
}

// optional string bbox = 5;
bool Status::has_bbox() const {
  return has_bbox_case() == kBbox;
}
void Status::set_has_bbox() {
  _oneof_case_[4] = kBbox;
}
void Status::clear_bbox() {
  if (has_bbox()) {
    has_bbox_.bbox_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_bbox();
  }
}
 const ::std::string& Status::bbox() const {
  // @@protoc_insertion_point(field_get:valhalla.Status.bbox)
  if (has_bbox()) {
    return has_bbox_.bbox_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
 void Status::set_bbox(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.Status.bbox)
  if (!has_bbox()) {
    clear_has_bbox();
    set_has_bbox();
    has_bbox_.bbox_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_bbox_.bbox_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.Status.bbox)
}
 void Status::set_bbox(const char* value) {
  if (!has_bbox()) {
    clear_has_bbox();
    set_has_bbox();
    has_bbox_.bbox_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_bbox_.bbox_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.Status.bbox)
}
 void Status::set_bbox(const char* value, size_t size) {
  if (!has_bbox()) {
    clear_has_bbox();
    set_has_bbox();
    has_bbox_.bbox_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_bbox_.bbox_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.Status.bbox)
}
 ::std::string* Status::mutable_bbox() {
  if (!has_bbox()) {
    clear_has_bbox();
    set_has_bbox();
    has_bbox_.bbox_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Status.bbox)
  return has_bbox_.bbox_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Status::release_bbox() {
  // @@protoc_insertion_point(field_release:valhalla.Status.bbox)
  if (has_bbox()) {
    clear_has_has_bbox();
    return has_bbox_.bbox_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
 void Status::set_allocated_bbox(::std::string* bbox) {
  if (!has_bbox()) {
    has_bbox_.bbox_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_bbox();
  if (bbox != NULL) {
    set_has_bbox();
    has_bbox_.bbox_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        bbox);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Status.bbox)
}

// optional string version = 6;
bool Status::has_version() const {
  return has_version_case() == kVersion;
}
void Status::set_has_version() {
  _oneof_case_[5] = kVersion;
}
void Status::clear_version() {
  if (has_version()) {
    has_version_.version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_version();
  }
}
 const ::std::string& Status::version() const {
  // @@protoc_insertion_point(field_get:valhalla.Status.version)
  if (has_version()) {
    return has_version_.version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
 void Status::set_version(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.Status.version)
  if (!has_version()) {
    clear_has_version();
    set_has_version();
    has_version_.version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_version_.version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.Status.version)
}
 void Status::set_version(const char* value) {
  if (!has_version()) {
    clear_has_version();
    set_has_version();
    has_version_.version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_version_.version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.Status.version)
}
 void Status::set_version(const char* value, size_t size) {
  if (!has_version()) {
    clear_has_version();
    set_has_version();
    has_version_.version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_version_.version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.Status.version)
}
 ::std::string* Status::mutable_version() {
  if (!has_version()) {
    clear_has_version();
    set_has_version();
    has_version_.version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Status.version)
  return has_version_.version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Status::release_version() {
  // @@protoc_insertion_point(field_release:valhalla.Status.version)
  if (has_version()) {
    clear_has_has_version();
    return has_version_.version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
 void Status::set_allocated_version(::std::string* version) {
  if (!has_version()) {
    has_version_.version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_version();
  if (version != NULL) {
    set_has_version();
    has_version_.version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        version);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Status.version)
}

// optional uint32 tileset_last_modified = 7;
bool Status::has_tileset_last_modified() const {
  return has_tileset_last_modified_case() == kTilesetLastModified;
}
void Status::set_has_tileset_last_modified() {
  _oneof_case_[6] = kTilesetLastModified;
}
void Status::clear_tileset_last_modified() {
  if (has_tileset_last_modified()) {
    has_tileset_last_modified_.tileset_last_modified_ = 0u;
    clear_has_has_tileset_last_modified();
  }
}
 ::google::protobuf::uint32 Status::tileset_last_modified() const {
  // @@protoc_insertion_point(field_get:valhalla.Status.tileset_last_modified)
  if (has_tileset_last_modified()) {
    return has_tileset_last_modified_.tileset_last_modified_;
  }
  return 0u;
}
 void Status::set_tileset_last_modified(::google::protobuf::uint32 value) {
  if (!has_tileset_last_modified()) {
    clear_has_tileset_last_modified();
    set_has_tileset_last_modified();
  }
  has_tileset_last_modified_.tileset_last_modified_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Status.tileset_last_modified)
}

bool Status::has_has_has_tiles() const {
  return has_has_tiles_case() != HAS_HAS_TILES_NOT_SET;
}
void Status::clear_has_has_has_tiles() {
  _oneof_case_[0] = HAS_HAS_TILES_NOT_SET;
}
bool Status::has_has_has_admins() const {
  return has_has_admins_case() != HAS_HAS_ADMINS_NOT_SET;
}
void Status::clear_has_has_has_admins() {
  _oneof_case_[1] = HAS_HAS_ADMINS_NOT_SET;
}
bool Status::has_has_has_timezones() const {
  return has_has_timezones_case() != HAS_HAS_TIMEZONES_NOT_SET;
}
void Status::clear_has_has_has_timezones() {
  _oneof_case_[2] = HAS_HAS_TIMEZONES_NOT_SET;
}
bool Status::has_has_has_live_traffic() const {
  return has_has_live_traffic_case() != HAS_HAS_LIVE_TRAFFIC_NOT_SET;
}
void Status::clear_has_has_has_live_traffic() {
  _oneof_case_[3] = HAS_HAS_LIVE_TRAFFIC_NOT_SET;
}
bool Status::has_has_bbox() const {
  return has_bbox_case() != HAS_BBOX_NOT_SET;
}
void Status::clear_has_has_bbox() {
  _oneof_case_[4] = HAS_BBOX_NOT_SET;
}
bool Status::has_has_version() const {
  return has_version_case() != HAS_VERSION_NOT_SET;
}
void Status::clear_has_has_version() {
  _oneof_case_[5] = HAS_VERSION_NOT_SET;
}
bool Status::has_has_tileset_last_modified() const {
  return has_tileset_last_modified_case() != HAS_TILESET_LAST_MODIFIED_NOT_SET;
}
void Status::clear_has_has_tileset_last_modified() {
  _oneof_case_[6] = HAS_TILESET_LAST_MODIFIED_NOT_SET;
}
Status::HasHasTilesCase Status::has_has_tiles_case() const {
  return Status::HasHasTilesCase(_oneof_case_[0]);
}
Status::HasHasAdminsCase Status::has_has_admins_case() const {
  return Status::HasHasAdminsCase(_oneof_case_[1]);
}
Status::HasHasTimezonesCase Status::has_has_timezones_case() const {
  return Status::HasHasTimezonesCase(_oneof_case_[2]);
}
Status::HasHasLiveTrafficCase Status::has_has_live_traffic_case() const {
  return Status::HasHasLiveTrafficCase(_oneof_case_[3]);
}
Status::HasBboxCase Status::has_bbox_case() const {
  return Status::HasBboxCase(_oneof_case_[4]);
}
Status::HasVersionCase Status::has_version_case() const {
  return Status::HasVersionCase(_oneof_case_[5]);
}
Status::HasTilesetLastModifiedCase Status::has_tileset_last_modified_case() const {
  return Status::HasTilesetLastModifiedCase(_oneof_case_[6]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

// @@protoc_insertion_point(global_scope)
