// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: directions.proto

#ifndef PROTOBUF_directions_2eproto__INCLUDED
#define PROTOBUF_directions_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
#include "tripcommon.pb.h"  // IWYU pragma: export
#include "sign.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

namespace valhalla {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_directions_2eproto();
void protobuf_AssignDesc_directions_2eproto();
void protobuf_ShutdownFile_directions_2eproto();

class Directions;
class DirectionsLeg;
class DirectionsLeg_GuidanceView;
class DirectionsLeg_Maneuver;
class DirectionsLeg_Summary;
class DirectionsRoute;

enum DirectionsLeg_GuidanceView_Type {
  DirectionsLeg_GuidanceView_Type_kJunction = 0,
  DirectionsLeg_GuidanceView_Type_kSapa = 1,
  DirectionsLeg_GuidanceView_Type_kTollbranch = 2,
  DirectionsLeg_GuidanceView_Type_kAftertoll = 3,
  DirectionsLeg_GuidanceView_Type_kEnt = 4,
  DirectionsLeg_GuidanceView_Type_kExit = 5,
  DirectionsLeg_GuidanceView_Type_kCityreal = 6,
  DirectionsLeg_GuidanceView_Type_kDirectionboard = 7,
  DirectionsLeg_GuidanceView_Type_kSignboard = 8,
  DirectionsLeg_GuidanceView_Type_DirectionsLeg_GuidanceView_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DirectionsLeg_GuidanceView_Type_DirectionsLeg_GuidanceView_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DirectionsLeg_GuidanceView_Type_IsValid(int value);
const DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView_Type_Type_MIN = DirectionsLeg_GuidanceView_Type_kJunction;
const DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView_Type_Type_MAX = DirectionsLeg_GuidanceView_Type_kSignboard;
const int DirectionsLeg_GuidanceView_Type_Type_ARRAYSIZE = DirectionsLeg_GuidanceView_Type_Type_MAX + 1;

enum DirectionsLeg_Maneuver_CardinalDirection {
  DirectionsLeg_Maneuver_CardinalDirection_kNorth = 0,
  DirectionsLeg_Maneuver_CardinalDirection_kNorthEast = 1,
  DirectionsLeg_Maneuver_CardinalDirection_kEast = 2,
  DirectionsLeg_Maneuver_CardinalDirection_kSouthEast = 3,
  DirectionsLeg_Maneuver_CardinalDirection_kSouth = 4,
  DirectionsLeg_Maneuver_CardinalDirection_kSouthWest = 5,
  DirectionsLeg_Maneuver_CardinalDirection_kWest = 6,
  DirectionsLeg_Maneuver_CardinalDirection_kNorthWest = 7,
  DirectionsLeg_Maneuver_CardinalDirection_DirectionsLeg_Maneuver_CardinalDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DirectionsLeg_Maneuver_CardinalDirection_DirectionsLeg_Maneuver_CardinalDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DirectionsLeg_Maneuver_CardinalDirection_IsValid(int value);
const DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MIN = DirectionsLeg_Maneuver_CardinalDirection_kNorth;
const DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MAX = DirectionsLeg_Maneuver_CardinalDirection_kNorthWest;
const int DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_ARRAYSIZE = DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MAX + 1;

enum DirectionsLeg_Maneuver_Type {
  DirectionsLeg_Maneuver_Type_kNone = 0,
  DirectionsLeg_Maneuver_Type_kStart = 1,
  DirectionsLeg_Maneuver_Type_kStartRight = 2,
  DirectionsLeg_Maneuver_Type_kStartLeft = 3,
  DirectionsLeg_Maneuver_Type_kDestination = 4,
  DirectionsLeg_Maneuver_Type_kDestinationRight = 5,
  DirectionsLeg_Maneuver_Type_kDestinationLeft = 6,
  DirectionsLeg_Maneuver_Type_kBecomes = 7,
  DirectionsLeg_Maneuver_Type_kContinue = 8,
  DirectionsLeg_Maneuver_Type_kSlightRight = 9,
  DirectionsLeg_Maneuver_Type_kRight = 10,
  DirectionsLeg_Maneuver_Type_kSharpRight = 11,
  DirectionsLeg_Maneuver_Type_kUturnRight = 12,
  DirectionsLeg_Maneuver_Type_kUturnLeft = 13,
  DirectionsLeg_Maneuver_Type_kSharpLeft = 14,
  DirectionsLeg_Maneuver_Type_kLeft = 15,
  DirectionsLeg_Maneuver_Type_kSlightLeft = 16,
  DirectionsLeg_Maneuver_Type_kRampStraight = 17,
  DirectionsLeg_Maneuver_Type_kRampRight = 18,
  DirectionsLeg_Maneuver_Type_kRampLeft = 19,
  DirectionsLeg_Maneuver_Type_kExitRight = 20,
  DirectionsLeg_Maneuver_Type_kExitLeft = 21,
  DirectionsLeg_Maneuver_Type_kStayStraight = 22,
  DirectionsLeg_Maneuver_Type_kStayRight = 23,
  DirectionsLeg_Maneuver_Type_kStayLeft = 24,
  DirectionsLeg_Maneuver_Type_kMerge = 25,
  DirectionsLeg_Maneuver_Type_kRoundaboutEnter = 26,
  DirectionsLeg_Maneuver_Type_kRoundaboutExit = 27,
  DirectionsLeg_Maneuver_Type_kFerryEnter = 28,
  DirectionsLeg_Maneuver_Type_kFerryExit = 29,
  DirectionsLeg_Maneuver_Type_kTransit = 30,
  DirectionsLeg_Maneuver_Type_kTransitTransfer = 31,
  DirectionsLeg_Maneuver_Type_kTransitRemainOn = 32,
  DirectionsLeg_Maneuver_Type_kTransitConnectionStart = 33,
  DirectionsLeg_Maneuver_Type_kTransitConnectionTransfer = 34,
  DirectionsLeg_Maneuver_Type_kTransitConnectionDestination = 35,
  DirectionsLeg_Maneuver_Type_kPostTransitConnectionDestination = 36,
  DirectionsLeg_Maneuver_Type_kMergeRight = 37,
  DirectionsLeg_Maneuver_Type_kMergeLeft = 38,
  DirectionsLeg_Maneuver_Type_DirectionsLeg_Maneuver_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DirectionsLeg_Maneuver_Type_DirectionsLeg_Maneuver_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DirectionsLeg_Maneuver_Type_IsValid(int value);
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver_Type_Type_MIN = DirectionsLeg_Maneuver_Type_kNone;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver_Type_Type_MAX = DirectionsLeg_Maneuver_Type_kMergeLeft;
const int DirectionsLeg_Maneuver_Type_Type_ARRAYSIZE = DirectionsLeg_Maneuver_Type_Type_MAX + 1;

enum DirectionsLeg_Maneuver_BssManeuverType {
  DirectionsLeg_Maneuver_BssManeuverType_kNoneAction = 0,
  DirectionsLeg_Maneuver_BssManeuverType_kRentBikeAtBikeShare = 1,
  DirectionsLeg_Maneuver_BssManeuverType_kReturnBikeAtBikeShare = 2,
  DirectionsLeg_Maneuver_BssManeuverType_DirectionsLeg_Maneuver_BssManeuverType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DirectionsLeg_Maneuver_BssManeuverType_DirectionsLeg_Maneuver_BssManeuverType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DirectionsLeg_Maneuver_BssManeuverType_IsValid(int value);
const DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MIN = DirectionsLeg_Maneuver_BssManeuverType_kNoneAction;
const DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MAX = DirectionsLeg_Maneuver_BssManeuverType_kReturnBikeAtBikeShare;
const int DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_ARRAYSIZE = DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MAX + 1;

// ===================================================================

class DirectionsLeg_Summary : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg.Summary) */ {
 public:
  DirectionsLeg_Summary();
  virtual ~DirectionsLeg_Summary();

  DirectionsLeg_Summary(const DirectionsLeg_Summary& from);

  inline DirectionsLeg_Summary& operator=(const DirectionsLeg_Summary& from) {
    CopyFrom(from);
    return *this;
  }

  static const DirectionsLeg_Summary& default_instance();

  enum HasLengthCase {
    kLength = 1,
    HAS_LENGTH_NOT_SET = 0,
  };

  enum HasTimeCase {
    kTime = 2,
    HAS_TIME_NOT_SET = 0,
  };

  enum HasHasTimeRestrictionsCase {
    kHasTimeRestrictions = 4,
    HAS_HAS_TIME_RESTRICTIONS_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DirectionsLeg_Summary* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DirectionsLeg_Summary* other);

  // implements Message ----------------------------------------------

  inline DirectionsLeg_Summary* New() const { return New(NULL); }

  DirectionsLeg_Summary* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DirectionsLeg_Summary& from);
  void MergeFrom(const DirectionsLeg_Summary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg_Summary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float length = 1;
  private:
  bool has_length() const;
  public:
  void clear_length();
  static const int kLengthFieldNumber = 1;
  float length() const;
  void set_length(float value);

  // optional double time = 2;
  private:
  bool has_time() const;
  public:
  void clear_time();
  static const int kTimeFieldNumber = 2;
  double time() const;
  void set_time(double value);

  // optional .valhalla.BoundingBox bbox = 3;
  bool has_bbox() const;
  void clear_bbox();
  static const int kBboxFieldNumber = 3;
  const ::valhalla::BoundingBox& bbox() const;
  ::valhalla::BoundingBox* mutable_bbox();
  ::valhalla::BoundingBox* release_bbox();
  void set_allocated_bbox(::valhalla::BoundingBox* bbox);

  // optional bool has_time_restrictions = 4;
  private:
  bool has_has_time_restrictions() const;
  public:
  void clear_has_time_restrictions();
  static const int kHasTimeRestrictionsFieldNumber = 4;
  bool has_time_restrictions() const;
  void set_has_time_restrictions(bool value);

  HasLengthCase has_length_case() const;
  HasTimeCase has_time_case() const;
  HasHasTimeRestrictionsCase has_has_time_restrictions_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.Summary)
 private:
  inline void set_has_length();
  inline void set_has_time();
  inline void set_has_has_time_restrictions();

  inline bool has_has_length() const;
  void clear_has_length();
  inline void clear_has_has_length();

  inline bool has_has_time() const;
  void clear_has_time();
  inline void clear_has_has_time();

  inline bool has_has_has_time_restrictions() const;
  void clear_has_has_time_restrictions();
  inline void clear_has_has_has_time_restrictions();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::valhalla::BoundingBox* bbox_;
  union HasLengthUnion {
    HasLengthUnion() {}
    float length_;
  } has_length_;
  union HasTimeUnion {
    HasTimeUnion() {}
    double time_;
  } has_time_;
  union HasHasTimeRestrictionsUnion {
    HasHasTimeRestrictionsUnion() {}
    bool has_time_restrictions_;
  } has_has_time_restrictions_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[3];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_directions_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_directions_2eproto();
  #endif
  friend void protobuf_AssignDesc_directions_2eproto();
  friend void protobuf_ShutdownFile_directions_2eproto();

  void InitAsDefaultInstance();
  static DirectionsLeg_Summary* default_instance_;
};
// -------------------------------------------------------------------

class DirectionsLeg_GuidanceView : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg.GuidanceView) */ {
 public:
  DirectionsLeg_GuidanceView();
  virtual ~DirectionsLeg_GuidanceView();

  DirectionsLeg_GuidanceView(const DirectionsLeg_GuidanceView& from);

  inline DirectionsLeg_GuidanceView& operator=(const DirectionsLeg_GuidanceView& from) {
    CopyFrom(from);
    return *this;
  }

  static const DirectionsLeg_GuidanceView& default_instance();

  enum HasDataIdCase {
    kDataId = 1,
    HAS_DATA_ID_NOT_SET = 0,
  };

  enum HasTypeCase {
    kType = 2,
    HAS_TYPE_NOT_SET = 0,
  };

  enum HasBaseIdCase {
    kBaseId = 3,
    HAS_BASE_ID_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DirectionsLeg_GuidanceView* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DirectionsLeg_GuidanceView* other);

  // implements Message ----------------------------------------------

  inline DirectionsLeg_GuidanceView* New() const { return New(NULL); }

  DirectionsLeg_GuidanceView* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DirectionsLeg_GuidanceView& from);
  void MergeFrom(const DirectionsLeg_GuidanceView& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg_GuidanceView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef DirectionsLeg_GuidanceView_Type Type;
  static const Type kJunction =
    DirectionsLeg_GuidanceView_Type_kJunction;
  static const Type kSapa =
    DirectionsLeg_GuidanceView_Type_kSapa;
  static const Type kTollbranch =
    DirectionsLeg_GuidanceView_Type_kTollbranch;
  static const Type kAftertoll =
    DirectionsLeg_GuidanceView_Type_kAftertoll;
  static const Type kEnt =
    DirectionsLeg_GuidanceView_Type_kEnt;
  static const Type kExit =
    DirectionsLeg_GuidanceView_Type_kExit;
  static const Type kCityreal =
    DirectionsLeg_GuidanceView_Type_kCityreal;
  static const Type kDirectionboard =
    DirectionsLeg_GuidanceView_Type_kDirectionboard;
  static const Type kSignboard =
    DirectionsLeg_GuidanceView_Type_kSignboard;
  static inline bool Type_IsValid(int value) {
    return DirectionsLeg_GuidanceView_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DirectionsLeg_GuidanceView_Type_Type_MIN;
  static const Type Type_MAX =
    DirectionsLeg_GuidanceView_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DirectionsLeg_GuidanceView_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string data_id = 1;
  private:
  bool has_data_id() const;
  public:
  void clear_data_id();
  static const int kDataIdFieldNumber = 1;
  const ::std::string& data_id() const;
  void set_data_id(const ::std::string& value);
  void set_data_id(const char* value);
  void set_data_id(const char* value, size_t size);
  ::std::string* mutable_data_id();
  ::std::string* release_data_id();
  void set_allocated_data_id(::std::string* data_id);

  // optional .valhalla.DirectionsLeg.GuidanceView.Type type = 2;
  private:
  bool has_type() const;
  public:
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::valhalla::DirectionsLeg_GuidanceView_Type type() const;
  void set_type(::valhalla::DirectionsLeg_GuidanceView_Type value);

  // optional string base_id = 3;
  private:
  bool has_base_id() const;
  public:
  void clear_base_id();
  static const int kBaseIdFieldNumber = 3;
  const ::std::string& base_id() const;
  void set_base_id(const ::std::string& value);
  void set_base_id(const char* value);
  void set_base_id(const char* value, size_t size);
  ::std::string* mutable_base_id();
  ::std::string* release_base_id();
  void set_allocated_base_id(::std::string* base_id);

  // repeated string overlay_ids = 4;
  int overlay_ids_size() const;
  void clear_overlay_ids();
  static const int kOverlayIdsFieldNumber = 4;
  const ::std::string& overlay_ids(int index) const;
  ::std::string* mutable_overlay_ids(int index);
  void set_overlay_ids(int index, const ::std::string& value);
  void set_overlay_ids(int index, const char* value);
  void set_overlay_ids(int index, const char* value, size_t size);
  ::std::string* add_overlay_ids();
  void add_overlay_ids(const ::std::string& value);
  void add_overlay_ids(const char* value);
  void add_overlay_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& overlay_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_overlay_ids();

  HasDataIdCase has_data_id_case() const;
  HasTypeCase has_type_case() const;
  HasBaseIdCase has_base_id_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.GuidanceView)
 private:
  inline void set_has_data_id();
  inline void set_has_type();
  inline void set_has_base_id();

  inline bool has_has_data_id() const;
  void clear_has_data_id();
  inline void clear_has_has_data_id();

  inline bool has_has_type() const;
  void clear_has_type();
  inline void clear_has_has_type();

  inline bool has_has_base_id() const;
  void clear_has_base_id();
  inline void clear_has_has_base_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::std::string> overlay_ids_;
  union HasDataIdUnion {
    HasDataIdUnion() {}
    ::google::protobuf::internal::ArenaStringPtr data_id_;
  } has_data_id_;
  union HasTypeUnion {
    HasTypeUnion() {}
    int type_;
  } has_type_;
  union HasBaseIdUnion {
    HasBaseIdUnion() {}
    ::google::protobuf::internal::ArenaStringPtr base_id_;
  } has_base_id_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[3];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_directions_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_directions_2eproto();
  #endif
  friend void protobuf_AssignDesc_directions_2eproto();
  friend void protobuf_ShutdownFile_directions_2eproto();

  void InitAsDefaultInstance();
  static DirectionsLeg_GuidanceView* default_instance_;
};
// -------------------------------------------------------------------

class DirectionsLeg_Maneuver : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg.Maneuver) */ {
 public:
  DirectionsLeg_Maneuver();
  virtual ~DirectionsLeg_Maneuver();

  DirectionsLeg_Maneuver(const DirectionsLeg_Maneuver& from);

  inline DirectionsLeg_Maneuver& operator=(const DirectionsLeg_Maneuver& from) {
    CopyFrom(from);
    return *this;
  }

  static const DirectionsLeg_Maneuver& default_instance();

  enum HasTypeCase {
    kType = 1,
    HAS_TYPE_NOT_SET = 0,
  };

  enum HasTextInstructionCase {
    kTextInstruction = 2,
    HAS_TEXT_INSTRUCTION_NOT_SET = 0,
  };

  enum HasLengthCase {
    kLength = 4,
    HAS_LENGTH_NOT_SET = 0,
  };

  enum HasTimeCase {
    kTime = 5,
    HAS_TIME_NOT_SET = 0,
  };

  enum HasBeginCardinalDirectionCase {
    kBeginCardinalDirection = 6,
    HAS_BEGIN_CARDINAL_DIRECTION_NOT_SET = 0,
  };

  enum HasBeginHeadingCase {
    kBeginHeading = 7,
    HAS_BEGIN_HEADING_NOT_SET = 0,
  };

  enum HasBeginShapeIndexCase {
    kBeginShapeIndex = 8,
    HAS_BEGIN_SHAPE_INDEX_NOT_SET = 0,
  };

  enum HasEndShapeIndexCase {
    kEndShapeIndex = 9,
    HAS_END_SHAPE_INDEX_NOT_SET = 0,
  };

  enum HasPortionsTollCase {
    kPortionsToll = 10,
    HAS_PORTIONS_TOLL_NOT_SET = 0,
  };

  enum HasPortionsUnpavedCase {
    kPortionsUnpaved = 11,
    HAS_PORTIONS_UNPAVED_NOT_SET = 0,
  };

  enum HasVerbalTransitionAlertInstructionCase {
    kVerbalTransitionAlertInstruction = 12,
    HAS_VERBAL_TRANSITION_ALERT_INSTRUCTION_NOT_SET = 0,
  };

  enum HasVerbalPreTransitionInstructionCase {
    kVerbalPreTransitionInstruction = 13,
    HAS_VERBAL_PRE_TRANSITION_INSTRUCTION_NOT_SET = 0,
  };

  enum HasVerbalPostTransitionInstructionCase {
    kVerbalPostTransitionInstruction = 14,
    HAS_VERBAL_POST_TRANSITION_INSTRUCTION_NOT_SET = 0,
  };

  enum HasRoundaboutExitCountCase {
    kRoundaboutExitCount = 17,
    HAS_ROUNDABOUT_EXIT_COUNT_NOT_SET = 0,
  };

  enum HasDepartInstructionCase {
    kDepartInstruction = 18,
    HAS_DEPART_INSTRUCTION_NOT_SET = 0,
  };

  enum HasVerbalDepartInstructionCase {
    kVerbalDepartInstruction = 19,
    HAS_VERBAL_DEPART_INSTRUCTION_NOT_SET = 0,
  };

  enum HasArriveInstructionCase {
    kArriveInstruction = 20,
    HAS_ARRIVE_INSTRUCTION_NOT_SET = 0,
  };

  enum HasVerbalArriveInstructionCase {
    kVerbalArriveInstruction = 21,
    HAS_VERBAL_ARRIVE_INSTRUCTION_NOT_SET = 0,
  };

  enum HasVerbalMultiCueCase {
    kVerbalMultiCue = 23,
    HAS_VERBAL_MULTI_CUE_NOT_SET = 0,
  };

  enum HasTravelModeCase {
    kTravelMode = 24,
    HAS_TRAVEL_MODE_NOT_SET = 0,
  };

  enum HasVehicleTypeCase {
    kVehicleType = 25,
    HAS_VEHICLE_TYPE_NOT_SET = 0,
  };

  enum HasPedestrianTypeCase {
    kPedestrianType = 26,
    HAS_PEDESTRIAN_TYPE_NOT_SET = 0,
  };

  enum HasBicycleTypeCase {
    kBicycleType = 27,
    HAS_BICYCLE_TYPE_NOT_SET = 0,
  };

  enum HasTransitTypeCase {
    kTransitType = 28,
    HAS_TRANSIT_TYPE_NOT_SET = 0,
  };

  enum HasBeginPathIndexCase {
    kBeginPathIndex = 29,
    HAS_BEGIN_PATH_INDEX_NOT_SET = 0,
  };

  enum HasEndPathIndexCase {
    kEndPathIndex = 30,
    HAS_END_PATH_INDEX_NOT_SET = 0,
  };

  enum HasToStayOnCase {
    kToStayOn = 31,
    HAS_TO_STAY_ON_NOT_SET = 0,
  };

  enum HasTurnDegreeCase {
    kTurnDegree = 33,
    HAS_TURN_DEGREE_NOT_SET = 0,
  };

  enum HasHasTimeRestrictionsCase {
    kHasTimeRestrictions = 34,
    HAS_HAS_TIME_RESTRICTIONS_NOT_SET = 0,
  };

  enum HasBssManeuverTypeCase {
    kBssManeuverType = 36,
    HAS_BSS_MANEUVER_TYPE_NOT_SET = 0,
  };

  enum HasVerbalSuccinctTransitionInstructionCase {
    kVerbalSuccinctTransitionInstruction = 37,
    HAS_VERBAL_SUCCINCT_TRANSITION_INSTRUCTION_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DirectionsLeg_Maneuver* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DirectionsLeg_Maneuver* other);

  // implements Message ----------------------------------------------

  inline DirectionsLeg_Maneuver* New() const { return New(NULL); }

  DirectionsLeg_Maneuver* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DirectionsLeg_Maneuver& from);
  void MergeFrom(const DirectionsLeg_Maneuver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg_Maneuver* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef DirectionsLeg_Maneuver_CardinalDirection CardinalDirection;
  static const CardinalDirection kNorth =
    DirectionsLeg_Maneuver_CardinalDirection_kNorth;
  static const CardinalDirection kNorthEast =
    DirectionsLeg_Maneuver_CardinalDirection_kNorthEast;
  static const CardinalDirection kEast =
    DirectionsLeg_Maneuver_CardinalDirection_kEast;
  static const CardinalDirection kSouthEast =
    DirectionsLeg_Maneuver_CardinalDirection_kSouthEast;
  static const CardinalDirection kSouth =
    DirectionsLeg_Maneuver_CardinalDirection_kSouth;
  static const CardinalDirection kSouthWest =
    DirectionsLeg_Maneuver_CardinalDirection_kSouthWest;
  static const CardinalDirection kWest =
    DirectionsLeg_Maneuver_CardinalDirection_kWest;
  static const CardinalDirection kNorthWest =
    DirectionsLeg_Maneuver_CardinalDirection_kNorthWest;
  static inline bool CardinalDirection_IsValid(int value) {
    return DirectionsLeg_Maneuver_CardinalDirection_IsValid(value);
  }
  static const CardinalDirection CardinalDirection_MIN =
    DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MIN;
  static const CardinalDirection CardinalDirection_MAX =
    DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MAX;
  static const int CardinalDirection_ARRAYSIZE =
    DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_ARRAYSIZE;

  typedef DirectionsLeg_Maneuver_Type Type;
  static const Type kNone =
    DirectionsLeg_Maneuver_Type_kNone;
  static const Type kStart =
    DirectionsLeg_Maneuver_Type_kStart;
  static const Type kStartRight =
    DirectionsLeg_Maneuver_Type_kStartRight;
  static const Type kStartLeft =
    DirectionsLeg_Maneuver_Type_kStartLeft;
  static const Type kDestination =
    DirectionsLeg_Maneuver_Type_kDestination;
  static const Type kDestinationRight =
    DirectionsLeg_Maneuver_Type_kDestinationRight;
  static const Type kDestinationLeft =
    DirectionsLeg_Maneuver_Type_kDestinationLeft;
  static const Type kBecomes =
    DirectionsLeg_Maneuver_Type_kBecomes;
  static const Type kContinue =
    DirectionsLeg_Maneuver_Type_kContinue;
  static const Type kSlightRight =
    DirectionsLeg_Maneuver_Type_kSlightRight;
  static const Type kRight =
    DirectionsLeg_Maneuver_Type_kRight;
  static const Type kSharpRight =
    DirectionsLeg_Maneuver_Type_kSharpRight;
  static const Type kUturnRight =
    DirectionsLeg_Maneuver_Type_kUturnRight;
  static const Type kUturnLeft =
    DirectionsLeg_Maneuver_Type_kUturnLeft;
  static const Type kSharpLeft =
    DirectionsLeg_Maneuver_Type_kSharpLeft;
  static const Type kLeft =
    DirectionsLeg_Maneuver_Type_kLeft;
  static const Type kSlightLeft =
    DirectionsLeg_Maneuver_Type_kSlightLeft;
  static const Type kRampStraight =
    DirectionsLeg_Maneuver_Type_kRampStraight;
  static const Type kRampRight =
    DirectionsLeg_Maneuver_Type_kRampRight;
  static const Type kRampLeft =
    DirectionsLeg_Maneuver_Type_kRampLeft;
  static const Type kExitRight =
    DirectionsLeg_Maneuver_Type_kExitRight;
  static const Type kExitLeft =
    DirectionsLeg_Maneuver_Type_kExitLeft;
  static const Type kStayStraight =
    DirectionsLeg_Maneuver_Type_kStayStraight;
  static const Type kStayRight =
    DirectionsLeg_Maneuver_Type_kStayRight;
  static const Type kStayLeft =
    DirectionsLeg_Maneuver_Type_kStayLeft;
  static const Type kMerge =
    DirectionsLeg_Maneuver_Type_kMerge;
  static const Type kRoundaboutEnter =
    DirectionsLeg_Maneuver_Type_kRoundaboutEnter;
  static const Type kRoundaboutExit =
    DirectionsLeg_Maneuver_Type_kRoundaboutExit;
  static const Type kFerryEnter =
    DirectionsLeg_Maneuver_Type_kFerryEnter;
  static const Type kFerryExit =
    DirectionsLeg_Maneuver_Type_kFerryExit;
  static const Type kTransit =
    DirectionsLeg_Maneuver_Type_kTransit;
  static const Type kTransitTransfer =
    DirectionsLeg_Maneuver_Type_kTransitTransfer;
  static const Type kTransitRemainOn =
    DirectionsLeg_Maneuver_Type_kTransitRemainOn;
  static const Type kTransitConnectionStart =
    DirectionsLeg_Maneuver_Type_kTransitConnectionStart;
  static const Type kTransitConnectionTransfer =
    DirectionsLeg_Maneuver_Type_kTransitConnectionTransfer;
  static const Type kTransitConnectionDestination =
    DirectionsLeg_Maneuver_Type_kTransitConnectionDestination;
  static const Type kPostTransitConnectionDestination =
    DirectionsLeg_Maneuver_Type_kPostTransitConnectionDestination;
  static const Type kMergeRight =
    DirectionsLeg_Maneuver_Type_kMergeRight;
  static const Type kMergeLeft =
    DirectionsLeg_Maneuver_Type_kMergeLeft;
  static inline bool Type_IsValid(int value) {
    return DirectionsLeg_Maneuver_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DirectionsLeg_Maneuver_Type_Type_MIN;
  static const Type Type_MAX =
    DirectionsLeg_Maneuver_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DirectionsLeg_Maneuver_Type_Type_ARRAYSIZE;

  typedef DirectionsLeg_Maneuver_BssManeuverType BssManeuverType;
  static const BssManeuverType kNoneAction =
    DirectionsLeg_Maneuver_BssManeuverType_kNoneAction;
  static const BssManeuverType kRentBikeAtBikeShare =
    DirectionsLeg_Maneuver_BssManeuverType_kRentBikeAtBikeShare;
  static const BssManeuverType kReturnBikeAtBikeShare =
    DirectionsLeg_Maneuver_BssManeuverType_kReturnBikeAtBikeShare;
  static inline bool BssManeuverType_IsValid(int value) {
    return DirectionsLeg_Maneuver_BssManeuverType_IsValid(value);
  }
  static const BssManeuverType BssManeuverType_MIN =
    DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MIN;
  static const BssManeuverType BssManeuverType_MAX =
    DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MAX;
  static const int BssManeuverType_ARRAYSIZE =
    DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .valhalla.DirectionsLeg.Maneuver.Type type = 1;
  private:
  bool has_type() const;
  public:
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::valhalla::DirectionsLeg_Maneuver_Type type() const;
  void set_type(::valhalla::DirectionsLeg_Maneuver_Type value);

  // optional string text_instruction = 2;
  private:
  bool has_text_instruction() const;
  public:
  void clear_text_instruction();
  static const int kTextInstructionFieldNumber = 2;
  const ::std::string& text_instruction() const;
  void set_text_instruction(const ::std::string& value);
  void set_text_instruction(const char* value);
  void set_text_instruction(const char* value, size_t size);
  ::std::string* mutable_text_instruction();
  ::std::string* release_text_instruction();
  void set_allocated_text_instruction(::std::string* text_instruction);

  // repeated .valhalla.StreetName street_name = 3;
  int street_name_size() const;
  void clear_street_name();
  static const int kStreetNameFieldNumber = 3;
  const ::valhalla::StreetName& street_name(int index) const;
  ::valhalla::StreetName* mutable_street_name(int index);
  ::valhalla::StreetName* add_street_name();
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_street_name();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
      street_name() const;

  // optional float length = 4;
  private:
  bool has_length() const;
  public:
  void clear_length();
  static const int kLengthFieldNumber = 4;
  float length() const;
  void set_length(float value);

  // optional double time = 5;
  private:
  bool has_time() const;
  public:
  void clear_time();
  static const int kTimeFieldNumber = 5;
  double time() const;
  void set_time(double value);

  // optional .valhalla.DirectionsLeg.Maneuver.CardinalDirection begin_cardinal_direction = 6;
  private:
  bool has_begin_cardinal_direction() const;
  public:
  void clear_begin_cardinal_direction();
  static const int kBeginCardinalDirectionFieldNumber = 6;
  ::valhalla::DirectionsLeg_Maneuver_CardinalDirection begin_cardinal_direction() const;
  void set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value);

  // optional uint32 begin_heading = 7;
  private:
  bool has_begin_heading() const;
  public:
  void clear_begin_heading();
  static const int kBeginHeadingFieldNumber = 7;
  ::google::protobuf::uint32 begin_heading() const;
  void set_begin_heading(::google::protobuf::uint32 value);

  // optional uint32 begin_shape_index = 8;
  private:
  bool has_begin_shape_index() const;
  public:
  void clear_begin_shape_index();
  static const int kBeginShapeIndexFieldNumber = 8;
  ::google::protobuf::uint32 begin_shape_index() const;
  void set_begin_shape_index(::google::protobuf::uint32 value);

  // optional uint32 end_shape_index = 9;
  private:
  bool has_end_shape_index() const;
  public:
  void clear_end_shape_index();
  static const int kEndShapeIndexFieldNumber = 9;
  ::google::protobuf::uint32 end_shape_index() const;
  void set_end_shape_index(::google::protobuf::uint32 value);

  // optional bool portions_toll = 10;
  private:
  bool has_portions_toll() const;
  public:
  void clear_portions_toll();
  static const int kPortionsTollFieldNumber = 10;
  bool portions_toll() const;
  void set_portions_toll(bool value);

  // optional bool portions_unpaved = 11;
  private:
  bool has_portions_unpaved() const;
  public:
  void clear_portions_unpaved();
  static const int kPortionsUnpavedFieldNumber = 11;
  bool portions_unpaved() const;
  void set_portions_unpaved(bool value);

  // optional string verbal_transition_alert_instruction = 12;
  private:
  bool has_verbal_transition_alert_instruction() const;
  public:
  void clear_verbal_transition_alert_instruction();
  static const int kVerbalTransitionAlertInstructionFieldNumber = 12;
  const ::std::string& verbal_transition_alert_instruction() const;
  void set_verbal_transition_alert_instruction(const ::std::string& value);
  void set_verbal_transition_alert_instruction(const char* value);
  void set_verbal_transition_alert_instruction(const char* value, size_t size);
  ::std::string* mutable_verbal_transition_alert_instruction();
  ::std::string* release_verbal_transition_alert_instruction();
  void set_allocated_verbal_transition_alert_instruction(::std::string* verbal_transition_alert_instruction);

  // optional string verbal_pre_transition_instruction = 13;
  private:
  bool has_verbal_pre_transition_instruction() const;
  public:
  void clear_verbal_pre_transition_instruction();
  static const int kVerbalPreTransitionInstructionFieldNumber = 13;
  const ::std::string& verbal_pre_transition_instruction() const;
  void set_verbal_pre_transition_instruction(const ::std::string& value);
  void set_verbal_pre_transition_instruction(const char* value);
  void set_verbal_pre_transition_instruction(const char* value, size_t size);
  ::std::string* mutable_verbal_pre_transition_instruction();
  ::std::string* release_verbal_pre_transition_instruction();
  void set_allocated_verbal_pre_transition_instruction(::std::string* verbal_pre_transition_instruction);

  // optional string verbal_post_transition_instruction = 14;
  private:
  bool has_verbal_post_transition_instruction() const;
  public:
  void clear_verbal_post_transition_instruction();
  static const int kVerbalPostTransitionInstructionFieldNumber = 14;
  const ::std::string& verbal_post_transition_instruction() const;
  void set_verbal_post_transition_instruction(const ::std::string& value);
  void set_verbal_post_transition_instruction(const char* value);
  void set_verbal_post_transition_instruction(const char* value, size_t size);
  ::std::string* mutable_verbal_post_transition_instruction();
  ::std::string* release_verbal_post_transition_instruction();
  void set_allocated_verbal_post_transition_instruction(::std::string* verbal_post_transition_instruction);

  // repeated .valhalla.StreetName begin_street_name = 15;
  int begin_street_name_size() const;
  void clear_begin_street_name();
  static const int kBeginStreetNameFieldNumber = 15;
  const ::valhalla::StreetName& begin_street_name(int index) const;
  ::valhalla::StreetName* mutable_begin_street_name(int index);
  ::valhalla::StreetName* add_begin_street_name();
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_begin_street_name();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
      begin_street_name() const;

  // optional .valhalla.TripSign sign = 16;
  bool has_sign() const;
  void clear_sign();
  static const int kSignFieldNumber = 16;
  const ::valhalla::TripSign& sign() const;
  ::valhalla::TripSign* mutable_sign();
  ::valhalla::TripSign* release_sign();
  void set_allocated_sign(::valhalla::TripSign* sign);

  // optional uint32 roundabout_exit_count = 17;
  private:
  bool has_roundabout_exit_count() const;
  public:
  void clear_roundabout_exit_count();
  static const int kRoundaboutExitCountFieldNumber = 17;
  ::google::protobuf::uint32 roundabout_exit_count() const;
  void set_roundabout_exit_count(::google::protobuf::uint32 value);

  // optional string depart_instruction = 18;
  private:
  bool has_depart_instruction() const;
  public:
  void clear_depart_instruction();
  static const int kDepartInstructionFieldNumber = 18;
  const ::std::string& depart_instruction() const;
  void set_depart_instruction(const ::std::string& value);
  void set_depart_instruction(const char* value);
  void set_depart_instruction(const char* value, size_t size);
  ::std::string* mutable_depart_instruction();
  ::std::string* release_depart_instruction();
  void set_allocated_depart_instruction(::std::string* depart_instruction);

  // optional string verbal_depart_instruction = 19;
  private:
  bool has_verbal_depart_instruction() const;
  public:
  void clear_verbal_depart_instruction();
  static const int kVerbalDepartInstructionFieldNumber = 19;
  const ::std::string& verbal_depart_instruction() const;
  void set_verbal_depart_instruction(const ::std::string& value);
  void set_verbal_depart_instruction(const char* value);
  void set_verbal_depart_instruction(const char* value, size_t size);
  ::std::string* mutable_verbal_depart_instruction();
  ::std::string* release_verbal_depart_instruction();
  void set_allocated_verbal_depart_instruction(::std::string* verbal_depart_instruction);

  // optional string arrive_instruction = 20;
  private:
  bool has_arrive_instruction() const;
  public:
  void clear_arrive_instruction();
  static const int kArriveInstructionFieldNumber = 20;
  const ::std::string& arrive_instruction() const;
  void set_arrive_instruction(const ::std::string& value);
  void set_arrive_instruction(const char* value);
  void set_arrive_instruction(const char* value, size_t size);
  ::std::string* mutable_arrive_instruction();
  ::std::string* release_arrive_instruction();
  void set_allocated_arrive_instruction(::std::string* arrive_instruction);

  // optional string verbal_arrive_instruction = 21;
  private:
  bool has_verbal_arrive_instruction() const;
  public:
  void clear_verbal_arrive_instruction();
  static const int kVerbalArriveInstructionFieldNumber = 21;
  const ::std::string& verbal_arrive_instruction() const;
  void set_verbal_arrive_instruction(const ::std::string& value);
  void set_verbal_arrive_instruction(const char* value);
  void set_verbal_arrive_instruction(const char* value, size_t size);
  ::std::string* mutable_verbal_arrive_instruction();
  ::std::string* release_verbal_arrive_instruction();
  void set_allocated_verbal_arrive_instruction(::std::string* verbal_arrive_instruction);

  // optional .valhalla.TransitRouteInfo transit_info = 22;
  bool has_transit_info() const;
  void clear_transit_info();
  static const int kTransitInfoFieldNumber = 22;
  const ::valhalla::TransitRouteInfo& transit_info() const;
  ::valhalla::TransitRouteInfo* mutable_transit_info();
  ::valhalla::TransitRouteInfo* release_transit_info();
  void set_allocated_transit_info(::valhalla::TransitRouteInfo* transit_info);

  // optional bool verbal_multi_cue = 23;
  private:
  bool has_verbal_multi_cue() const;
  public:
  void clear_verbal_multi_cue();
  static const int kVerbalMultiCueFieldNumber = 23;
  bool verbal_multi_cue() const;
  void set_verbal_multi_cue(bool value);

  // optional .valhalla.TravelMode travel_mode = 24;
  private:
  bool has_travel_mode() const;
  public:
  void clear_travel_mode();
  static const int kTravelModeFieldNumber = 24;
  ::valhalla::TravelMode travel_mode() const;
  void set_travel_mode(::valhalla::TravelMode value);

  // optional .valhalla.VehicleType vehicle_type = 25;
  private:
  bool has_vehicle_type() const;
  public:
  void clear_vehicle_type();
  static const int kVehicleTypeFieldNumber = 25;
  ::valhalla::VehicleType vehicle_type() const;
  void set_vehicle_type(::valhalla::VehicleType value);

  // optional .valhalla.PedestrianType pedestrian_type = 26;
  private:
  bool has_pedestrian_type() const;
  public:
  void clear_pedestrian_type();
  static const int kPedestrianTypeFieldNumber = 26;
  ::valhalla::PedestrianType pedestrian_type() const;
  void set_pedestrian_type(::valhalla::PedestrianType value);

  // optional .valhalla.BicycleType bicycle_type = 27;
  private:
  bool has_bicycle_type() const;
  public:
  void clear_bicycle_type();
  static const int kBicycleTypeFieldNumber = 27;
  ::valhalla::BicycleType bicycle_type() const;
  void set_bicycle_type(::valhalla::BicycleType value);

  // optional .valhalla.TransitType transit_type = 28;
  private:
  bool has_transit_type() const;
  public:
  void clear_transit_type();
  static const int kTransitTypeFieldNumber = 28;
  ::valhalla::TransitType transit_type() const;
  void set_transit_type(::valhalla::TransitType value);

  // optional uint32 begin_path_index = 29;
  private:
  bool has_begin_path_index() const;
  public:
  void clear_begin_path_index();
  static const int kBeginPathIndexFieldNumber = 29;
  ::google::protobuf::uint32 begin_path_index() const;
  void set_begin_path_index(::google::protobuf::uint32 value);

  // optional uint32 end_path_index = 30;
  private:
  bool has_end_path_index() const;
  public:
  void clear_end_path_index();
  static const int kEndPathIndexFieldNumber = 30;
  ::google::protobuf::uint32 end_path_index() const;
  void set_end_path_index(::google::protobuf::uint32 value);

  // optional bool to_stay_on = 31;
  private:
  bool has_to_stay_on() const;
  public:
  void clear_to_stay_on();
  static const int kToStayOnFieldNumber = 31;
  bool to_stay_on() const;
  void set_to_stay_on(bool value);

  // repeated .valhalla.StreetName roundabout_exit_street_names = 32;
  int roundabout_exit_street_names_size() const;
  void clear_roundabout_exit_street_names();
  static const int kRoundaboutExitStreetNamesFieldNumber = 32;
  const ::valhalla::StreetName& roundabout_exit_street_names(int index) const;
  ::valhalla::StreetName* mutable_roundabout_exit_street_names(int index);
  ::valhalla::StreetName* add_roundabout_exit_street_names();
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_roundabout_exit_street_names();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
      roundabout_exit_street_names() const;

  // optional uint32 turn_degree = 33;
  private:
  bool has_turn_degree() const;
  public:
  void clear_turn_degree();
  static const int kTurnDegreeFieldNumber = 33;
  ::google::protobuf::uint32 turn_degree() const;
  void set_turn_degree(::google::protobuf::uint32 value);

  // optional bool has_time_restrictions = 34;
  private:
  bool has_has_time_restrictions() const;
  public:
  void clear_has_time_restrictions();
  static const int kHasTimeRestrictionsFieldNumber = 34;
  bool has_time_restrictions() const;
  void set_has_time_restrictions(bool value);

  // repeated .valhalla.DirectionsLeg.GuidanceView guidance_views = 35;
  int guidance_views_size() const;
  void clear_guidance_views();
  static const int kGuidanceViewsFieldNumber = 35;
  const ::valhalla::DirectionsLeg_GuidanceView& guidance_views(int index) const;
  ::valhalla::DirectionsLeg_GuidanceView* mutable_guidance_views(int index);
  ::valhalla::DirectionsLeg_GuidanceView* add_guidance_views();
  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView >*
      mutable_guidance_views();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView >&
      guidance_views() const;

  // optional .valhalla.DirectionsLeg.Maneuver.BssManeuverType bss_maneuver_type = 36;
  private:
  bool has_bss_maneuver_type() const;
  public:
  void clear_bss_maneuver_type();
  static const int kBssManeuverTypeFieldNumber = 36;
  ::valhalla::DirectionsLeg_Maneuver_BssManeuverType bss_maneuver_type() const;
  void set_bss_maneuver_type(::valhalla::DirectionsLeg_Maneuver_BssManeuverType value);

  // optional string verbal_succinct_transition_instruction = 37;
  private:
  bool has_verbal_succinct_transition_instruction() const;
  public:
  void clear_verbal_succinct_transition_instruction();
  static const int kVerbalSuccinctTransitionInstructionFieldNumber = 37;
  const ::std::string& verbal_succinct_transition_instruction() const;
  void set_verbal_succinct_transition_instruction(const ::std::string& value);
  void set_verbal_succinct_transition_instruction(const char* value);
  void set_verbal_succinct_transition_instruction(const char* value, size_t size);
  ::std::string* mutable_verbal_succinct_transition_instruction();
  ::std::string* release_verbal_succinct_transition_instruction();
  void set_allocated_verbal_succinct_transition_instruction(::std::string* verbal_succinct_transition_instruction);

  // optional .valhalla.BikeShareStationInfo bss_info = 38;
  bool has_bss_info() const;
  void clear_bss_info();
  static const int kBssInfoFieldNumber = 38;
  const ::valhalla::BikeShareStationInfo& bss_info() const;
  ::valhalla::BikeShareStationInfo* mutable_bss_info();
  ::valhalla::BikeShareStationInfo* release_bss_info();
  void set_allocated_bss_info(::valhalla::BikeShareStationInfo* bss_info);

  HasTypeCase has_type_case() const;
  HasTextInstructionCase has_text_instruction_case() const;
  HasLengthCase has_length_case() const;
  HasTimeCase has_time_case() const;
  HasBeginCardinalDirectionCase has_begin_cardinal_direction_case() const;
  HasBeginHeadingCase has_begin_heading_case() const;
  HasBeginShapeIndexCase has_begin_shape_index_case() const;
  HasEndShapeIndexCase has_end_shape_index_case() const;
  HasPortionsTollCase has_portions_toll_case() const;
  HasPortionsUnpavedCase has_portions_unpaved_case() const;
  HasVerbalTransitionAlertInstructionCase has_verbal_transition_alert_instruction_case() const;
  HasVerbalPreTransitionInstructionCase has_verbal_pre_transition_instruction_case() const;
  HasVerbalPostTransitionInstructionCase has_verbal_post_transition_instruction_case() const;
  HasRoundaboutExitCountCase has_roundabout_exit_count_case() const;
  HasDepartInstructionCase has_depart_instruction_case() const;
  HasVerbalDepartInstructionCase has_verbal_depart_instruction_case() const;
  HasArriveInstructionCase has_arrive_instruction_case() const;
  HasVerbalArriveInstructionCase has_verbal_arrive_instruction_case() const;
  HasVerbalMultiCueCase has_verbal_multi_cue_case() const;
  HasTravelModeCase has_travel_mode_case() const;
  HasVehicleTypeCase has_vehicle_type_case() const;
  HasPedestrianTypeCase has_pedestrian_type_case() const;
  HasBicycleTypeCase has_bicycle_type_case() const;
  HasTransitTypeCase has_transit_type_case() const;
  HasBeginPathIndexCase has_begin_path_index_case() const;
  HasEndPathIndexCase has_end_path_index_case() const;
  HasToStayOnCase has_to_stay_on_case() const;
  HasTurnDegreeCase has_turn_degree_case() const;
  HasHasTimeRestrictionsCase has_has_time_restrictions_case() const;
  HasBssManeuverTypeCase has_bss_maneuver_type_case() const;
  HasVerbalSuccinctTransitionInstructionCase has_verbal_succinct_transition_instruction_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.Maneuver)
 private:
  inline void set_has_type();
  inline void set_has_text_instruction();
  inline void set_has_length();
  inline void set_has_time();
  inline void set_has_begin_cardinal_direction();
  inline void set_has_begin_heading();
  inline void set_has_begin_shape_index();
  inline void set_has_end_shape_index();
  inline void set_has_portions_toll();
  inline void set_has_portions_unpaved();
  inline void set_has_verbal_transition_alert_instruction();
  inline void set_has_verbal_pre_transition_instruction();
  inline void set_has_verbal_post_transition_instruction();
  inline void set_has_roundabout_exit_count();
  inline void set_has_depart_instruction();
  inline void set_has_verbal_depart_instruction();
  inline void set_has_arrive_instruction();
  inline void set_has_verbal_arrive_instruction();
  inline void set_has_verbal_multi_cue();
  inline void set_has_travel_mode();
  inline void set_has_vehicle_type();
  inline void set_has_pedestrian_type();
  inline void set_has_bicycle_type();
  inline void set_has_transit_type();
  inline void set_has_begin_path_index();
  inline void set_has_end_path_index();
  inline void set_has_to_stay_on();
  inline void set_has_turn_degree();
  inline void set_has_has_time_restrictions();
  inline void set_has_bss_maneuver_type();
  inline void set_has_verbal_succinct_transition_instruction();

  inline bool has_has_type() const;
  void clear_has_type();
  inline void clear_has_has_type();

  inline bool has_has_text_instruction() const;
  void clear_has_text_instruction();
  inline void clear_has_has_text_instruction();

  inline bool has_has_length() const;
  void clear_has_length();
  inline void clear_has_has_length();

  inline bool has_has_time() const;
  void clear_has_time();
  inline void clear_has_has_time();

  inline bool has_has_begin_cardinal_direction() const;
  void clear_has_begin_cardinal_direction();
  inline void clear_has_has_begin_cardinal_direction();

  inline bool has_has_begin_heading() const;
  void clear_has_begin_heading();
  inline void clear_has_has_begin_heading();

  inline bool has_has_begin_shape_index() const;
  void clear_has_begin_shape_index();
  inline void clear_has_has_begin_shape_index();

  inline bool has_has_end_shape_index() const;
  void clear_has_end_shape_index();
  inline void clear_has_has_end_shape_index();

  inline bool has_has_portions_toll() const;
  void clear_has_portions_toll();
  inline void clear_has_has_portions_toll();

  inline bool has_has_portions_unpaved() const;
  void clear_has_portions_unpaved();
  inline void clear_has_has_portions_unpaved();

  inline bool has_has_verbal_transition_alert_instruction() const;
  void clear_has_verbal_transition_alert_instruction();
  inline void clear_has_has_verbal_transition_alert_instruction();

  inline bool has_has_verbal_pre_transition_instruction() const;
  void clear_has_verbal_pre_transition_instruction();
  inline void clear_has_has_verbal_pre_transition_instruction();

  inline bool has_has_verbal_post_transition_instruction() const;
  void clear_has_verbal_post_transition_instruction();
  inline void clear_has_has_verbal_post_transition_instruction();

  inline bool has_has_roundabout_exit_count() const;
  void clear_has_roundabout_exit_count();
  inline void clear_has_has_roundabout_exit_count();

  inline bool has_has_depart_instruction() const;
  void clear_has_depart_instruction();
  inline void clear_has_has_depart_instruction();

  inline bool has_has_verbal_depart_instruction() const;
  void clear_has_verbal_depart_instruction();
  inline void clear_has_has_verbal_depart_instruction();

  inline bool has_has_arrive_instruction() const;
  void clear_has_arrive_instruction();
  inline void clear_has_has_arrive_instruction();

  inline bool has_has_verbal_arrive_instruction() const;
  void clear_has_verbal_arrive_instruction();
  inline void clear_has_has_verbal_arrive_instruction();

  inline bool has_has_verbal_multi_cue() const;
  void clear_has_verbal_multi_cue();
  inline void clear_has_has_verbal_multi_cue();

  inline bool has_has_travel_mode() const;
  void clear_has_travel_mode();
  inline void clear_has_has_travel_mode();

  inline bool has_has_vehicle_type() const;
  void clear_has_vehicle_type();
  inline void clear_has_has_vehicle_type();

  inline bool has_has_pedestrian_type() const;
  void clear_has_pedestrian_type();
  inline void clear_has_has_pedestrian_type();

  inline bool has_has_bicycle_type() const;
  void clear_has_bicycle_type();
  inline void clear_has_has_bicycle_type();

  inline bool has_has_transit_type() const;
  void clear_has_transit_type();
  inline void clear_has_has_transit_type();

  inline bool has_has_begin_path_index() const;
  void clear_has_begin_path_index();
  inline void clear_has_has_begin_path_index();

  inline bool has_has_end_path_index() const;
  void clear_has_end_path_index();
  inline void clear_has_has_end_path_index();

  inline bool has_has_to_stay_on() const;
  void clear_has_to_stay_on();
  inline void clear_has_has_to_stay_on();

  inline bool has_has_turn_degree() const;
  void clear_has_turn_degree();
  inline void clear_has_has_turn_degree();

  inline bool has_has_has_time_restrictions() const;
  void clear_has_has_time_restrictions();
  inline void clear_has_has_has_time_restrictions();

  inline bool has_has_bss_maneuver_type() const;
  void clear_has_bss_maneuver_type();
  inline void clear_has_has_bss_maneuver_type();

  inline bool has_has_verbal_succinct_transition_instruction() const;
  void clear_has_verbal_succinct_transition_instruction();
  inline void clear_has_has_verbal_succinct_transition_instruction();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName > street_name_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName > begin_street_name_;
  ::valhalla::TripSign* sign_;
  ::valhalla::TransitRouteInfo* transit_info_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName > roundabout_exit_street_names_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView > guidance_views_;
  ::valhalla::BikeShareStationInfo* bss_info_;
  union HasTypeUnion {
    HasTypeUnion() {}
    int type_;
  } has_type_;
  union HasTextInstructionUnion {
    HasTextInstructionUnion() {}
    ::google::protobuf::internal::ArenaStringPtr text_instruction_;
  } has_text_instruction_;
  union HasLengthUnion {
    HasLengthUnion() {}
    float length_;
  } has_length_;
  union HasTimeUnion {
    HasTimeUnion() {}
    double time_;
  } has_time_;
  union HasBeginCardinalDirectionUnion {
    HasBeginCardinalDirectionUnion() {}
    int begin_cardinal_direction_;
  } has_begin_cardinal_direction_;
  union HasBeginHeadingUnion {
    HasBeginHeadingUnion() {}
    ::google::protobuf::uint32 begin_heading_;
  } has_begin_heading_;
  union HasBeginShapeIndexUnion {
    HasBeginShapeIndexUnion() {}
    ::google::protobuf::uint32 begin_shape_index_;
  } has_begin_shape_index_;
  union HasEndShapeIndexUnion {
    HasEndShapeIndexUnion() {}
    ::google::protobuf::uint32 end_shape_index_;
  } has_end_shape_index_;
  union HasPortionsTollUnion {
    HasPortionsTollUnion() {}
    bool portions_toll_;
  } has_portions_toll_;
  union HasPortionsUnpavedUnion {
    HasPortionsUnpavedUnion() {}
    bool portions_unpaved_;
  } has_portions_unpaved_;
  union HasVerbalTransitionAlertInstructionUnion {
    HasVerbalTransitionAlertInstructionUnion() {}
    ::google::protobuf::internal::ArenaStringPtr verbal_transition_alert_instruction_;
  } has_verbal_transition_alert_instruction_;
  union HasVerbalPreTransitionInstructionUnion {
    HasVerbalPreTransitionInstructionUnion() {}
    ::google::protobuf::internal::ArenaStringPtr verbal_pre_transition_instruction_;
  } has_verbal_pre_transition_instruction_;
  union HasVerbalPostTransitionInstructionUnion {
    HasVerbalPostTransitionInstructionUnion() {}
    ::google::protobuf::internal::ArenaStringPtr verbal_post_transition_instruction_;
  } has_verbal_post_transition_instruction_;
  union HasRoundaboutExitCountUnion {
    HasRoundaboutExitCountUnion() {}
    ::google::protobuf::uint32 roundabout_exit_count_;
  } has_roundabout_exit_count_;
  union HasDepartInstructionUnion {
    HasDepartInstructionUnion() {}
    ::google::protobuf::internal::ArenaStringPtr depart_instruction_;
  } has_depart_instruction_;
  union HasVerbalDepartInstructionUnion {
    HasVerbalDepartInstructionUnion() {}
    ::google::protobuf::internal::ArenaStringPtr verbal_depart_instruction_;
  } has_verbal_depart_instruction_;
  union HasArriveInstructionUnion {
    HasArriveInstructionUnion() {}
    ::google::protobuf::internal::ArenaStringPtr arrive_instruction_;
  } has_arrive_instruction_;
  union HasVerbalArriveInstructionUnion {
    HasVerbalArriveInstructionUnion() {}
    ::google::protobuf::internal::ArenaStringPtr verbal_arrive_instruction_;
  } has_verbal_arrive_instruction_;
  union HasVerbalMultiCueUnion {
    HasVerbalMultiCueUnion() {}
    bool verbal_multi_cue_;
  } has_verbal_multi_cue_;
  union HasTravelModeUnion {
    HasTravelModeUnion() {}
    int travel_mode_;
  } has_travel_mode_;
  union HasVehicleTypeUnion {
    HasVehicleTypeUnion() {}
    int vehicle_type_;
  } has_vehicle_type_;
  union HasPedestrianTypeUnion {
    HasPedestrianTypeUnion() {}
    int pedestrian_type_;
  } has_pedestrian_type_;
  union HasBicycleTypeUnion {
    HasBicycleTypeUnion() {}
    int bicycle_type_;
  } has_bicycle_type_;
  union HasTransitTypeUnion {
    HasTransitTypeUnion() {}
    int transit_type_;
  } has_transit_type_;
  union HasBeginPathIndexUnion {
    HasBeginPathIndexUnion() {}
    ::google::protobuf::uint32 begin_path_index_;
  } has_begin_path_index_;
  union HasEndPathIndexUnion {
    HasEndPathIndexUnion() {}
    ::google::protobuf::uint32 end_path_index_;
  } has_end_path_index_;
  union HasToStayOnUnion {
    HasToStayOnUnion() {}
    bool to_stay_on_;
  } has_to_stay_on_;
  union HasTurnDegreeUnion {
    HasTurnDegreeUnion() {}
    ::google::protobuf::uint32 turn_degree_;
  } has_turn_degree_;
  union HasHasTimeRestrictionsUnion {
    HasHasTimeRestrictionsUnion() {}
    bool has_time_restrictions_;
  } has_has_time_restrictions_;
  union HasBssManeuverTypeUnion {
    HasBssManeuverTypeUnion() {}
    int bss_maneuver_type_;
  } has_bss_maneuver_type_;
  union HasVerbalSuccinctTransitionInstructionUnion {
    HasVerbalSuccinctTransitionInstructionUnion() {}
    ::google::protobuf::internal::ArenaStringPtr verbal_succinct_transition_instruction_;
  } has_verbal_succinct_transition_instruction_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[31];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_directions_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_directions_2eproto();
  #endif
  friend void protobuf_AssignDesc_directions_2eproto();
  friend void protobuf_ShutdownFile_directions_2eproto();

  void InitAsDefaultInstance();
  static DirectionsLeg_Maneuver* default_instance_;
};
// -------------------------------------------------------------------

class DirectionsLeg : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg) */ {
 public:
  DirectionsLeg();
  virtual ~DirectionsLeg();

  DirectionsLeg(const DirectionsLeg& from);

  inline DirectionsLeg& operator=(const DirectionsLeg& from) {
    CopyFrom(from);
    return *this;
  }

  static const DirectionsLeg& default_instance();

  enum HasTripIdCase {
    kTripId = 1,
    HAS_TRIP_ID_NOT_SET = 0,
  };

  enum HasLegIdCase {
    kLegId = 2,
    HAS_LEG_ID_NOT_SET = 0,
  };

  enum HasLegCountCase {
    kLegCount = 3,
    HAS_LEG_COUNT_NOT_SET = 0,
  };

  enum HasShapeCase {
    kShape = 7,
    HAS_SHAPE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DirectionsLeg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DirectionsLeg* other);

  // implements Message ----------------------------------------------

  inline DirectionsLeg* New() const { return New(NULL); }

  DirectionsLeg* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DirectionsLeg& from);
  void MergeFrom(const DirectionsLeg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef DirectionsLeg_Summary Summary;
  typedef DirectionsLeg_GuidanceView GuidanceView;
  typedef DirectionsLeg_Maneuver Maneuver;

  // accessors -------------------------------------------------------

  // optional uint64 trip_id = 1;
  private:
  bool has_trip_id() const;
  public:
  void clear_trip_id();
  static const int kTripIdFieldNumber = 1;
  ::google::protobuf::uint64 trip_id() const;
  void set_trip_id(::google::protobuf::uint64 value);

  // optional uint32 leg_id = 2;
  private:
  bool has_leg_id() const;
  public:
  void clear_leg_id();
  static const int kLegIdFieldNumber = 2;
  ::google::protobuf::uint32 leg_id() const;
  void set_leg_id(::google::protobuf::uint32 value);

  // optional uint32 leg_count = 3;
  private:
  bool has_leg_count() const;
  public:
  void clear_leg_count();
  static const int kLegCountFieldNumber = 3;
  ::google::protobuf::uint32 leg_count() const;
  void set_leg_count(::google::protobuf::uint32 value);

  // repeated .valhalla.Location location = 4;
  int location_size() const;
  void clear_location();
  static const int kLocationFieldNumber = 4;
  const ::valhalla::Location& location(int index) const;
  ::valhalla::Location* mutable_location(int index);
  ::valhalla::Location* add_location();
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_location();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      location() const;

  // optional .valhalla.DirectionsLeg.Summary summary = 5;
  bool has_summary() const;
  void clear_summary();
  static const int kSummaryFieldNumber = 5;
  const ::valhalla::DirectionsLeg_Summary& summary() const;
  ::valhalla::DirectionsLeg_Summary* mutable_summary();
  ::valhalla::DirectionsLeg_Summary* release_summary();
  void set_allocated_summary(::valhalla::DirectionsLeg_Summary* summary);

  // repeated .valhalla.DirectionsLeg.Maneuver maneuver = 6;
  int maneuver_size() const;
  void clear_maneuver();
  static const int kManeuverFieldNumber = 6;
  const ::valhalla::DirectionsLeg_Maneuver& maneuver(int index) const;
  ::valhalla::DirectionsLeg_Maneuver* mutable_maneuver(int index);
  ::valhalla::DirectionsLeg_Maneuver* add_maneuver();
  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >*
      mutable_maneuver();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >&
      maneuver() const;

  // optional string shape = 7;
  private:
  bool has_shape() const;
  public:
  void clear_shape();
  static const int kShapeFieldNumber = 7;
  const ::std::string& shape() const;
  void set_shape(const ::std::string& value);
  void set_shape(const char* value);
  void set_shape(const char* value, size_t size);
  ::std::string* mutable_shape();
  ::std::string* release_shape();
  void set_allocated_shape(::std::string* shape);

  HasTripIdCase has_trip_id_case() const;
  HasLegIdCase has_leg_id_case() const;
  HasLegCountCase has_leg_count_case() const;
  HasShapeCase has_shape_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg)
 private:
  inline void set_has_trip_id();
  inline void set_has_leg_id();
  inline void set_has_leg_count();
  inline void set_has_shape();

  inline bool has_has_trip_id() const;
  void clear_has_trip_id();
  inline void clear_has_has_trip_id();

  inline bool has_has_leg_id() const;
  void clear_has_leg_id();
  inline void clear_has_has_leg_id();

  inline bool has_has_leg_count() const;
  void clear_has_leg_count();
  inline void clear_has_has_leg_count();

  inline bool has_has_shape() const;
  void clear_has_shape();
  inline void clear_has_has_shape();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location > location_;
  ::valhalla::DirectionsLeg_Summary* summary_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver > maneuver_;
  union HasTripIdUnion {
    HasTripIdUnion() {}
    ::google::protobuf::uint64 trip_id_;
  } has_trip_id_;
  union HasLegIdUnion {
    HasLegIdUnion() {}
    ::google::protobuf::uint32 leg_id_;
  } has_leg_id_;
  union HasLegCountUnion {
    HasLegCountUnion() {}
    ::google::protobuf::uint32 leg_count_;
  } has_leg_count_;
  union HasShapeUnion {
    HasShapeUnion() {}
    ::google::protobuf::internal::ArenaStringPtr shape_;
  } has_shape_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[4];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_directions_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_directions_2eproto();
  #endif
  friend void protobuf_AssignDesc_directions_2eproto();
  friend void protobuf_ShutdownFile_directions_2eproto();

  void InitAsDefaultInstance();
  static DirectionsLeg* default_instance_;
};
// -------------------------------------------------------------------

class DirectionsRoute : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsRoute) */ {
 public:
  DirectionsRoute();
  virtual ~DirectionsRoute();

  DirectionsRoute(const DirectionsRoute& from);

  inline DirectionsRoute& operator=(const DirectionsRoute& from) {
    CopyFrom(from);
    return *this;
  }

  static const DirectionsRoute& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DirectionsRoute* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DirectionsRoute* other);

  // implements Message ----------------------------------------------

  inline DirectionsRoute* New() const { return New(NULL); }

  DirectionsRoute* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DirectionsRoute& from);
  void MergeFrom(const DirectionsRoute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsRoute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .valhalla.DirectionsLeg legs = 1;
  int legs_size() const;
  void clear_legs();
  static const int kLegsFieldNumber = 1;
  const ::valhalla::DirectionsLeg& legs(int index) const;
  ::valhalla::DirectionsLeg* mutable_legs(int index);
  ::valhalla::DirectionsLeg* add_legs();
  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg >*
      mutable_legs();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg >&
      legs() const;

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsRoute)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg > legs_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_directions_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_directions_2eproto();
  #endif
  friend void protobuf_AssignDesc_directions_2eproto();
  friend void protobuf_ShutdownFile_directions_2eproto();

  void InitAsDefaultInstance();
  static DirectionsRoute* default_instance_;
};
// -------------------------------------------------------------------

class Directions : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Directions) */ {
 public:
  Directions();
  virtual ~Directions();

  Directions(const Directions& from);

  inline Directions& operator=(const Directions& from) {
    CopyFrom(from);
    return *this;
  }

  static const Directions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Directions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Directions* other);

  // implements Message ----------------------------------------------

  inline Directions* New() const { return New(NULL); }

  Directions* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Directions& from);
  void MergeFrom(const Directions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Directions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .valhalla.DirectionsRoute routes = 1;
  int routes_size() const;
  void clear_routes();
  static const int kRoutesFieldNumber = 1;
  const ::valhalla::DirectionsRoute& routes(int index) const;
  ::valhalla::DirectionsRoute* mutable_routes(int index);
  ::valhalla::DirectionsRoute* add_routes();
  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsRoute >*
      mutable_routes();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsRoute >&
      routes() const;

  // @@protoc_insertion_point(class_scope:valhalla.Directions)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsRoute > routes_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_directions_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_directions_2eproto();
  #endif
  friend void protobuf_AssignDesc_directions_2eproto();
  friend void protobuf_ShutdownFile_directions_2eproto();

  void InitAsDefaultInstance();
  static Directions* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// DirectionsLeg_Summary

// optional float length = 1;
inline bool DirectionsLeg_Summary::has_length() const {
  return has_length_case() == kLength;
}
inline void DirectionsLeg_Summary::set_has_length() {
  _oneof_case_[0] = kLength;
}
inline void DirectionsLeg_Summary::clear_length() {
  if (has_length()) {
    has_length_.length_ = 0;
    clear_has_has_length();
  }
}
inline float DirectionsLeg_Summary::length() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.length)
  if (has_length()) {
    return has_length_.length_;
  }
  return 0;
}
inline void DirectionsLeg_Summary::set_length(float value) {
  if (!has_length()) {
    clear_has_length();
    set_has_length();
  }
  has_length_.length_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Summary.length)
}

// optional double time = 2;
inline bool DirectionsLeg_Summary::has_time() const {
  return has_time_case() == kTime;
}
inline void DirectionsLeg_Summary::set_has_time() {
  _oneof_case_[1] = kTime;
}
inline void DirectionsLeg_Summary::clear_time() {
  if (has_time()) {
    has_time_.time_ = 0;
    clear_has_has_time();
  }
}
inline double DirectionsLeg_Summary::time() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.time)
  if (has_time()) {
    return has_time_.time_;
  }
  return 0;
}
inline void DirectionsLeg_Summary::set_time(double value) {
  if (!has_time()) {
    clear_has_time();
    set_has_time();
  }
  has_time_.time_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Summary.time)
}

// optional .valhalla.BoundingBox bbox = 3;
inline bool DirectionsLeg_Summary::has_bbox() const {
  return !_is_default_instance_ && bbox_ != NULL;
}
inline void DirectionsLeg_Summary::clear_bbox() {
  if (GetArenaNoVirtual() == NULL && bbox_ != NULL) delete bbox_;
  bbox_ = NULL;
}
inline const ::valhalla::BoundingBox& DirectionsLeg_Summary::bbox() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.bbox)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bbox_ != NULL ? *bbox_ : *default_instance().bbox_;
#else
  return bbox_ != NULL ? *bbox_ : *default_instance_->bbox_;
#endif
}
inline ::valhalla::BoundingBox* DirectionsLeg_Summary::mutable_bbox() {
  
  if (bbox_ == NULL) {
    bbox_ = new ::valhalla::BoundingBox;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Summary.bbox)
  return bbox_;
}
inline ::valhalla::BoundingBox* DirectionsLeg_Summary::release_bbox() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Summary.bbox)
  
  ::valhalla::BoundingBox* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline void DirectionsLeg_Summary::set_allocated_bbox(::valhalla::BoundingBox* bbox) {
  delete bbox_;
  bbox_ = bbox;
  if (bbox) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Summary.bbox)
}

// optional bool has_time_restrictions = 4;
inline bool DirectionsLeg_Summary::has_has_time_restrictions() const {
  return has_has_time_restrictions_case() == kHasTimeRestrictions;
}
inline void DirectionsLeg_Summary::set_has_has_time_restrictions() {
  _oneof_case_[2] = kHasTimeRestrictions;
}
inline void DirectionsLeg_Summary::clear_has_time_restrictions() {
  if (has_has_time_restrictions()) {
    has_has_time_restrictions_.has_time_restrictions_ = false;
    clear_has_has_has_time_restrictions();
  }
}
inline bool DirectionsLeg_Summary::has_time_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.has_time_restrictions)
  if (has_has_time_restrictions()) {
    return has_has_time_restrictions_.has_time_restrictions_;
  }
  return false;
}
inline void DirectionsLeg_Summary::set_has_time_restrictions(bool value) {
  if (!has_has_time_restrictions()) {
    clear_has_has_time_restrictions();
    set_has_has_time_restrictions();
  }
  has_has_time_restrictions_.has_time_restrictions_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Summary.has_time_restrictions)
}

inline bool DirectionsLeg_Summary::has_has_length() const {
  return has_length_case() != HAS_LENGTH_NOT_SET;
}
inline void DirectionsLeg_Summary::clear_has_has_length() {
  _oneof_case_[0] = HAS_LENGTH_NOT_SET;
}
inline bool DirectionsLeg_Summary::has_has_time() const {
  return has_time_case() != HAS_TIME_NOT_SET;
}
inline void DirectionsLeg_Summary::clear_has_has_time() {
  _oneof_case_[1] = HAS_TIME_NOT_SET;
}
inline bool DirectionsLeg_Summary::has_has_has_time_restrictions() const {
  return has_has_time_restrictions_case() != HAS_HAS_TIME_RESTRICTIONS_NOT_SET;
}
inline void DirectionsLeg_Summary::clear_has_has_has_time_restrictions() {
  _oneof_case_[2] = HAS_HAS_TIME_RESTRICTIONS_NOT_SET;
}
inline DirectionsLeg_Summary::HasLengthCase DirectionsLeg_Summary::has_length_case() const {
  return DirectionsLeg_Summary::HasLengthCase(_oneof_case_[0]);
}
inline DirectionsLeg_Summary::HasTimeCase DirectionsLeg_Summary::has_time_case() const {
  return DirectionsLeg_Summary::HasTimeCase(_oneof_case_[1]);
}
inline DirectionsLeg_Summary::HasHasTimeRestrictionsCase DirectionsLeg_Summary::has_has_time_restrictions_case() const {
  return DirectionsLeg_Summary::HasHasTimeRestrictionsCase(_oneof_case_[2]);
}
// -------------------------------------------------------------------

// DirectionsLeg_GuidanceView

// optional string data_id = 1;
inline bool DirectionsLeg_GuidanceView::has_data_id() const {
  return has_data_id_case() == kDataId;
}
inline void DirectionsLeg_GuidanceView::set_has_data_id() {
  _oneof_case_[0] = kDataId;
}
inline void DirectionsLeg_GuidanceView::clear_data_id() {
  if (has_data_id()) {
    has_data_id_.data_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_data_id();
  }
}
inline const ::std::string& DirectionsLeg_GuidanceView::data_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.data_id)
  if (has_data_id()) {
    return has_data_id_.data_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_GuidanceView::set_data_id(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.data_id)
  if (!has_data_id()) {
    clear_has_data_id();
    set_has_data_id();
    has_data_id_.data_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_data_id_.data_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.data_id)
}
inline void DirectionsLeg_GuidanceView::set_data_id(const char* value) {
  if (!has_data_id()) {
    clear_has_data_id();
    set_has_data_id();
    has_data_id_.data_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_data_id_.data_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.DirectionsLeg.GuidanceView.data_id)
}
inline void DirectionsLeg_GuidanceView::set_data_id(const char* value, size_t size) {
  if (!has_data_id()) {
    clear_has_data_id();
    set_has_data_id();
    has_data_id_.data_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_data_id_.data_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.DirectionsLeg.GuidanceView.data_id)
}
inline ::std::string* DirectionsLeg_GuidanceView::mutable_data_id() {
  if (!has_data_id()) {
    clear_has_data_id();
    set_has_data_id();
    has_data_id_.data_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.GuidanceView.data_id)
  return has_data_id_.data_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLeg_GuidanceView::release_data_id() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.GuidanceView.data_id)
  if (has_data_id()) {
    clear_has_has_data_id();
    return has_data_id_.data_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void DirectionsLeg_GuidanceView::set_allocated_data_id(::std::string* data_id) {
  if (!has_data_id()) {
    has_data_id_.data_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_data_id();
  if (data_id != NULL) {
    set_has_data_id();
    has_data_id_.data_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        data_id);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.GuidanceView.data_id)
}

// optional .valhalla.DirectionsLeg.GuidanceView.Type type = 2;
inline bool DirectionsLeg_GuidanceView::has_type() const {
  return has_type_case() == kType;
}
inline void DirectionsLeg_GuidanceView::set_has_type() {
  _oneof_case_[1] = kType;
}
inline void DirectionsLeg_GuidanceView::clear_type() {
  if (has_type()) {
    has_type_.type_ = 0;
    clear_has_has_type();
  }
}
inline ::valhalla::DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView::type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.type)
  if (has_type()) {
    return static_cast< ::valhalla::DirectionsLeg_GuidanceView_Type >(has_type_.type_);
  }
  return static_cast< ::valhalla::DirectionsLeg_GuidanceView_Type >(0);
}
inline void DirectionsLeg_GuidanceView::set_type(::valhalla::DirectionsLeg_GuidanceView_Type value) {
  if (!has_type()) {
    clear_has_type();
    set_has_type();
  }
  has_type_.type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.type)
}

// optional string base_id = 3;
inline bool DirectionsLeg_GuidanceView::has_base_id() const {
  return has_base_id_case() == kBaseId;
}
inline void DirectionsLeg_GuidanceView::set_has_base_id() {
  _oneof_case_[2] = kBaseId;
}
inline void DirectionsLeg_GuidanceView::clear_base_id() {
  if (has_base_id()) {
    has_base_id_.base_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_base_id();
  }
}
inline const ::std::string& DirectionsLeg_GuidanceView::base_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.base_id)
  if (has_base_id()) {
    return has_base_id_.base_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_GuidanceView::set_base_id(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.base_id)
  if (!has_base_id()) {
    clear_has_base_id();
    set_has_base_id();
    has_base_id_.base_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_base_id_.base_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.base_id)
}
inline void DirectionsLeg_GuidanceView::set_base_id(const char* value) {
  if (!has_base_id()) {
    clear_has_base_id();
    set_has_base_id();
    has_base_id_.base_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_base_id_.base_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.DirectionsLeg.GuidanceView.base_id)
}
inline void DirectionsLeg_GuidanceView::set_base_id(const char* value, size_t size) {
  if (!has_base_id()) {
    clear_has_base_id();
    set_has_base_id();
    has_base_id_.base_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_base_id_.base_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.DirectionsLeg.GuidanceView.base_id)
}
inline ::std::string* DirectionsLeg_GuidanceView::mutable_base_id() {
  if (!has_base_id()) {
    clear_has_base_id();
    set_has_base_id();
    has_base_id_.base_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.GuidanceView.base_id)
  return has_base_id_.base_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLeg_GuidanceView::release_base_id() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.GuidanceView.base_id)
  if (has_base_id()) {
    clear_has_has_base_id();
    return has_base_id_.base_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void DirectionsLeg_GuidanceView::set_allocated_base_id(::std::string* base_id) {
  if (!has_base_id()) {
    has_base_id_.base_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_base_id();
  if (base_id != NULL) {
    set_has_base_id();
    has_base_id_.base_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        base_id);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.GuidanceView.base_id)
}

// repeated string overlay_ids = 4;
inline int DirectionsLeg_GuidanceView::overlay_ids_size() const {
  return overlay_ids_.size();
}
inline void DirectionsLeg_GuidanceView::clear_overlay_ids() {
  overlay_ids_.Clear();
}
inline const ::std::string& DirectionsLeg_GuidanceView::overlay_ids(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return overlay_ids_.Get(index);
}
inline ::std::string* DirectionsLeg_GuidanceView::mutable_overlay_ids(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return overlay_ids_.Mutable(index);
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  overlay_ids_.Mutable(index)->assign(value);
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, const char* value) {
  overlay_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, const char* value, size_t size) {
  overlay_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline ::std::string* DirectionsLeg_GuidanceView::add_overlay_ids() {
  // @@protoc_insertion_point(field_add_mutable:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return overlay_ids_.Add();
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(const ::std::string& value) {
  overlay_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(const char* value) {
  overlay_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(const char* value, size_t size) {
  overlay_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DirectionsLeg_GuidanceView::overlay_ids() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return overlay_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DirectionsLeg_GuidanceView::mutable_overlay_ids() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return &overlay_ids_;
}

inline bool DirectionsLeg_GuidanceView::has_has_data_id() const {
  return has_data_id_case() != HAS_DATA_ID_NOT_SET;
}
inline void DirectionsLeg_GuidanceView::clear_has_has_data_id() {
  _oneof_case_[0] = HAS_DATA_ID_NOT_SET;
}
inline bool DirectionsLeg_GuidanceView::has_has_type() const {
  return has_type_case() != HAS_TYPE_NOT_SET;
}
inline void DirectionsLeg_GuidanceView::clear_has_has_type() {
  _oneof_case_[1] = HAS_TYPE_NOT_SET;
}
inline bool DirectionsLeg_GuidanceView::has_has_base_id() const {
  return has_base_id_case() != HAS_BASE_ID_NOT_SET;
}
inline void DirectionsLeg_GuidanceView::clear_has_has_base_id() {
  _oneof_case_[2] = HAS_BASE_ID_NOT_SET;
}
inline DirectionsLeg_GuidanceView::HasDataIdCase DirectionsLeg_GuidanceView::has_data_id_case() const {
  return DirectionsLeg_GuidanceView::HasDataIdCase(_oneof_case_[0]);
}
inline DirectionsLeg_GuidanceView::HasTypeCase DirectionsLeg_GuidanceView::has_type_case() const {
  return DirectionsLeg_GuidanceView::HasTypeCase(_oneof_case_[1]);
}
inline DirectionsLeg_GuidanceView::HasBaseIdCase DirectionsLeg_GuidanceView::has_base_id_case() const {
  return DirectionsLeg_GuidanceView::HasBaseIdCase(_oneof_case_[2]);
}
// -------------------------------------------------------------------

// DirectionsLeg_Maneuver

// optional .valhalla.DirectionsLeg.Maneuver.Type type = 1;
inline bool DirectionsLeg_Maneuver::has_type() const {
  return has_type_case() == kType;
}
inline void DirectionsLeg_Maneuver::set_has_type() {
  _oneof_case_[0] = kType;
}
inline void DirectionsLeg_Maneuver::clear_type() {
  if (has_type()) {
    has_type_.type_ = 0;
    clear_has_has_type();
  }
}
inline ::valhalla::DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.type)
  if (has_type()) {
    return static_cast< ::valhalla::DirectionsLeg_Maneuver_Type >(has_type_.type_);
  }
  return static_cast< ::valhalla::DirectionsLeg_Maneuver_Type >(0);
}
inline void DirectionsLeg_Maneuver::set_type(::valhalla::DirectionsLeg_Maneuver_Type value) {
  if (!has_type()) {
    clear_has_type();
    set_has_type();
  }
  has_type_.type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.type)
}

// optional string text_instruction = 2;
inline bool DirectionsLeg_Maneuver::has_text_instruction() const {
  return has_text_instruction_case() == kTextInstruction;
}
inline void DirectionsLeg_Maneuver::set_has_text_instruction() {
  _oneof_case_[1] = kTextInstruction;
}
inline void DirectionsLeg_Maneuver::clear_text_instruction() {
  if (has_text_instruction()) {
    has_text_instruction_.text_instruction_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_text_instruction();
  }
}
inline const ::std::string& DirectionsLeg_Maneuver::text_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.text_instruction)
  if (has_text_instruction()) {
    return has_text_instruction_.text_instruction_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_Maneuver::set_text_instruction(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.text_instruction)
  if (!has_text_instruction()) {
    clear_has_text_instruction();
    set_has_text_instruction();
    has_text_instruction_.text_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_text_instruction_.text_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.text_instruction)
}
inline void DirectionsLeg_Maneuver::set_text_instruction(const char* value) {
  if (!has_text_instruction()) {
    clear_has_text_instruction();
    set_has_text_instruction();
    has_text_instruction_.text_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_text_instruction_.text_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.DirectionsLeg.Maneuver.text_instruction)
}
inline void DirectionsLeg_Maneuver::set_text_instruction(const char* value, size_t size) {
  if (!has_text_instruction()) {
    clear_has_text_instruction();
    set_has_text_instruction();
    has_text_instruction_.text_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_text_instruction_.text_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.DirectionsLeg.Maneuver.text_instruction)
}
inline ::std::string* DirectionsLeg_Maneuver::mutable_text_instruction() {
  if (!has_text_instruction()) {
    clear_has_text_instruction();
    set_has_text_instruction();
    has_text_instruction_.text_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.text_instruction)
  return has_text_instruction_.text_instruction_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLeg_Maneuver::release_text_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.text_instruction)
  if (has_text_instruction()) {
    clear_has_has_text_instruction();
    return has_text_instruction_.text_instruction_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_text_instruction(::std::string* text_instruction) {
  if (!has_text_instruction()) {
    has_text_instruction_.text_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_text_instruction();
  if (text_instruction != NULL) {
    set_has_text_instruction();
    has_text_instruction_.text_instruction_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        text_instruction);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.text_instruction)
}

// repeated .valhalla.StreetName street_name = 3;
inline int DirectionsLeg_Maneuver::street_name_size() const {
  return street_name_.size();
}
inline void DirectionsLeg_Maneuver::clear_street_name() {
  street_name_.Clear();
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::street_name(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.street_name)
  return street_name_.Get(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::mutable_street_name(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.street_name)
  return street_name_.Mutable(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::add_street_name() {
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.street_name)
  return street_name_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
DirectionsLeg_Maneuver::mutable_street_name() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.street_name)
  return &street_name_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
DirectionsLeg_Maneuver::street_name() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.street_name)
  return street_name_;
}

// optional float length = 4;
inline bool DirectionsLeg_Maneuver::has_length() const {
  return has_length_case() == kLength;
}
inline void DirectionsLeg_Maneuver::set_has_length() {
  _oneof_case_[2] = kLength;
}
inline void DirectionsLeg_Maneuver::clear_length() {
  if (has_length()) {
    has_length_.length_ = 0;
    clear_has_has_length();
  }
}
inline float DirectionsLeg_Maneuver::length() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.length)
  if (has_length()) {
    return has_length_.length_;
  }
  return 0;
}
inline void DirectionsLeg_Maneuver::set_length(float value) {
  if (!has_length()) {
    clear_has_length();
    set_has_length();
  }
  has_length_.length_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.length)
}

// optional double time = 5;
inline bool DirectionsLeg_Maneuver::has_time() const {
  return has_time_case() == kTime;
}
inline void DirectionsLeg_Maneuver::set_has_time() {
  _oneof_case_[3] = kTime;
}
inline void DirectionsLeg_Maneuver::clear_time() {
  if (has_time()) {
    has_time_.time_ = 0;
    clear_has_has_time();
  }
}
inline double DirectionsLeg_Maneuver::time() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.time)
  if (has_time()) {
    return has_time_.time_;
  }
  return 0;
}
inline void DirectionsLeg_Maneuver::set_time(double value) {
  if (!has_time()) {
    clear_has_time();
    set_has_time();
  }
  has_time_.time_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.time)
}

// optional .valhalla.DirectionsLeg.Maneuver.CardinalDirection begin_cardinal_direction = 6;
inline bool DirectionsLeg_Maneuver::has_begin_cardinal_direction() const {
  return has_begin_cardinal_direction_case() == kBeginCardinalDirection;
}
inline void DirectionsLeg_Maneuver::set_has_begin_cardinal_direction() {
  _oneof_case_[4] = kBeginCardinalDirection;
}
inline void DirectionsLeg_Maneuver::clear_begin_cardinal_direction() {
  if (has_begin_cardinal_direction()) {
    has_begin_cardinal_direction_.begin_cardinal_direction_ = 0;
    clear_has_has_begin_cardinal_direction();
  }
}
inline ::valhalla::DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::begin_cardinal_direction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_cardinal_direction)
  if (has_begin_cardinal_direction()) {
    return static_cast< ::valhalla::DirectionsLeg_Maneuver_CardinalDirection >(has_begin_cardinal_direction_.begin_cardinal_direction_);
  }
  return static_cast< ::valhalla::DirectionsLeg_Maneuver_CardinalDirection >(0);
}
inline void DirectionsLeg_Maneuver::set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value) {
  if (!has_begin_cardinal_direction()) {
    clear_has_begin_cardinal_direction();
    set_has_begin_cardinal_direction();
  }
  has_begin_cardinal_direction_.begin_cardinal_direction_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_cardinal_direction)
}

// optional uint32 begin_heading = 7;
inline bool DirectionsLeg_Maneuver::has_begin_heading() const {
  return has_begin_heading_case() == kBeginHeading;
}
inline void DirectionsLeg_Maneuver::set_has_begin_heading() {
  _oneof_case_[5] = kBeginHeading;
}
inline void DirectionsLeg_Maneuver::clear_begin_heading() {
  if (has_begin_heading()) {
    has_begin_heading_.begin_heading_ = 0u;
    clear_has_has_begin_heading();
  }
}
inline ::google::protobuf::uint32 DirectionsLeg_Maneuver::begin_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_heading)
  if (has_begin_heading()) {
    return has_begin_heading_.begin_heading_;
  }
  return 0u;
}
inline void DirectionsLeg_Maneuver::set_begin_heading(::google::protobuf::uint32 value) {
  if (!has_begin_heading()) {
    clear_has_begin_heading();
    set_has_begin_heading();
  }
  has_begin_heading_.begin_heading_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_heading)
}

// optional uint32 begin_shape_index = 8;
inline bool DirectionsLeg_Maneuver::has_begin_shape_index() const {
  return has_begin_shape_index_case() == kBeginShapeIndex;
}
inline void DirectionsLeg_Maneuver::set_has_begin_shape_index() {
  _oneof_case_[6] = kBeginShapeIndex;
}
inline void DirectionsLeg_Maneuver::clear_begin_shape_index() {
  if (has_begin_shape_index()) {
    has_begin_shape_index_.begin_shape_index_ = 0u;
    clear_has_has_begin_shape_index();
  }
}
inline ::google::protobuf::uint32 DirectionsLeg_Maneuver::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_shape_index)
  if (has_begin_shape_index()) {
    return has_begin_shape_index_.begin_shape_index_;
  }
  return 0u;
}
inline void DirectionsLeg_Maneuver::set_begin_shape_index(::google::protobuf::uint32 value) {
  if (!has_begin_shape_index()) {
    clear_has_begin_shape_index();
    set_has_begin_shape_index();
  }
  has_begin_shape_index_.begin_shape_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_shape_index)
}

// optional uint32 end_shape_index = 9;
inline bool DirectionsLeg_Maneuver::has_end_shape_index() const {
  return has_end_shape_index_case() == kEndShapeIndex;
}
inline void DirectionsLeg_Maneuver::set_has_end_shape_index() {
  _oneof_case_[7] = kEndShapeIndex;
}
inline void DirectionsLeg_Maneuver::clear_end_shape_index() {
  if (has_end_shape_index()) {
    has_end_shape_index_.end_shape_index_ = 0u;
    clear_has_has_end_shape_index();
  }
}
inline ::google::protobuf::uint32 DirectionsLeg_Maneuver::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.end_shape_index)
  if (has_end_shape_index()) {
    return has_end_shape_index_.end_shape_index_;
  }
  return 0u;
}
inline void DirectionsLeg_Maneuver::set_end_shape_index(::google::protobuf::uint32 value) {
  if (!has_end_shape_index()) {
    clear_has_end_shape_index();
    set_has_end_shape_index();
  }
  has_end_shape_index_.end_shape_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.end_shape_index)
}

// optional bool portions_toll = 10;
inline bool DirectionsLeg_Maneuver::has_portions_toll() const {
  return has_portions_toll_case() == kPortionsToll;
}
inline void DirectionsLeg_Maneuver::set_has_portions_toll() {
  _oneof_case_[8] = kPortionsToll;
}
inline void DirectionsLeg_Maneuver::clear_portions_toll() {
  if (has_portions_toll()) {
    has_portions_toll_.portions_toll_ = false;
    clear_has_has_portions_toll();
  }
}
inline bool DirectionsLeg_Maneuver::portions_toll() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.portions_toll)
  if (has_portions_toll()) {
    return has_portions_toll_.portions_toll_;
  }
  return false;
}
inline void DirectionsLeg_Maneuver::set_portions_toll(bool value) {
  if (!has_portions_toll()) {
    clear_has_portions_toll();
    set_has_portions_toll();
  }
  has_portions_toll_.portions_toll_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.portions_toll)
}

// optional bool portions_unpaved = 11;
inline bool DirectionsLeg_Maneuver::has_portions_unpaved() const {
  return has_portions_unpaved_case() == kPortionsUnpaved;
}
inline void DirectionsLeg_Maneuver::set_has_portions_unpaved() {
  _oneof_case_[9] = kPortionsUnpaved;
}
inline void DirectionsLeg_Maneuver::clear_portions_unpaved() {
  if (has_portions_unpaved()) {
    has_portions_unpaved_.portions_unpaved_ = false;
    clear_has_has_portions_unpaved();
  }
}
inline bool DirectionsLeg_Maneuver::portions_unpaved() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.portions_unpaved)
  if (has_portions_unpaved()) {
    return has_portions_unpaved_.portions_unpaved_;
  }
  return false;
}
inline void DirectionsLeg_Maneuver::set_portions_unpaved(bool value) {
  if (!has_portions_unpaved()) {
    clear_has_portions_unpaved();
    set_has_portions_unpaved();
  }
  has_portions_unpaved_.portions_unpaved_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.portions_unpaved)
}

// optional string verbal_transition_alert_instruction = 12;
inline bool DirectionsLeg_Maneuver::has_verbal_transition_alert_instruction() const {
  return has_verbal_transition_alert_instruction_case() == kVerbalTransitionAlertInstruction;
}
inline void DirectionsLeg_Maneuver::set_has_verbal_transition_alert_instruction() {
  _oneof_case_[10] = kVerbalTransitionAlertInstruction;
}
inline void DirectionsLeg_Maneuver::clear_verbal_transition_alert_instruction() {
  if (has_verbal_transition_alert_instruction()) {
    has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_verbal_transition_alert_instruction();
  }
}
inline const ::std::string& DirectionsLeg_Maneuver::verbal_transition_alert_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
  if (has_verbal_transition_alert_instruction()) {
    return has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_Maneuver::set_verbal_transition_alert_instruction(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
  if (!has_verbal_transition_alert_instruction()) {
    clear_has_verbal_transition_alert_instruction();
    set_has_verbal_transition_alert_instruction();
    has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
}
inline void DirectionsLeg_Maneuver::set_verbal_transition_alert_instruction(const char* value) {
  if (!has_verbal_transition_alert_instruction()) {
    clear_has_verbal_transition_alert_instruction();
    set_has_verbal_transition_alert_instruction();
    has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
}
inline void DirectionsLeg_Maneuver::set_verbal_transition_alert_instruction(const char* value, size_t size) {
  if (!has_verbal_transition_alert_instruction()) {
    clear_has_verbal_transition_alert_instruction();
    set_has_verbal_transition_alert_instruction();
    has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
}
inline ::std::string* DirectionsLeg_Maneuver::mutable_verbal_transition_alert_instruction() {
  if (!has_verbal_transition_alert_instruction()) {
    clear_has_verbal_transition_alert_instruction();
    set_has_verbal_transition_alert_instruction();
    has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
  return has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLeg_Maneuver::release_verbal_transition_alert_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
  if (has_verbal_transition_alert_instruction()) {
    clear_has_has_verbal_transition_alert_instruction();
    return has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_transition_alert_instruction(::std::string* verbal_transition_alert_instruction) {
  if (!has_verbal_transition_alert_instruction()) {
    has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_verbal_transition_alert_instruction();
  if (verbal_transition_alert_instruction != NULL) {
    set_has_verbal_transition_alert_instruction();
    has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        verbal_transition_alert_instruction);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
}

// optional string verbal_pre_transition_instruction = 13;
inline bool DirectionsLeg_Maneuver::has_verbal_pre_transition_instruction() const {
  return has_verbal_pre_transition_instruction_case() == kVerbalPreTransitionInstruction;
}
inline void DirectionsLeg_Maneuver::set_has_verbal_pre_transition_instruction() {
  _oneof_case_[11] = kVerbalPreTransitionInstruction;
}
inline void DirectionsLeg_Maneuver::clear_verbal_pre_transition_instruction() {
  if (has_verbal_pre_transition_instruction()) {
    has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_verbal_pre_transition_instruction();
  }
}
inline const ::std::string& DirectionsLeg_Maneuver::verbal_pre_transition_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
  if (has_verbal_pre_transition_instruction()) {
    return has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_Maneuver::set_verbal_pre_transition_instruction(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
  if (!has_verbal_pre_transition_instruction()) {
    clear_has_verbal_pre_transition_instruction();
    set_has_verbal_pre_transition_instruction();
    has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
}
inline void DirectionsLeg_Maneuver::set_verbal_pre_transition_instruction(const char* value) {
  if (!has_verbal_pre_transition_instruction()) {
    clear_has_verbal_pre_transition_instruction();
    set_has_verbal_pre_transition_instruction();
    has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
}
inline void DirectionsLeg_Maneuver::set_verbal_pre_transition_instruction(const char* value, size_t size) {
  if (!has_verbal_pre_transition_instruction()) {
    clear_has_verbal_pre_transition_instruction();
    set_has_verbal_pre_transition_instruction();
    has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
}
inline ::std::string* DirectionsLeg_Maneuver::mutable_verbal_pre_transition_instruction() {
  if (!has_verbal_pre_transition_instruction()) {
    clear_has_verbal_pre_transition_instruction();
    set_has_verbal_pre_transition_instruction();
    has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
  return has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLeg_Maneuver::release_verbal_pre_transition_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
  if (has_verbal_pre_transition_instruction()) {
    clear_has_has_verbal_pre_transition_instruction();
    return has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_pre_transition_instruction(::std::string* verbal_pre_transition_instruction) {
  if (!has_verbal_pre_transition_instruction()) {
    has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_verbal_pre_transition_instruction();
  if (verbal_pre_transition_instruction != NULL) {
    set_has_verbal_pre_transition_instruction();
    has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        verbal_pre_transition_instruction);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
}

// optional string verbal_post_transition_instruction = 14;
inline bool DirectionsLeg_Maneuver::has_verbal_post_transition_instruction() const {
  return has_verbal_post_transition_instruction_case() == kVerbalPostTransitionInstruction;
}
inline void DirectionsLeg_Maneuver::set_has_verbal_post_transition_instruction() {
  _oneof_case_[12] = kVerbalPostTransitionInstruction;
}
inline void DirectionsLeg_Maneuver::clear_verbal_post_transition_instruction() {
  if (has_verbal_post_transition_instruction()) {
    has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_verbal_post_transition_instruction();
  }
}
inline const ::std::string& DirectionsLeg_Maneuver::verbal_post_transition_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
  if (has_verbal_post_transition_instruction()) {
    return has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_Maneuver::set_verbal_post_transition_instruction(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
  if (!has_verbal_post_transition_instruction()) {
    clear_has_verbal_post_transition_instruction();
    set_has_verbal_post_transition_instruction();
    has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
}
inline void DirectionsLeg_Maneuver::set_verbal_post_transition_instruction(const char* value) {
  if (!has_verbal_post_transition_instruction()) {
    clear_has_verbal_post_transition_instruction();
    set_has_verbal_post_transition_instruction();
    has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
}
inline void DirectionsLeg_Maneuver::set_verbal_post_transition_instruction(const char* value, size_t size) {
  if (!has_verbal_post_transition_instruction()) {
    clear_has_verbal_post_transition_instruction();
    set_has_verbal_post_transition_instruction();
    has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
}
inline ::std::string* DirectionsLeg_Maneuver::mutable_verbal_post_transition_instruction() {
  if (!has_verbal_post_transition_instruction()) {
    clear_has_verbal_post_transition_instruction();
    set_has_verbal_post_transition_instruction();
    has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
  return has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLeg_Maneuver::release_verbal_post_transition_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
  if (has_verbal_post_transition_instruction()) {
    clear_has_has_verbal_post_transition_instruction();
    return has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_post_transition_instruction(::std::string* verbal_post_transition_instruction) {
  if (!has_verbal_post_transition_instruction()) {
    has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_verbal_post_transition_instruction();
  if (verbal_post_transition_instruction != NULL) {
    set_has_verbal_post_transition_instruction();
    has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        verbal_post_transition_instruction);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
}

// repeated .valhalla.StreetName begin_street_name = 15;
inline int DirectionsLeg_Maneuver::begin_street_name_size() const {
  return begin_street_name_.size();
}
inline void DirectionsLeg_Maneuver::clear_begin_street_name() {
  begin_street_name_.Clear();
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::begin_street_name(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return begin_street_name_.Get(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::mutable_begin_street_name(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return begin_street_name_.Mutable(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::add_begin_street_name() {
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return begin_street_name_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
DirectionsLeg_Maneuver::mutable_begin_street_name() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return &begin_street_name_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
DirectionsLeg_Maneuver::begin_street_name() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return begin_street_name_;
}

// optional .valhalla.TripSign sign = 16;
inline bool DirectionsLeg_Maneuver::has_sign() const {
  return !_is_default_instance_ && sign_ != NULL;
}
inline void DirectionsLeg_Maneuver::clear_sign() {
  if (GetArenaNoVirtual() == NULL && sign_ != NULL) delete sign_;
  sign_ = NULL;
}
inline const ::valhalla::TripSign& DirectionsLeg_Maneuver::sign() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.sign)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sign_ != NULL ? *sign_ : *default_instance().sign_;
#else
  return sign_ != NULL ? *sign_ : *default_instance_->sign_;
#endif
}
inline ::valhalla::TripSign* DirectionsLeg_Maneuver::mutable_sign() {
  
  if (sign_ == NULL) {
    sign_ = new ::valhalla::TripSign;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.sign)
  return sign_;
}
inline ::valhalla::TripSign* DirectionsLeg_Maneuver::release_sign() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.sign)
  
  ::valhalla::TripSign* temp = sign_;
  sign_ = NULL;
  return temp;
}
inline void DirectionsLeg_Maneuver::set_allocated_sign(::valhalla::TripSign* sign) {
  delete sign_;
  sign_ = sign;
  if (sign) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.sign)
}

// optional uint32 roundabout_exit_count = 17;
inline bool DirectionsLeg_Maneuver::has_roundabout_exit_count() const {
  return has_roundabout_exit_count_case() == kRoundaboutExitCount;
}
inline void DirectionsLeg_Maneuver::set_has_roundabout_exit_count() {
  _oneof_case_[13] = kRoundaboutExitCount;
}
inline void DirectionsLeg_Maneuver::clear_roundabout_exit_count() {
  if (has_roundabout_exit_count()) {
    has_roundabout_exit_count_.roundabout_exit_count_ = 0u;
    clear_has_has_roundabout_exit_count();
  }
}
inline ::google::protobuf::uint32 DirectionsLeg_Maneuver::roundabout_exit_count() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.roundabout_exit_count)
  if (has_roundabout_exit_count()) {
    return has_roundabout_exit_count_.roundabout_exit_count_;
  }
  return 0u;
}
inline void DirectionsLeg_Maneuver::set_roundabout_exit_count(::google::protobuf::uint32 value) {
  if (!has_roundabout_exit_count()) {
    clear_has_roundabout_exit_count();
    set_has_roundabout_exit_count();
  }
  has_roundabout_exit_count_.roundabout_exit_count_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.roundabout_exit_count)
}

// optional string depart_instruction = 18;
inline bool DirectionsLeg_Maneuver::has_depart_instruction() const {
  return has_depart_instruction_case() == kDepartInstruction;
}
inline void DirectionsLeg_Maneuver::set_has_depart_instruction() {
  _oneof_case_[14] = kDepartInstruction;
}
inline void DirectionsLeg_Maneuver::clear_depart_instruction() {
  if (has_depart_instruction()) {
    has_depart_instruction_.depart_instruction_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_depart_instruction();
  }
}
inline const ::std::string& DirectionsLeg_Maneuver::depart_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.depart_instruction)
  if (has_depart_instruction()) {
    return has_depart_instruction_.depart_instruction_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_Maneuver::set_depart_instruction(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.depart_instruction)
  if (!has_depart_instruction()) {
    clear_has_depart_instruction();
    set_has_depart_instruction();
    has_depart_instruction_.depart_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_depart_instruction_.depart_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.depart_instruction)
}
inline void DirectionsLeg_Maneuver::set_depart_instruction(const char* value) {
  if (!has_depart_instruction()) {
    clear_has_depart_instruction();
    set_has_depart_instruction();
    has_depart_instruction_.depart_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_depart_instruction_.depart_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.DirectionsLeg.Maneuver.depart_instruction)
}
inline void DirectionsLeg_Maneuver::set_depart_instruction(const char* value, size_t size) {
  if (!has_depart_instruction()) {
    clear_has_depart_instruction();
    set_has_depart_instruction();
    has_depart_instruction_.depart_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_depart_instruction_.depart_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.DirectionsLeg.Maneuver.depart_instruction)
}
inline ::std::string* DirectionsLeg_Maneuver::mutable_depart_instruction() {
  if (!has_depart_instruction()) {
    clear_has_depart_instruction();
    set_has_depart_instruction();
    has_depart_instruction_.depart_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.depart_instruction)
  return has_depart_instruction_.depart_instruction_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLeg_Maneuver::release_depart_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.depart_instruction)
  if (has_depart_instruction()) {
    clear_has_has_depart_instruction();
    return has_depart_instruction_.depart_instruction_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_depart_instruction(::std::string* depart_instruction) {
  if (!has_depart_instruction()) {
    has_depart_instruction_.depart_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_depart_instruction();
  if (depart_instruction != NULL) {
    set_has_depart_instruction();
    has_depart_instruction_.depart_instruction_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        depart_instruction);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.depart_instruction)
}

// optional string verbal_depart_instruction = 19;
inline bool DirectionsLeg_Maneuver::has_verbal_depart_instruction() const {
  return has_verbal_depart_instruction_case() == kVerbalDepartInstruction;
}
inline void DirectionsLeg_Maneuver::set_has_verbal_depart_instruction() {
  _oneof_case_[15] = kVerbalDepartInstruction;
}
inline void DirectionsLeg_Maneuver::clear_verbal_depart_instruction() {
  if (has_verbal_depart_instruction()) {
    has_verbal_depart_instruction_.verbal_depart_instruction_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_verbal_depart_instruction();
  }
}
inline const ::std::string& DirectionsLeg_Maneuver::verbal_depart_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
  if (has_verbal_depart_instruction()) {
    return has_verbal_depart_instruction_.verbal_depart_instruction_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_Maneuver::set_verbal_depart_instruction(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
  if (!has_verbal_depart_instruction()) {
    clear_has_verbal_depart_instruction();
    set_has_verbal_depart_instruction();
    has_verbal_depart_instruction_.verbal_depart_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_depart_instruction_.verbal_depart_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
}
inline void DirectionsLeg_Maneuver::set_verbal_depart_instruction(const char* value) {
  if (!has_verbal_depart_instruction()) {
    clear_has_verbal_depart_instruction();
    set_has_verbal_depart_instruction();
    has_verbal_depart_instruction_.verbal_depart_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_depart_instruction_.verbal_depart_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
}
inline void DirectionsLeg_Maneuver::set_verbal_depart_instruction(const char* value, size_t size) {
  if (!has_verbal_depart_instruction()) {
    clear_has_verbal_depart_instruction();
    set_has_verbal_depart_instruction();
    has_verbal_depart_instruction_.verbal_depart_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_depart_instruction_.verbal_depart_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
}
inline ::std::string* DirectionsLeg_Maneuver::mutable_verbal_depart_instruction() {
  if (!has_verbal_depart_instruction()) {
    clear_has_verbal_depart_instruction();
    set_has_verbal_depart_instruction();
    has_verbal_depart_instruction_.verbal_depart_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
  return has_verbal_depart_instruction_.verbal_depart_instruction_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLeg_Maneuver::release_verbal_depart_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
  if (has_verbal_depart_instruction()) {
    clear_has_has_verbal_depart_instruction();
    return has_verbal_depart_instruction_.verbal_depart_instruction_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_depart_instruction(::std::string* verbal_depart_instruction) {
  if (!has_verbal_depart_instruction()) {
    has_verbal_depart_instruction_.verbal_depart_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_verbal_depart_instruction();
  if (verbal_depart_instruction != NULL) {
    set_has_verbal_depart_instruction();
    has_verbal_depart_instruction_.verbal_depart_instruction_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        verbal_depart_instruction);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
}

// optional string arrive_instruction = 20;
inline bool DirectionsLeg_Maneuver::has_arrive_instruction() const {
  return has_arrive_instruction_case() == kArriveInstruction;
}
inline void DirectionsLeg_Maneuver::set_has_arrive_instruction() {
  _oneof_case_[16] = kArriveInstruction;
}
inline void DirectionsLeg_Maneuver::clear_arrive_instruction() {
  if (has_arrive_instruction()) {
    has_arrive_instruction_.arrive_instruction_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_arrive_instruction();
  }
}
inline const ::std::string& DirectionsLeg_Maneuver::arrive_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
  if (has_arrive_instruction()) {
    return has_arrive_instruction_.arrive_instruction_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_Maneuver::set_arrive_instruction(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
  if (!has_arrive_instruction()) {
    clear_has_arrive_instruction();
    set_has_arrive_instruction();
    has_arrive_instruction_.arrive_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_arrive_instruction_.arrive_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
}
inline void DirectionsLeg_Maneuver::set_arrive_instruction(const char* value) {
  if (!has_arrive_instruction()) {
    clear_has_arrive_instruction();
    set_has_arrive_instruction();
    has_arrive_instruction_.arrive_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_arrive_instruction_.arrive_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
}
inline void DirectionsLeg_Maneuver::set_arrive_instruction(const char* value, size_t size) {
  if (!has_arrive_instruction()) {
    clear_has_arrive_instruction();
    set_has_arrive_instruction();
    has_arrive_instruction_.arrive_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_arrive_instruction_.arrive_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
}
inline ::std::string* DirectionsLeg_Maneuver::mutable_arrive_instruction() {
  if (!has_arrive_instruction()) {
    clear_has_arrive_instruction();
    set_has_arrive_instruction();
    has_arrive_instruction_.arrive_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
  return has_arrive_instruction_.arrive_instruction_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLeg_Maneuver::release_arrive_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
  if (has_arrive_instruction()) {
    clear_has_has_arrive_instruction();
    return has_arrive_instruction_.arrive_instruction_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_arrive_instruction(::std::string* arrive_instruction) {
  if (!has_arrive_instruction()) {
    has_arrive_instruction_.arrive_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_arrive_instruction();
  if (arrive_instruction != NULL) {
    set_has_arrive_instruction();
    has_arrive_instruction_.arrive_instruction_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        arrive_instruction);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
}

// optional string verbal_arrive_instruction = 21;
inline bool DirectionsLeg_Maneuver::has_verbal_arrive_instruction() const {
  return has_verbal_arrive_instruction_case() == kVerbalArriveInstruction;
}
inline void DirectionsLeg_Maneuver::set_has_verbal_arrive_instruction() {
  _oneof_case_[17] = kVerbalArriveInstruction;
}
inline void DirectionsLeg_Maneuver::clear_verbal_arrive_instruction() {
  if (has_verbal_arrive_instruction()) {
    has_verbal_arrive_instruction_.verbal_arrive_instruction_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_verbal_arrive_instruction();
  }
}
inline const ::std::string& DirectionsLeg_Maneuver::verbal_arrive_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
  if (has_verbal_arrive_instruction()) {
    return has_verbal_arrive_instruction_.verbal_arrive_instruction_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_Maneuver::set_verbal_arrive_instruction(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
  if (!has_verbal_arrive_instruction()) {
    clear_has_verbal_arrive_instruction();
    set_has_verbal_arrive_instruction();
    has_verbal_arrive_instruction_.verbal_arrive_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_arrive_instruction_.verbal_arrive_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
}
inline void DirectionsLeg_Maneuver::set_verbal_arrive_instruction(const char* value) {
  if (!has_verbal_arrive_instruction()) {
    clear_has_verbal_arrive_instruction();
    set_has_verbal_arrive_instruction();
    has_verbal_arrive_instruction_.verbal_arrive_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_arrive_instruction_.verbal_arrive_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
}
inline void DirectionsLeg_Maneuver::set_verbal_arrive_instruction(const char* value, size_t size) {
  if (!has_verbal_arrive_instruction()) {
    clear_has_verbal_arrive_instruction();
    set_has_verbal_arrive_instruction();
    has_verbal_arrive_instruction_.verbal_arrive_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_arrive_instruction_.verbal_arrive_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
}
inline ::std::string* DirectionsLeg_Maneuver::mutable_verbal_arrive_instruction() {
  if (!has_verbal_arrive_instruction()) {
    clear_has_verbal_arrive_instruction();
    set_has_verbal_arrive_instruction();
    has_verbal_arrive_instruction_.verbal_arrive_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
  return has_verbal_arrive_instruction_.verbal_arrive_instruction_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLeg_Maneuver::release_verbal_arrive_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
  if (has_verbal_arrive_instruction()) {
    clear_has_has_verbal_arrive_instruction();
    return has_verbal_arrive_instruction_.verbal_arrive_instruction_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_arrive_instruction(::std::string* verbal_arrive_instruction) {
  if (!has_verbal_arrive_instruction()) {
    has_verbal_arrive_instruction_.verbal_arrive_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_verbal_arrive_instruction();
  if (verbal_arrive_instruction != NULL) {
    set_has_verbal_arrive_instruction();
    has_verbal_arrive_instruction_.verbal_arrive_instruction_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        verbal_arrive_instruction);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
}

// optional .valhalla.TransitRouteInfo transit_info = 22;
inline bool DirectionsLeg_Maneuver::has_transit_info() const {
  return !_is_default_instance_ && transit_info_ != NULL;
}
inline void DirectionsLeg_Maneuver::clear_transit_info() {
  if (GetArenaNoVirtual() == NULL && transit_info_ != NULL) delete transit_info_;
  transit_info_ = NULL;
}
inline const ::valhalla::TransitRouteInfo& DirectionsLeg_Maneuver::transit_info() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.transit_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transit_info_ != NULL ? *transit_info_ : *default_instance().transit_info_;
#else
  return transit_info_ != NULL ? *transit_info_ : *default_instance_->transit_info_;
#endif
}
inline ::valhalla::TransitRouteInfo* DirectionsLeg_Maneuver::mutable_transit_info() {
  
  if (transit_info_ == NULL) {
    transit_info_ = new ::valhalla::TransitRouteInfo;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.transit_info)
  return transit_info_;
}
inline ::valhalla::TransitRouteInfo* DirectionsLeg_Maneuver::release_transit_info() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.transit_info)
  
  ::valhalla::TransitRouteInfo* temp = transit_info_;
  transit_info_ = NULL;
  return temp;
}
inline void DirectionsLeg_Maneuver::set_allocated_transit_info(::valhalla::TransitRouteInfo* transit_info) {
  delete transit_info_;
  transit_info_ = transit_info;
  if (transit_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.transit_info)
}

// optional bool verbal_multi_cue = 23;
inline bool DirectionsLeg_Maneuver::has_verbal_multi_cue() const {
  return has_verbal_multi_cue_case() == kVerbalMultiCue;
}
inline void DirectionsLeg_Maneuver::set_has_verbal_multi_cue() {
  _oneof_case_[18] = kVerbalMultiCue;
}
inline void DirectionsLeg_Maneuver::clear_verbal_multi_cue() {
  if (has_verbal_multi_cue()) {
    has_verbal_multi_cue_.verbal_multi_cue_ = false;
    clear_has_has_verbal_multi_cue();
  }
}
inline bool DirectionsLeg_Maneuver::verbal_multi_cue() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_multi_cue)
  if (has_verbal_multi_cue()) {
    return has_verbal_multi_cue_.verbal_multi_cue_;
  }
  return false;
}
inline void DirectionsLeg_Maneuver::set_verbal_multi_cue(bool value) {
  if (!has_verbal_multi_cue()) {
    clear_has_verbal_multi_cue();
    set_has_verbal_multi_cue();
  }
  has_verbal_multi_cue_.verbal_multi_cue_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_multi_cue)
}

// optional .valhalla.TravelMode travel_mode = 24;
inline bool DirectionsLeg_Maneuver::has_travel_mode() const {
  return has_travel_mode_case() == kTravelMode;
}
inline void DirectionsLeg_Maneuver::set_has_travel_mode() {
  _oneof_case_[19] = kTravelMode;
}
inline void DirectionsLeg_Maneuver::clear_travel_mode() {
  if (has_travel_mode()) {
    has_travel_mode_.travel_mode_ = 0;
    clear_has_has_travel_mode();
  }
}
inline ::valhalla::TravelMode DirectionsLeg_Maneuver::travel_mode() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.travel_mode)
  if (has_travel_mode()) {
    return static_cast< ::valhalla::TravelMode >(has_travel_mode_.travel_mode_);
  }
  return static_cast< ::valhalla::TravelMode >(0);
}
inline void DirectionsLeg_Maneuver::set_travel_mode(::valhalla::TravelMode value) {
  if (!has_travel_mode()) {
    clear_has_travel_mode();
    set_has_travel_mode();
  }
  has_travel_mode_.travel_mode_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.travel_mode)
}

// optional .valhalla.VehicleType vehicle_type = 25;
inline bool DirectionsLeg_Maneuver::has_vehicle_type() const {
  return has_vehicle_type_case() == kVehicleType;
}
inline void DirectionsLeg_Maneuver::set_has_vehicle_type() {
  _oneof_case_[20] = kVehicleType;
}
inline void DirectionsLeg_Maneuver::clear_vehicle_type() {
  if (has_vehicle_type()) {
    has_vehicle_type_.vehicle_type_ = 0;
    clear_has_has_vehicle_type();
  }
}
inline ::valhalla::VehicleType DirectionsLeg_Maneuver::vehicle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.vehicle_type)
  if (has_vehicle_type()) {
    return static_cast< ::valhalla::VehicleType >(has_vehicle_type_.vehicle_type_);
  }
  return static_cast< ::valhalla::VehicleType >(0);
}
inline void DirectionsLeg_Maneuver::set_vehicle_type(::valhalla::VehicleType value) {
  if (!has_vehicle_type()) {
    clear_has_vehicle_type();
    set_has_vehicle_type();
  }
  has_vehicle_type_.vehicle_type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.vehicle_type)
}

// optional .valhalla.PedestrianType pedestrian_type = 26;
inline bool DirectionsLeg_Maneuver::has_pedestrian_type() const {
  return has_pedestrian_type_case() == kPedestrianType;
}
inline void DirectionsLeg_Maneuver::set_has_pedestrian_type() {
  _oneof_case_[21] = kPedestrianType;
}
inline void DirectionsLeg_Maneuver::clear_pedestrian_type() {
  if (has_pedestrian_type()) {
    has_pedestrian_type_.pedestrian_type_ = 0;
    clear_has_has_pedestrian_type();
  }
}
inline ::valhalla::PedestrianType DirectionsLeg_Maneuver::pedestrian_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.pedestrian_type)
  if (has_pedestrian_type()) {
    return static_cast< ::valhalla::PedestrianType >(has_pedestrian_type_.pedestrian_type_);
  }
  return static_cast< ::valhalla::PedestrianType >(0);
}
inline void DirectionsLeg_Maneuver::set_pedestrian_type(::valhalla::PedestrianType value) {
  if (!has_pedestrian_type()) {
    clear_has_pedestrian_type();
    set_has_pedestrian_type();
  }
  has_pedestrian_type_.pedestrian_type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.pedestrian_type)
}

// optional .valhalla.BicycleType bicycle_type = 27;
inline bool DirectionsLeg_Maneuver::has_bicycle_type() const {
  return has_bicycle_type_case() == kBicycleType;
}
inline void DirectionsLeg_Maneuver::set_has_bicycle_type() {
  _oneof_case_[22] = kBicycleType;
}
inline void DirectionsLeg_Maneuver::clear_bicycle_type() {
  if (has_bicycle_type()) {
    has_bicycle_type_.bicycle_type_ = 0;
    clear_has_has_bicycle_type();
  }
}
inline ::valhalla::BicycleType DirectionsLeg_Maneuver::bicycle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.bicycle_type)
  if (has_bicycle_type()) {
    return static_cast< ::valhalla::BicycleType >(has_bicycle_type_.bicycle_type_);
  }
  return static_cast< ::valhalla::BicycleType >(0);
}
inline void DirectionsLeg_Maneuver::set_bicycle_type(::valhalla::BicycleType value) {
  if (!has_bicycle_type()) {
    clear_has_bicycle_type();
    set_has_bicycle_type();
  }
  has_bicycle_type_.bicycle_type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.bicycle_type)
}

// optional .valhalla.TransitType transit_type = 28;
inline bool DirectionsLeg_Maneuver::has_transit_type() const {
  return has_transit_type_case() == kTransitType;
}
inline void DirectionsLeg_Maneuver::set_has_transit_type() {
  _oneof_case_[23] = kTransitType;
}
inline void DirectionsLeg_Maneuver::clear_transit_type() {
  if (has_transit_type()) {
    has_transit_type_.transit_type_ = 0;
    clear_has_has_transit_type();
  }
}
inline ::valhalla::TransitType DirectionsLeg_Maneuver::transit_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.transit_type)
  if (has_transit_type()) {
    return static_cast< ::valhalla::TransitType >(has_transit_type_.transit_type_);
  }
  return static_cast< ::valhalla::TransitType >(0);
}
inline void DirectionsLeg_Maneuver::set_transit_type(::valhalla::TransitType value) {
  if (!has_transit_type()) {
    clear_has_transit_type();
    set_has_transit_type();
  }
  has_transit_type_.transit_type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.transit_type)
}

// optional uint32 begin_path_index = 29;
inline bool DirectionsLeg_Maneuver::has_begin_path_index() const {
  return has_begin_path_index_case() == kBeginPathIndex;
}
inline void DirectionsLeg_Maneuver::set_has_begin_path_index() {
  _oneof_case_[24] = kBeginPathIndex;
}
inline void DirectionsLeg_Maneuver::clear_begin_path_index() {
  if (has_begin_path_index()) {
    has_begin_path_index_.begin_path_index_ = 0u;
    clear_has_has_begin_path_index();
  }
}
inline ::google::protobuf::uint32 DirectionsLeg_Maneuver::begin_path_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_path_index)
  if (has_begin_path_index()) {
    return has_begin_path_index_.begin_path_index_;
  }
  return 0u;
}
inline void DirectionsLeg_Maneuver::set_begin_path_index(::google::protobuf::uint32 value) {
  if (!has_begin_path_index()) {
    clear_has_begin_path_index();
    set_has_begin_path_index();
  }
  has_begin_path_index_.begin_path_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_path_index)
}

// optional uint32 end_path_index = 30;
inline bool DirectionsLeg_Maneuver::has_end_path_index() const {
  return has_end_path_index_case() == kEndPathIndex;
}
inline void DirectionsLeg_Maneuver::set_has_end_path_index() {
  _oneof_case_[25] = kEndPathIndex;
}
inline void DirectionsLeg_Maneuver::clear_end_path_index() {
  if (has_end_path_index()) {
    has_end_path_index_.end_path_index_ = 0u;
    clear_has_has_end_path_index();
  }
}
inline ::google::protobuf::uint32 DirectionsLeg_Maneuver::end_path_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.end_path_index)
  if (has_end_path_index()) {
    return has_end_path_index_.end_path_index_;
  }
  return 0u;
}
inline void DirectionsLeg_Maneuver::set_end_path_index(::google::protobuf::uint32 value) {
  if (!has_end_path_index()) {
    clear_has_end_path_index();
    set_has_end_path_index();
  }
  has_end_path_index_.end_path_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.end_path_index)
}

// optional bool to_stay_on = 31;
inline bool DirectionsLeg_Maneuver::has_to_stay_on() const {
  return has_to_stay_on_case() == kToStayOn;
}
inline void DirectionsLeg_Maneuver::set_has_to_stay_on() {
  _oneof_case_[26] = kToStayOn;
}
inline void DirectionsLeg_Maneuver::clear_to_stay_on() {
  if (has_to_stay_on()) {
    has_to_stay_on_.to_stay_on_ = false;
    clear_has_has_to_stay_on();
  }
}
inline bool DirectionsLeg_Maneuver::to_stay_on() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.to_stay_on)
  if (has_to_stay_on()) {
    return has_to_stay_on_.to_stay_on_;
  }
  return false;
}
inline void DirectionsLeg_Maneuver::set_to_stay_on(bool value) {
  if (!has_to_stay_on()) {
    clear_has_to_stay_on();
    set_has_to_stay_on();
  }
  has_to_stay_on_.to_stay_on_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.to_stay_on)
}

// repeated .valhalla.StreetName roundabout_exit_street_names = 32;
inline int DirectionsLeg_Maneuver::roundabout_exit_street_names_size() const {
  return roundabout_exit_street_names_.size();
}
inline void DirectionsLeg_Maneuver::clear_roundabout_exit_street_names() {
  roundabout_exit_street_names_.Clear();
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::roundabout_exit_street_names(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return roundabout_exit_street_names_.Get(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::mutable_roundabout_exit_street_names(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return roundabout_exit_street_names_.Mutable(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::add_roundabout_exit_street_names() {
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return roundabout_exit_street_names_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
DirectionsLeg_Maneuver::mutable_roundabout_exit_street_names() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return &roundabout_exit_street_names_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
DirectionsLeg_Maneuver::roundabout_exit_street_names() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return roundabout_exit_street_names_;
}

// optional uint32 turn_degree = 33;
inline bool DirectionsLeg_Maneuver::has_turn_degree() const {
  return has_turn_degree_case() == kTurnDegree;
}
inline void DirectionsLeg_Maneuver::set_has_turn_degree() {
  _oneof_case_[27] = kTurnDegree;
}
inline void DirectionsLeg_Maneuver::clear_turn_degree() {
  if (has_turn_degree()) {
    has_turn_degree_.turn_degree_ = 0u;
    clear_has_has_turn_degree();
  }
}
inline ::google::protobuf::uint32 DirectionsLeg_Maneuver::turn_degree() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.turn_degree)
  if (has_turn_degree()) {
    return has_turn_degree_.turn_degree_;
  }
  return 0u;
}
inline void DirectionsLeg_Maneuver::set_turn_degree(::google::protobuf::uint32 value) {
  if (!has_turn_degree()) {
    clear_has_turn_degree();
    set_has_turn_degree();
  }
  has_turn_degree_.turn_degree_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.turn_degree)
}

// optional bool has_time_restrictions = 34;
inline bool DirectionsLeg_Maneuver::has_has_time_restrictions() const {
  return has_has_time_restrictions_case() == kHasTimeRestrictions;
}
inline void DirectionsLeg_Maneuver::set_has_has_time_restrictions() {
  _oneof_case_[28] = kHasTimeRestrictions;
}
inline void DirectionsLeg_Maneuver::clear_has_time_restrictions() {
  if (has_has_time_restrictions()) {
    has_has_time_restrictions_.has_time_restrictions_ = false;
    clear_has_has_has_time_restrictions();
  }
}
inline bool DirectionsLeg_Maneuver::has_time_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.has_time_restrictions)
  if (has_has_time_restrictions()) {
    return has_has_time_restrictions_.has_time_restrictions_;
  }
  return false;
}
inline void DirectionsLeg_Maneuver::set_has_time_restrictions(bool value) {
  if (!has_has_time_restrictions()) {
    clear_has_has_time_restrictions();
    set_has_has_time_restrictions();
  }
  has_has_time_restrictions_.has_time_restrictions_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.has_time_restrictions)
}

// repeated .valhalla.DirectionsLeg.GuidanceView guidance_views = 35;
inline int DirectionsLeg_Maneuver::guidance_views_size() const {
  return guidance_views_.size();
}
inline void DirectionsLeg_Maneuver::clear_guidance_views() {
  guidance_views_.Clear();
}
inline const ::valhalla::DirectionsLeg_GuidanceView& DirectionsLeg_Maneuver::guidance_views(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return guidance_views_.Get(index);
}
inline ::valhalla::DirectionsLeg_GuidanceView* DirectionsLeg_Maneuver::mutable_guidance_views(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return guidance_views_.Mutable(index);
}
inline ::valhalla::DirectionsLeg_GuidanceView* DirectionsLeg_Maneuver::add_guidance_views() {
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return guidance_views_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView >*
DirectionsLeg_Maneuver::mutable_guidance_views() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return &guidance_views_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView >&
DirectionsLeg_Maneuver::guidance_views() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return guidance_views_;
}

// optional .valhalla.DirectionsLeg.Maneuver.BssManeuverType bss_maneuver_type = 36;
inline bool DirectionsLeg_Maneuver::has_bss_maneuver_type() const {
  return has_bss_maneuver_type_case() == kBssManeuverType;
}
inline void DirectionsLeg_Maneuver::set_has_bss_maneuver_type() {
  _oneof_case_[29] = kBssManeuverType;
}
inline void DirectionsLeg_Maneuver::clear_bss_maneuver_type() {
  if (has_bss_maneuver_type()) {
    has_bss_maneuver_type_.bss_maneuver_type_ = 0;
    clear_has_has_bss_maneuver_type();
  }
}
inline ::valhalla::DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver::bss_maneuver_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.bss_maneuver_type)
  if (has_bss_maneuver_type()) {
    return static_cast< ::valhalla::DirectionsLeg_Maneuver_BssManeuverType >(has_bss_maneuver_type_.bss_maneuver_type_);
  }
  return static_cast< ::valhalla::DirectionsLeg_Maneuver_BssManeuverType >(0);
}
inline void DirectionsLeg_Maneuver::set_bss_maneuver_type(::valhalla::DirectionsLeg_Maneuver_BssManeuverType value) {
  if (!has_bss_maneuver_type()) {
    clear_has_bss_maneuver_type();
    set_has_bss_maneuver_type();
  }
  has_bss_maneuver_type_.bss_maneuver_type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.bss_maneuver_type)
}

// optional string verbal_succinct_transition_instruction = 37;
inline bool DirectionsLeg_Maneuver::has_verbal_succinct_transition_instruction() const {
  return has_verbal_succinct_transition_instruction_case() == kVerbalSuccinctTransitionInstruction;
}
inline void DirectionsLeg_Maneuver::set_has_verbal_succinct_transition_instruction() {
  _oneof_case_[30] = kVerbalSuccinctTransitionInstruction;
}
inline void DirectionsLeg_Maneuver::clear_verbal_succinct_transition_instruction() {
  if (has_verbal_succinct_transition_instruction()) {
    has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_verbal_succinct_transition_instruction();
  }
}
inline const ::std::string& DirectionsLeg_Maneuver::verbal_succinct_transition_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
  if (has_verbal_succinct_transition_instruction()) {
    return has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_Maneuver::set_verbal_succinct_transition_instruction(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
  if (!has_verbal_succinct_transition_instruction()) {
    clear_has_verbal_succinct_transition_instruction();
    set_has_verbal_succinct_transition_instruction();
    has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
}
inline void DirectionsLeg_Maneuver::set_verbal_succinct_transition_instruction(const char* value) {
  if (!has_verbal_succinct_transition_instruction()) {
    clear_has_verbal_succinct_transition_instruction();
    set_has_verbal_succinct_transition_instruction();
    has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
}
inline void DirectionsLeg_Maneuver::set_verbal_succinct_transition_instruction(const char* value, size_t size) {
  if (!has_verbal_succinct_transition_instruction()) {
    clear_has_verbal_succinct_transition_instruction();
    set_has_verbal_succinct_transition_instruction();
    has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
}
inline ::std::string* DirectionsLeg_Maneuver::mutable_verbal_succinct_transition_instruction() {
  if (!has_verbal_succinct_transition_instruction()) {
    clear_has_verbal_succinct_transition_instruction();
    set_has_verbal_succinct_transition_instruction();
    has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
  return has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLeg_Maneuver::release_verbal_succinct_transition_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
  if (has_verbal_succinct_transition_instruction()) {
    clear_has_has_verbal_succinct_transition_instruction();
    return has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_succinct_transition_instruction(::std::string* verbal_succinct_transition_instruction) {
  if (!has_verbal_succinct_transition_instruction()) {
    has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_verbal_succinct_transition_instruction();
  if (verbal_succinct_transition_instruction != NULL) {
    set_has_verbal_succinct_transition_instruction();
    has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        verbal_succinct_transition_instruction);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
}

// optional .valhalla.BikeShareStationInfo bss_info = 38;
inline bool DirectionsLeg_Maneuver::has_bss_info() const {
  return !_is_default_instance_ && bss_info_ != NULL;
}
inline void DirectionsLeg_Maneuver::clear_bss_info() {
  if (GetArenaNoVirtual() == NULL && bss_info_ != NULL) delete bss_info_;
  bss_info_ = NULL;
}
inline const ::valhalla::BikeShareStationInfo& DirectionsLeg_Maneuver::bss_info() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.bss_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bss_info_ != NULL ? *bss_info_ : *default_instance().bss_info_;
#else
  return bss_info_ != NULL ? *bss_info_ : *default_instance_->bss_info_;
#endif
}
inline ::valhalla::BikeShareStationInfo* DirectionsLeg_Maneuver::mutable_bss_info() {
  
  if (bss_info_ == NULL) {
    bss_info_ = new ::valhalla::BikeShareStationInfo;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.bss_info)
  return bss_info_;
}
inline ::valhalla::BikeShareStationInfo* DirectionsLeg_Maneuver::release_bss_info() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.bss_info)
  
  ::valhalla::BikeShareStationInfo* temp = bss_info_;
  bss_info_ = NULL;
  return temp;
}
inline void DirectionsLeg_Maneuver::set_allocated_bss_info(::valhalla::BikeShareStationInfo* bss_info) {
  delete bss_info_;
  bss_info_ = bss_info;
  if (bss_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.bss_info)
}

inline bool DirectionsLeg_Maneuver::has_has_type() const {
  return has_type_case() != HAS_TYPE_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_type() {
  _oneof_case_[0] = HAS_TYPE_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_text_instruction() const {
  return has_text_instruction_case() != HAS_TEXT_INSTRUCTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_text_instruction() {
  _oneof_case_[1] = HAS_TEXT_INSTRUCTION_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_length() const {
  return has_length_case() != HAS_LENGTH_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_length() {
  _oneof_case_[2] = HAS_LENGTH_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_time() const {
  return has_time_case() != HAS_TIME_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_time() {
  _oneof_case_[3] = HAS_TIME_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_begin_cardinal_direction() const {
  return has_begin_cardinal_direction_case() != HAS_BEGIN_CARDINAL_DIRECTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_begin_cardinal_direction() {
  _oneof_case_[4] = HAS_BEGIN_CARDINAL_DIRECTION_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_begin_heading() const {
  return has_begin_heading_case() != HAS_BEGIN_HEADING_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_begin_heading() {
  _oneof_case_[5] = HAS_BEGIN_HEADING_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_begin_shape_index() const {
  return has_begin_shape_index_case() != HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_begin_shape_index() {
  _oneof_case_[6] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_end_shape_index() const {
  return has_end_shape_index_case() != HAS_END_SHAPE_INDEX_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_end_shape_index() {
  _oneof_case_[7] = HAS_END_SHAPE_INDEX_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_portions_toll() const {
  return has_portions_toll_case() != HAS_PORTIONS_TOLL_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_portions_toll() {
  _oneof_case_[8] = HAS_PORTIONS_TOLL_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_portions_unpaved() const {
  return has_portions_unpaved_case() != HAS_PORTIONS_UNPAVED_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_portions_unpaved() {
  _oneof_case_[9] = HAS_PORTIONS_UNPAVED_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_verbal_transition_alert_instruction() const {
  return has_verbal_transition_alert_instruction_case() != HAS_VERBAL_TRANSITION_ALERT_INSTRUCTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_verbal_transition_alert_instruction() {
  _oneof_case_[10] = HAS_VERBAL_TRANSITION_ALERT_INSTRUCTION_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_verbal_pre_transition_instruction() const {
  return has_verbal_pre_transition_instruction_case() != HAS_VERBAL_PRE_TRANSITION_INSTRUCTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_verbal_pre_transition_instruction() {
  _oneof_case_[11] = HAS_VERBAL_PRE_TRANSITION_INSTRUCTION_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_verbal_post_transition_instruction() const {
  return has_verbal_post_transition_instruction_case() != HAS_VERBAL_POST_TRANSITION_INSTRUCTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_verbal_post_transition_instruction() {
  _oneof_case_[12] = HAS_VERBAL_POST_TRANSITION_INSTRUCTION_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_roundabout_exit_count() const {
  return has_roundabout_exit_count_case() != HAS_ROUNDABOUT_EXIT_COUNT_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_roundabout_exit_count() {
  _oneof_case_[13] = HAS_ROUNDABOUT_EXIT_COUNT_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_depart_instruction() const {
  return has_depart_instruction_case() != HAS_DEPART_INSTRUCTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_depart_instruction() {
  _oneof_case_[14] = HAS_DEPART_INSTRUCTION_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_verbal_depart_instruction() const {
  return has_verbal_depart_instruction_case() != HAS_VERBAL_DEPART_INSTRUCTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_verbal_depart_instruction() {
  _oneof_case_[15] = HAS_VERBAL_DEPART_INSTRUCTION_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_arrive_instruction() const {
  return has_arrive_instruction_case() != HAS_ARRIVE_INSTRUCTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_arrive_instruction() {
  _oneof_case_[16] = HAS_ARRIVE_INSTRUCTION_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_verbal_arrive_instruction() const {
  return has_verbal_arrive_instruction_case() != HAS_VERBAL_ARRIVE_INSTRUCTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_verbal_arrive_instruction() {
  _oneof_case_[17] = HAS_VERBAL_ARRIVE_INSTRUCTION_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_verbal_multi_cue() const {
  return has_verbal_multi_cue_case() != HAS_VERBAL_MULTI_CUE_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_verbal_multi_cue() {
  _oneof_case_[18] = HAS_VERBAL_MULTI_CUE_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_travel_mode() const {
  return has_travel_mode_case() != HAS_TRAVEL_MODE_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_travel_mode() {
  _oneof_case_[19] = HAS_TRAVEL_MODE_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_vehicle_type() const {
  return has_vehicle_type_case() != HAS_VEHICLE_TYPE_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_vehicle_type() {
  _oneof_case_[20] = HAS_VEHICLE_TYPE_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_pedestrian_type() const {
  return has_pedestrian_type_case() != HAS_PEDESTRIAN_TYPE_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_pedestrian_type() {
  _oneof_case_[21] = HAS_PEDESTRIAN_TYPE_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_bicycle_type() const {
  return has_bicycle_type_case() != HAS_BICYCLE_TYPE_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_bicycle_type() {
  _oneof_case_[22] = HAS_BICYCLE_TYPE_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_transit_type() const {
  return has_transit_type_case() != HAS_TRANSIT_TYPE_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_transit_type() {
  _oneof_case_[23] = HAS_TRANSIT_TYPE_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_begin_path_index() const {
  return has_begin_path_index_case() != HAS_BEGIN_PATH_INDEX_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_begin_path_index() {
  _oneof_case_[24] = HAS_BEGIN_PATH_INDEX_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_end_path_index() const {
  return has_end_path_index_case() != HAS_END_PATH_INDEX_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_end_path_index() {
  _oneof_case_[25] = HAS_END_PATH_INDEX_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_to_stay_on() const {
  return has_to_stay_on_case() != HAS_TO_STAY_ON_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_to_stay_on() {
  _oneof_case_[26] = HAS_TO_STAY_ON_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_turn_degree() const {
  return has_turn_degree_case() != HAS_TURN_DEGREE_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_turn_degree() {
  _oneof_case_[27] = HAS_TURN_DEGREE_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_has_time_restrictions() const {
  return has_has_time_restrictions_case() != HAS_HAS_TIME_RESTRICTIONS_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_has_time_restrictions() {
  _oneof_case_[28] = HAS_HAS_TIME_RESTRICTIONS_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_bss_maneuver_type() const {
  return has_bss_maneuver_type_case() != HAS_BSS_MANEUVER_TYPE_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_bss_maneuver_type() {
  _oneof_case_[29] = HAS_BSS_MANEUVER_TYPE_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_verbal_succinct_transition_instruction() const {
  return has_verbal_succinct_transition_instruction_case() != HAS_VERBAL_SUCCINCT_TRANSITION_INSTRUCTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_verbal_succinct_transition_instruction() {
  _oneof_case_[30] = HAS_VERBAL_SUCCINCT_TRANSITION_INSTRUCTION_NOT_SET;
}
inline DirectionsLeg_Maneuver::HasTypeCase DirectionsLeg_Maneuver::has_type_case() const {
  return DirectionsLeg_Maneuver::HasTypeCase(_oneof_case_[0]);
}
inline DirectionsLeg_Maneuver::HasTextInstructionCase DirectionsLeg_Maneuver::has_text_instruction_case() const {
  return DirectionsLeg_Maneuver::HasTextInstructionCase(_oneof_case_[1]);
}
inline DirectionsLeg_Maneuver::HasLengthCase DirectionsLeg_Maneuver::has_length_case() const {
  return DirectionsLeg_Maneuver::HasLengthCase(_oneof_case_[2]);
}
inline DirectionsLeg_Maneuver::HasTimeCase DirectionsLeg_Maneuver::has_time_case() const {
  return DirectionsLeg_Maneuver::HasTimeCase(_oneof_case_[3]);
}
inline DirectionsLeg_Maneuver::HasBeginCardinalDirectionCase DirectionsLeg_Maneuver::has_begin_cardinal_direction_case() const {
  return DirectionsLeg_Maneuver::HasBeginCardinalDirectionCase(_oneof_case_[4]);
}
inline DirectionsLeg_Maneuver::HasBeginHeadingCase DirectionsLeg_Maneuver::has_begin_heading_case() const {
  return DirectionsLeg_Maneuver::HasBeginHeadingCase(_oneof_case_[5]);
}
inline DirectionsLeg_Maneuver::HasBeginShapeIndexCase DirectionsLeg_Maneuver::has_begin_shape_index_case() const {
  return DirectionsLeg_Maneuver::HasBeginShapeIndexCase(_oneof_case_[6]);
}
inline DirectionsLeg_Maneuver::HasEndShapeIndexCase DirectionsLeg_Maneuver::has_end_shape_index_case() const {
  return DirectionsLeg_Maneuver::HasEndShapeIndexCase(_oneof_case_[7]);
}
inline DirectionsLeg_Maneuver::HasPortionsTollCase DirectionsLeg_Maneuver::has_portions_toll_case() const {
  return DirectionsLeg_Maneuver::HasPortionsTollCase(_oneof_case_[8]);
}
inline DirectionsLeg_Maneuver::HasPortionsUnpavedCase DirectionsLeg_Maneuver::has_portions_unpaved_case() const {
  return DirectionsLeg_Maneuver::HasPortionsUnpavedCase(_oneof_case_[9]);
}
inline DirectionsLeg_Maneuver::HasVerbalTransitionAlertInstructionCase DirectionsLeg_Maneuver::has_verbal_transition_alert_instruction_case() const {
  return DirectionsLeg_Maneuver::HasVerbalTransitionAlertInstructionCase(_oneof_case_[10]);
}
inline DirectionsLeg_Maneuver::HasVerbalPreTransitionInstructionCase DirectionsLeg_Maneuver::has_verbal_pre_transition_instruction_case() const {
  return DirectionsLeg_Maneuver::HasVerbalPreTransitionInstructionCase(_oneof_case_[11]);
}
inline DirectionsLeg_Maneuver::HasVerbalPostTransitionInstructionCase DirectionsLeg_Maneuver::has_verbal_post_transition_instruction_case() const {
  return DirectionsLeg_Maneuver::HasVerbalPostTransitionInstructionCase(_oneof_case_[12]);
}
inline DirectionsLeg_Maneuver::HasRoundaboutExitCountCase DirectionsLeg_Maneuver::has_roundabout_exit_count_case() const {
  return DirectionsLeg_Maneuver::HasRoundaboutExitCountCase(_oneof_case_[13]);
}
inline DirectionsLeg_Maneuver::HasDepartInstructionCase DirectionsLeg_Maneuver::has_depart_instruction_case() const {
  return DirectionsLeg_Maneuver::HasDepartInstructionCase(_oneof_case_[14]);
}
inline DirectionsLeg_Maneuver::HasVerbalDepartInstructionCase DirectionsLeg_Maneuver::has_verbal_depart_instruction_case() const {
  return DirectionsLeg_Maneuver::HasVerbalDepartInstructionCase(_oneof_case_[15]);
}
inline DirectionsLeg_Maneuver::HasArriveInstructionCase DirectionsLeg_Maneuver::has_arrive_instruction_case() const {
  return DirectionsLeg_Maneuver::HasArriveInstructionCase(_oneof_case_[16]);
}
inline DirectionsLeg_Maneuver::HasVerbalArriveInstructionCase DirectionsLeg_Maneuver::has_verbal_arrive_instruction_case() const {
  return DirectionsLeg_Maneuver::HasVerbalArriveInstructionCase(_oneof_case_[17]);
}
inline DirectionsLeg_Maneuver::HasVerbalMultiCueCase DirectionsLeg_Maneuver::has_verbal_multi_cue_case() const {
  return DirectionsLeg_Maneuver::HasVerbalMultiCueCase(_oneof_case_[18]);
}
inline DirectionsLeg_Maneuver::HasTravelModeCase DirectionsLeg_Maneuver::has_travel_mode_case() const {
  return DirectionsLeg_Maneuver::HasTravelModeCase(_oneof_case_[19]);
}
inline DirectionsLeg_Maneuver::HasVehicleTypeCase DirectionsLeg_Maneuver::has_vehicle_type_case() const {
  return DirectionsLeg_Maneuver::HasVehicleTypeCase(_oneof_case_[20]);
}
inline DirectionsLeg_Maneuver::HasPedestrianTypeCase DirectionsLeg_Maneuver::has_pedestrian_type_case() const {
  return DirectionsLeg_Maneuver::HasPedestrianTypeCase(_oneof_case_[21]);
}
inline DirectionsLeg_Maneuver::HasBicycleTypeCase DirectionsLeg_Maneuver::has_bicycle_type_case() const {
  return DirectionsLeg_Maneuver::HasBicycleTypeCase(_oneof_case_[22]);
}
inline DirectionsLeg_Maneuver::HasTransitTypeCase DirectionsLeg_Maneuver::has_transit_type_case() const {
  return DirectionsLeg_Maneuver::HasTransitTypeCase(_oneof_case_[23]);
}
inline DirectionsLeg_Maneuver::HasBeginPathIndexCase DirectionsLeg_Maneuver::has_begin_path_index_case() const {
  return DirectionsLeg_Maneuver::HasBeginPathIndexCase(_oneof_case_[24]);
}
inline DirectionsLeg_Maneuver::HasEndPathIndexCase DirectionsLeg_Maneuver::has_end_path_index_case() const {
  return DirectionsLeg_Maneuver::HasEndPathIndexCase(_oneof_case_[25]);
}
inline DirectionsLeg_Maneuver::HasToStayOnCase DirectionsLeg_Maneuver::has_to_stay_on_case() const {
  return DirectionsLeg_Maneuver::HasToStayOnCase(_oneof_case_[26]);
}
inline DirectionsLeg_Maneuver::HasTurnDegreeCase DirectionsLeg_Maneuver::has_turn_degree_case() const {
  return DirectionsLeg_Maneuver::HasTurnDegreeCase(_oneof_case_[27]);
}
inline DirectionsLeg_Maneuver::HasHasTimeRestrictionsCase DirectionsLeg_Maneuver::has_has_time_restrictions_case() const {
  return DirectionsLeg_Maneuver::HasHasTimeRestrictionsCase(_oneof_case_[28]);
}
inline DirectionsLeg_Maneuver::HasBssManeuverTypeCase DirectionsLeg_Maneuver::has_bss_maneuver_type_case() const {
  return DirectionsLeg_Maneuver::HasBssManeuverTypeCase(_oneof_case_[29]);
}
inline DirectionsLeg_Maneuver::HasVerbalSuccinctTransitionInstructionCase DirectionsLeg_Maneuver::has_verbal_succinct_transition_instruction_case() const {
  return DirectionsLeg_Maneuver::HasVerbalSuccinctTransitionInstructionCase(_oneof_case_[30]);
}
// -------------------------------------------------------------------

// DirectionsLeg

// optional uint64 trip_id = 1;
inline bool DirectionsLeg::has_trip_id() const {
  return has_trip_id_case() == kTripId;
}
inline void DirectionsLeg::set_has_trip_id() {
  _oneof_case_[0] = kTripId;
}
inline void DirectionsLeg::clear_trip_id() {
  if (has_trip_id()) {
    has_trip_id_.trip_id_ = GOOGLE_ULONGLONG(0);
    clear_has_has_trip_id();
  }
}
inline ::google::protobuf::uint64 DirectionsLeg::trip_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.trip_id)
  if (has_trip_id()) {
    return has_trip_id_.trip_id_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void DirectionsLeg::set_trip_id(::google::protobuf::uint64 value) {
  if (!has_trip_id()) {
    clear_has_trip_id();
    set_has_trip_id();
  }
  has_trip_id_.trip_id_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.trip_id)
}

// optional uint32 leg_id = 2;
inline bool DirectionsLeg::has_leg_id() const {
  return has_leg_id_case() == kLegId;
}
inline void DirectionsLeg::set_has_leg_id() {
  _oneof_case_[1] = kLegId;
}
inline void DirectionsLeg::clear_leg_id() {
  if (has_leg_id()) {
    has_leg_id_.leg_id_ = 0u;
    clear_has_has_leg_id();
  }
}
inline ::google::protobuf::uint32 DirectionsLeg::leg_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.leg_id)
  if (has_leg_id()) {
    return has_leg_id_.leg_id_;
  }
  return 0u;
}
inline void DirectionsLeg::set_leg_id(::google::protobuf::uint32 value) {
  if (!has_leg_id()) {
    clear_has_leg_id();
    set_has_leg_id();
  }
  has_leg_id_.leg_id_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.leg_id)
}

// optional uint32 leg_count = 3;
inline bool DirectionsLeg::has_leg_count() const {
  return has_leg_count_case() == kLegCount;
}
inline void DirectionsLeg::set_has_leg_count() {
  _oneof_case_[2] = kLegCount;
}
inline void DirectionsLeg::clear_leg_count() {
  if (has_leg_count()) {
    has_leg_count_.leg_count_ = 0u;
    clear_has_has_leg_count();
  }
}
inline ::google::protobuf::uint32 DirectionsLeg::leg_count() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.leg_count)
  if (has_leg_count()) {
    return has_leg_count_.leg_count_;
  }
  return 0u;
}
inline void DirectionsLeg::set_leg_count(::google::protobuf::uint32 value) {
  if (!has_leg_count()) {
    clear_has_leg_count();
    set_has_leg_count();
  }
  has_leg_count_.leg_count_ = value;
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.leg_count)
}

// repeated .valhalla.Location location = 4;
inline int DirectionsLeg::location_size() const {
  return location_.size();
}
inline void DirectionsLeg::clear_location() {
  location_.Clear();
}
inline const ::valhalla::Location& DirectionsLeg::location(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.location)
  return location_.Get(index);
}
inline ::valhalla::Location* DirectionsLeg::mutable_location(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.location)
  return location_.Mutable(index);
}
inline ::valhalla::Location* DirectionsLeg::add_location() {
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.location)
  return location_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
DirectionsLeg::mutable_location() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.location)
  return &location_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
DirectionsLeg::location() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.location)
  return location_;
}

// optional .valhalla.DirectionsLeg.Summary summary = 5;
inline bool DirectionsLeg::has_summary() const {
  return !_is_default_instance_ && summary_ != NULL;
}
inline void DirectionsLeg::clear_summary() {
  if (GetArenaNoVirtual() == NULL && summary_ != NULL) delete summary_;
  summary_ = NULL;
}
inline const ::valhalla::DirectionsLeg_Summary& DirectionsLeg::summary() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.summary)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return summary_ != NULL ? *summary_ : *default_instance().summary_;
#else
  return summary_ != NULL ? *summary_ : *default_instance_->summary_;
#endif
}
inline ::valhalla::DirectionsLeg_Summary* DirectionsLeg::mutable_summary() {
  
  if (summary_ == NULL) {
    summary_ = new ::valhalla::DirectionsLeg_Summary;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.summary)
  return summary_;
}
inline ::valhalla::DirectionsLeg_Summary* DirectionsLeg::release_summary() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.summary)
  
  ::valhalla::DirectionsLeg_Summary* temp = summary_;
  summary_ = NULL;
  return temp;
}
inline void DirectionsLeg::set_allocated_summary(::valhalla::DirectionsLeg_Summary* summary) {
  delete summary_;
  summary_ = summary;
  if (summary) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.summary)
}

// repeated .valhalla.DirectionsLeg.Maneuver maneuver = 6;
inline int DirectionsLeg::maneuver_size() const {
  return maneuver_.size();
}
inline void DirectionsLeg::clear_maneuver() {
  maneuver_.Clear();
}
inline const ::valhalla::DirectionsLeg_Maneuver& DirectionsLeg::maneuver(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.maneuver)
  return maneuver_.Get(index);
}
inline ::valhalla::DirectionsLeg_Maneuver* DirectionsLeg::mutable_maneuver(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.maneuver)
  return maneuver_.Mutable(index);
}
inline ::valhalla::DirectionsLeg_Maneuver* DirectionsLeg::add_maneuver() {
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.maneuver)
  return maneuver_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >*
DirectionsLeg::mutable_maneuver() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.maneuver)
  return &maneuver_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >&
DirectionsLeg::maneuver() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.maneuver)
  return maneuver_;
}

// optional string shape = 7;
inline bool DirectionsLeg::has_shape() const {
  return has_shape_case() == kShape;
}
inline void DirectionsLeg::set_has_shape() {
  _oneof_case_[3] = kShape;
}
inline void DirectionsLeg::clear_shape() {
  if (has_shape()) {
    has_shape_.shape_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_shape();
  }
}
inline const ::std::string& DirectionsLeg::shape() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.shape)
  if (has_shape()) {
    return has_shape_.shape_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg::set_shape(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.shape)
  if (!has_shape()) {
    clear_has_shape();
    set_has_shape();
    has_shape_.shape_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_shape_.shape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.shape)
}
inline void DirectionsLeg::set_shape(const char* value) {
  if (!has_shape()) {
    clear_has_shape();
    set_has_shape();
    has_shape_.shape_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_shape_.shape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.DirectionsLeg.shape)
}
inline void DirectionsLeg::set_shape(const char* value, size_t size) {
  if (!has_shape()) {
    clear_has_shape();
    set_has_shape();
    has_shape_.shape_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_shape_.shape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.DirectionsLeg.shape)
}
inline ::std::string* DirectionsLeg::mutable_shape() {
  if (!has_shape()) {
    clear_has_shape();
    set_has_shape();
    has_shape_.shape_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.shape)
  return has_shape_.shape_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLeg::release_shape() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.shape)
  if (has_shape()) {
    clear_has_has_shape();
    return has_shape_.shape_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void DirectionsLeg::set_allocated_shape(::std::string* shape) {
  if (!has_shape()) {
    has_shape_.shape_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_shape();
  if (shape != NULL) {
    set_has_shape();
    has_shape_.shape_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        shape);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.shape)
}

inline bool DirectionsLeg::has_has_trip_id() const {
  return has_trip_id_case() != HAS_TRIP_ID_NOT_SET;
}
inline void DirectionsLeg::clear_has_has_trip_id() {
  _oneof_case_[0] = HAS_TRIP_ID_NOT_SET;
}
inline bool DirectionsLeg::has_has_leg_id() const {
  return has_leg_id_case() != HAS_LEG_ID_NOT_SET;
}
inline void DirectionsLeg::clear_has_has_leg_id() {
  _oneof_case_[1] = HAS_LEG_ID_NOT_SET;
}
inline bool DirectionsLeg::has_has_leg_count() const {
  return has_leg_count_case() != HAS_LEG_COUNT_NOT_SET;
}
inline void DirectionsLeg::clear_has_has_leg_count() {
  _oneof_case_[2] = HAS_LEG_COUNT_NOT_SET;
}
inline bool DirectionsLeg::has_has_shape() const {
  return has_shape_case() != HAS_SHAPE_NOT_SET;
}
inline void DirectionsLeg::clear_has_has_shape() {
  _oneof_case_[3] = HAS_SHAPE_NOT_SET;
}
inline DirectionsLeg::HasTripIdCase DirectionsLeg::has_trip_id_case() const {
  return DirectionsLeg::HasTripIdCase(_oneof_case_[0]);
}
inline DirectionsLeg::HasLegIdCase DirectionsLeg::has_leg_id_case() const {
  return DirectionsLeg::HasLegIdCase(_oneof_case_[1]);
}
inline DirectionsLeg::HasLegCountCase DirectionsLeg::has_leg_count_case() const {
  return DirectionsLeg::HasLegCountCase(_oneof_case_[2]);
}
inline DirectionsLeg::HasShapeCase DirectionsLeg::has_shape_case() const {
  return DirectionsLeg::HasShapeCase(_oneof_case_[3]);
}
// -------------------------------------------------------------------

// DirectionsRoute

// repeated .valhalla.DirectionsLeg legs = 1;
inline int DirectionsRoute::legs_size() const {
  return legs_.size();
}
inline void DirectionsRoute::clear_legs() {
  legs_.Clear();
}
inline const ::valhalla::DirectionsLeg& DirectionsRoute::legs(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsRoute.legs)
  return legs_.Get(index);
}
inline ::valhalla::DirectionsLeg* DirectionsRoute::mutable_legs(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsRoute.legs)
  return legs_.Mutable(index);
}
inline ::valhalla::DirectionsLeg* DirectionsRoute::add_legs() {
  // @@protoc_insertion_point(field_add:valhalla.DirectionsRoute.legs)
  return legs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg >*
DirectionsRoute::mutable_legs() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsRoute.legs)
  return &legs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg >&
DirectionsRoute::legs() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsRoute.legs)
  return legs_;
}

// -------------------------------------------------------------------

// Directions

// repeated .valhalla.DirectionsRoute routes = 1;
inline int Directions::routes_size() const {
  return routes_.size();
}
inline void Directions::clear_routes() {
  routes_.Clear();
}
inline const ::valhalla::DirectionsRoute& Directions::routes(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Directions.routes)
  return routes_.Get(index);
}
inline ::valhalla::DirectionsRoute* Directions::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Directions.routes)
  return routes_.Mutable(index);
}
inline ::valhalla::DirectionsRoute* Directions::add_routes() {
  // @@protoc_insertion_point(field_add:valhalla.Directions.routes)
  return routes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsRoute >*
Directions::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Directions.routes)
  return &routes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsRoute >&
Directions::routes() const {
  // @@protoc_insertion_point(field_list:valhalla.Directions.routes)
  return routes_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::valhalla::DirectionsLeg_GuidanceView_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsLeg_Maneuver_CardinalDirection> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsLeg_Maneuver_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsLeg_Maneuver_BssManeuverType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_directions_2eproto__INCLUDED
