// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: info.proto

#ifndef PROTOBUF_info_2eproto__INCLUDED
#define PROTOBUF_info_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace valhalla {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_info_2eproto();
void protobuf_AssignDesc_info_2eproto();
void protobuf_ShutdownFile_info_2eproto();

class CodedDescription;
class Info;
class Statistic;

enum StatisticType {
  count = 0,
  gauge = 1,
  timing = 2,
  set = 3,
  StatisticType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  StatisticType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool StatisticType_IsValid(int value);
const StatisticType StatisticType_MIN = count;
const StatisticType StatisticType_MAX = set;
const int StatisticType_ARRAYSIZE = StatisticType_MAX + 1;

// ===================================================================

class Statistic : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Statistic) */ {
 public:
  Statistic();
  virtual ~Statistic();

  Statistic(const Statistic& from);

  inline Statistic& operator=(const Statistic& from) {
    CopyFrom(from);
    return *this;
  }

  static const Statistic& default_instance();

  enum HasKeyCase {
    kKey = 1,
    HAS_KEY_NOT_SET = 0,
  };

  enum HasValueCase {
    kValue = 2,
    HAS_VALUE_NOT_SET = 0,
  };

  enum HasFrequencyCase {
    kFrequency = 3,
    HAS_FREQUENCY_NOT_SET = 0,
  };

  enum HasTypeCase {
    kType = 4,
    HAS_TYPE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Statistic* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Statistic* other);

  // implements Message ----------------------------------------------

  inline Statistic* New() const { return New(NULL); }

  Statistic* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Statistic& from);
  void MergeFrom(const Statistic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Statistic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  private:
  bool has_key() const;
  public:
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional double value = 2;
  private:
  bool has_value() const;
  public:
  void clear_value();
  static const int kValueFieldNumber = 2;
  double value() const;
  void set_value(double value);

  // optional float frequency = 3;
  private:
  bool has_frequency() const;
  public:
  void clear_frequency();
  static const int kFrequencyFieldNumber = 3;
  float frequency() const;
  void set_frequency(float value);

  // optional .valhalla.StatisticType type = 4;
  private:
  bool has_type() const;
  public:
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::valhalla::StatisticType type() const;
  void set_type(::valhalla::StatisticType value);

  HasKeyCase has_key_case() const;
  HasValueCase has_value_case() const;
  HasFrequencyCase has_frequency_case() const;
  HasTypeCase has_type_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.Statistic)
 private:
  inline void set_has_key();
  inline void set_has_value();
  inline void set_has_frequency();
  inline void set_has_type();

  inline bool has_has_key() const;
  void clear_has_key();
  inline void clear_has_has_key();

  inline bool has_has_value() const;
  void clear_has_value();
  inline void clear_has_has_value();

  inline bool has_has_frequency() const;
  void clear_has_frequency();
  inline void clear_has_has_frequency();

  inline bool has_has_type() const;
  void clear_has_type();
  inline void clear_has_has_type();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  union HasKeyUnion {
    HasKeyUnion() {}
    ::google::protobuf::internal::ArenaStringPtr key_;
  } has_key_;
  union HasValueUnion {
    HasValueUnion() {}
    double value_;
  } has_value_;
  union HasFrequencyUnion {
    HasFrequencyUnion() {}
    float frequency_;
  } has_frequency_;
  union HasTypeUnion {
    HasTypeUnion() {}
    int type_;
  } has_type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[4];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_info_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_info_2eproto();
  #endif
  friend void protobuf_AssignDesc_info_2eproto();
  friend void protobuf_ShutdownFile_info_2eproto();

  void InitAsDefaultInstance();
  static Statistic* default_instance_;
};
// -------------------------------------------------------------------

class CodedDescription : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.CodedDescription) */ {
 public:
  CodedDescription();
  virtual ~CodedDescription();

  CodedDescription(const CodedDescription& from);

  inline CodedDescription& operator=(const CodedDescription& from) {
    CopyFrom(from);
    return *this;
  }

  static const CodedDescription& default_instance();

  enum HasDescriptionCase {
    kDescription = 1,
    HAS_DESCRIPTION_NOT_SET = 0,
  };

  enum HasCodeCase {
    kCode = 2,
    HAS_CODE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CodedDescription* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CodedDescription* other);

  // implements Message ----------------------------------------------

  inline CodedDescription* New() const { return New(NULL); }

  CodedDescription* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CodedDescription& from);
  void MergeFrom(const CodedDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CodedDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string description = 1;
  private:
  bool has_description() const;
  public:
  void clear_description();
  static const int kDescriptionFieldNumber = 1;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional uint64 code = 2;
  private:
  bool has_code() const;
  public:
  void clear_code();
  static const int kCodeFieldNumber = 2;
  ::google::protobuf::uint64 code() const;
  void set_code(::google::protobuf::uint64 value);

  HasDescriptionCase has_description_case() const;
  HasCodeCase has_code_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.CodedDescription)
 private:
  inline void set_has_description();
  inline void set_has_code();

  inline bool has_has_description() const;
  void clear_has_description();
  inline void clear_has_has_description();

  inline bool has_has_code() const;
  void clear_has_code();
  inline void clear_has_has_code();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  union HasDescriptionUnion {
    HasDescriptionUnion() {}
    ::google::protobuf::internal::ArenaStringPtr description_;
  } has_description_;
  union HasCodeUnion {
    HasCodeUnion() {}
    ::google::protobuf::uint64 code_;
  } has_code_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_info_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_info_2eproto();
  #endif
  friend void protobuf_AssignDesc_info_2eproto();
  friend void protobuf_ShutdownFile_info_2eproto();

  void InitAsDefaultInstance();
  static CodedDescription* default_instance_;
};
// -------------------------------------------------------------------

class Info : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Info) */ {
 public:
  Info();
  virtual ~Info();

  Info(const Info& from);

  inline Info& operator=(const Info& from) {
    CopyFrom(from);
    return *this;
  }

  static const Info& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Info* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Info* other);

  // implements Message ----------------------------------------------

  inline Info* New() const { return New(NULL); }

  Info* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Info& from);
  void MergeFrom(const Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .valhalla.Statistic statistics = 1;
  int statistics_size() const;
  void clear_statistics();
  static const int kStatisticsFieldNumber = 1;
  const ::valhalla::Statistic& statistics(int index) const;
  ::valhalla::Statistic* mutable_statistics(int index);
  ::valhalla::Statistic* add_statistics();
  ::google::protobuf::RepeatedPtrField< ::valhalla::Statistic >*
      mutable_statistics();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Statistic >&
      statistics() const;

  // repeated .valhalla.CodedDescription errors = 2;
  int errors_size() const;
  void clear_errors();
  static const int kErrorsFieldNumber = 2;
  const ::valhalla::CodedDescription& errors(int index) const;
  ::valhalla::CodedDescription* mutable_errors(int index);
  ::valhalla::CodedDescription* add_errors();
  ::google::protobuf::RepeatedPtrField< ::valhalla::CodedDescription >*
      mutable_errors();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::CodedDescription >&
      errors() const;

  // repeated .valhalla.CodedDescription warnings = 3;
  int warnings_size() const;
  void clear_warnings();
  static const int kWarningsFieldNumber = 3;
  const ::valhalla::CodedDescription& warnings(int index) const;
  ::valhalla::CodedDescription* mutable_warnings(int index);
  ::valhalla::CodedDescription* add_warnings();
  ::google::protobuf::RepeatedPtrField< ::valhalla::CodedDescription >*
      mutable_warnings();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::CodedDescription >&
      warnings() const;

  // @@protoc_insertion_point(class_scope:valhalla.Info)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Statistic > statistics_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::CodedDescription > errors_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::CodedDescription > warnings_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_info_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_info_2eproto();
  #endif
  friend void protobuf_AssignDesc_info_2eproto();
  friend void protobuf_ShutdownFile_info_2eproto();

  void InitAsDefaultInstance();
  static Info* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Statistic

// optional string key = 1;
inline bool Statistic::has_key() const {
  return has_key_case() == kKey;
}
inline void Statistic::set_has_key() {
  _oneof_case_[0] = kKey;
}
inline void Statistic::clear_key() {
  if (has_key()) {
    has_key_.key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_key();
  }
}
inline const ::std::string& Statistic::key() const {
  // @@protoc_insertion_point(field_get:valhalla.Statistic.key)
  if (has_key()) {
    return has_key_.key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Statistic::set_key(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.Statistic.key)
  if (!has_key()) {
    clear_has_key();
    set_has_key();
    has_key_.key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_key_.key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.Statistic.key)
}
inline void Statistic::set_key(const char* value) {
  if (!has_key()) {
    clear_has_key();
    set_has_key();
    has_key_.key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_key_.key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.Statistic.key)
}
inline void Statistic::set_key(const char* value, size_t size) {
  if (!has_key()) {
    clear_has_key();
    set_has_key();
    has_key_.key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_key_.key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.Statistic.key)
}
inline ::std::string* Statistic::mutable_key() {
  if (!has_key()) {
    clear_has_key();
    set_has_key();
    has_key_.key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Statistic.key)
  return has_key_.key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Statistic::release_key() {
  // @@protoc_insertion_point(field_release:valhalla.Statistic.key)
  if (has_key()) {
    clear_has_has_key();
    return has_key_.key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Statistic::set_allocated_key(::std::string* key) {
  if (!has_key()) {
    has_key_.key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_key();
  if (key != NULL) {
    set_has_key();
    has_key_.key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        key);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Statistic.key)
}

// optional double value = 2;
inline bool Statistic::has_value() const {
  return has_value_case() == kValue;
}
inline void Statistic::set_has_value() {
  _oneof_case_[1] = kValue;
}
inline void Statistic::clear_value() {
  if (has_value()) {
    has_value_.value_ = 0;
    clear_has_has_value();
  }
}
inline double Statistic::value() const {
  // @@protoc_insertion_point(field_get:valhalla.Statistic.value)
  if (has_value()) {
    return has_value_.value_;
  }
  return 0;
}
inline void Statistic::set_value(double value) {
  if (!has_value()) {
    clear_has_value();
    set_has_value();
  }
  has_value_.value_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Statistic.value)
}

// optional float frequency = 3;
inline bool Statistic::has_frequency() const {
  return has_frequency_case() == kFrequency;
}
inline void Statistic::set_has_frequency() {
  _oneof_case_[2] = kFrequency;
}
inline void Statistic::clear_frequency() {
  if (has_frequency()) {
    has_frequency_.frequency_ = 0;
    clear_has_has_frequency();
  }
}
inline float Statistic::frequency() const {
  // @@protoc_insertion_point(field_get:valhalla.Statistic.frequency)
  if (has_frequency()) {
    return has_frequency_.frequency_;
  }
  return 0;
}
inline void Statistic::set_frequency(float value) {
  if (!has_frequency()) {
    clear_has_frequency();
    set_has_frequency();
  }
  has_frequency_.frequency_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Statistic.frequency)
}

// optional .valhalla.StatisticType type = 4;
inline bool Statistic::has_type() const {
  return has_type_case() == kType;
}
inline void Statistic::set_has_type() {
  _oneof_case_[3] = kType;
}
inline void Statistic::clear_type() {
  if (has_type()) {
    has_type_.type_ = 0;
    clear_has_has_type();
  }
}
inline ::valhalla::StatisticType Statistic::type() const {
  // @@protoc_insertion_point(field_get:valhalla.Statistic.type)
  if (has_type()) {
    return static_cast< ::valhalla::StatisticType >(has_type_.type_);
  }
  return static_cast< ::valhalla::StatisticType >(0);
}
inline void Statistic::set_type(::valhalla::StatisticType value) {
  if (!has_type()) {
    clear_has_type();
    set_has_type();
  }
  has_type_.type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Statistic.type)
}

inline bool Statistic::has_has_key() const {
  return has_key_case() != HAS_KEY_NOT_SET;
}
inline void Statistic::clear_has_has_key() {
  _oneof_case_[0] = HAS_KEY_NOT_SET;
}
inline bool Statistic::has_has_value() const {
  return has_value_case() != HAS_VALUE_NOT_SET;
}
inline void Statistic::clear_has_has_value() {
  _oneof_case_[1] = HAS_VALUE_NOT_SET;
}
inline bool Statistic::has_has_frequency() const {
  return has_frequency_case() != HAS_FREQUENCY_NOT_SET;
}
inline void Statistic::clear_has_has_frequency() {
  _oneof_case_[2] = HAS_FREQUENCY_NOT_SET;
}
inline bool Statistic::has_has_type() const {
  return has_type_case() != HAS_TYPE_NOT_SET;
}
inline void Statistic::clear_has_has_type() {
  _oneof_case_[3] = HAS_TYPE_NOT_SET;
}
inline Statistic::HasKeyCase Statistic::has_key_case() const {
  return Statistic::HasKeyCase(_oneof_case_[0]);
}
inline Statistic::HasValueCase Statistic::has_value_case() const {
  return Statistic::HasValueCase(_oneof_case_[1]);
}
inline Statistic::HasFrequencyCase Statistic::has_frequency_case() const {
  return Statistic::HasFrequencyCase(_oneof_case_[2]);
}
inline Statistic::HasTypeCase Statistic::has_type_case() const {
  return Statistic::HasTypeCase(_oneof_case_[3]);
}
// -------------------------------------------------------------------

// CodedDescription

// optional string description = 1;
inline bool CodedDescription::has_description() const {
  return has_description_case() == kDescription;
}
inline void CodedDescription::set_has_description() {
  _oneof_case_[0] = kDescription;
}
inline void CodedDescription::clear_description() {
  if (has_description()) {
    has_description_.description_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_description();
  }
}
inline const ::std::string& CodedDescription::description() const {
  // @@protoc_insertion_point(field_get:valhalla.CodedDescription.description)
  if (has_description()) {
    return has_description_.description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void CodedDescription::set_description(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.CodedDescription.description)
  if (!has_description()) {
    clear_has_description();
    set_has_description();
    has_description_.description_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_description_.description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.CodedDescription.description)
}
inline void CodedDescription::set_description(const char* value) {
  if (!has_description()) {
    clear_has_description();
    set_has_description();
    has_description_.description_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_description_.description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.CodedDescription.description)
}
inline void CodedDescription::set_description(const char* value, size_t size) {
  if (!has_description()) {
    clear_has_description();
    set_has_description();
    has_description_.description_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_description_.description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.CodedDescription.description)
}
inline ::std::string* CodedDescription::mutable_description() {
  if (!has_description()) {
    clear_has_description();
    set_has_description();
    has_description_.description_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.CodedDescription.description)
  return has_description_.description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CodedDescription::release_description() {
  // @@protoc_insertion_point(field_release:valhalla.CodedDescription.description)
  if (has_description()) {
    clear_has_has_description();
    return has_description_.description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void CodedDescription::set_allocated_description(::std::string* description) {
  if (!has_description()) {
    has_description_.description_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_description();
  if (description != NULL) {
    set_has_description();
    has_description_.description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        description);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.CodedDescription.description)
}

// optional uint64 code = 2;
inline bool CodedDescription::has_code() const {
  return has_code_case() == kCode;
}
inline void CodedDescription::set_has_code() {
  _oneof_case_[1] = kCode;
}
inline void CodedDescription::clear_code() {
  if (has_code()) {
    has_code_.code_ = GOOGLE_ULONGLONG(0);
    clear_has_has_code();
  }
}
inline ::google::protobuf::uint64 CodedDescription::code() const {
  // @@protoc_insertion_point(field_get:valhalla.CodedDescription.code)
  if (has_code()) {
    return has_code_.code_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void CodedDescription::set_code(::google::protobuf::uint64 value) {
  if (!has_code()) {
    clear_has_code();
    set_has_code();
  }
  has_code_.code_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CodedDescription.code)
}

inline bool CodedDescription::has_has_description() const {
  return has_description_case() != HAS_DESCRIPTION_NOT_SET;
}
inline void CodedDescription::clear_has_has_description() {
  _oneof_case_[0] = HAS_DESCRIPTION_NOT_SET;
}
inline bool CodedDescription::has_has_code() const {
  return has_code_case() != HAS_CODE_NOT_SET;
}
inline void CodedDescription::clear_has_has_code() {
  _oneof_case_[1] = HAS_CODE_NOT_SET;
}
inline CodedDescription::HasDescriptionCase CodedDescription::has_description_case() const {
  return CodedDescription::HasDescriptionCase(_oneof_case_[0]);
}
inline CodedDescription::HasCodeCase CodedDescription::has_code_case() const {
  return CodedDescription::HasCodeCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// Info

// repeated .valhalla.Statistic statistics = 1;
inline int Info::statistics_size() const {
  return statistics_.size();
}
inline void Info::clear_statistics() {
  statistics_.Clear();
}
inline const ::valhalla::Statistic& Info::statistics(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Info.statistics)
  return statistics_.Get(index);
}
inline ::valhalla::Statistic* Info::mutable_statistics(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Info.statistics)
  return statistics_.Mutable(index);
}
inline ::valhalla::Statistic* Info::add_statistics() {
  // @@protoc_insertion_point(field_add:valhalla.Info.statistics)
  return statistics_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Statistic >*
Info::mutable_statistics() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Info.statistics)
  return &statistics_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Statistic >&
Info::statistics() const {
  // @@protoc_insertion_point(field_list:valhalla.Info.statistics)
  return statistics_;
}

// repeated .valhalla.CodedDescription errors = 2;
inline int Info::errors_size() const {
  return errors_.size();
}
inline void Info::clear_errors() {
  errors_.Clear();
}
inline const ::valhalla::CodedDescription& Info::errors(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Info.errors)
  return errors_.Get(index);
}
inline ::valhalla::CodedDescription* Info::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Info.errors)
  return errors_.Mutable(index);
}
inline ::valhalla::CodedDescription* Info::add_errors() {
  // @@protoc_insertion_point(field_add:valhalla.Info.errors)
  return errors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::CodedDescription >*
Info::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Info.errors)
  return &errors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::CodedDescription >&
Info::errors() const {
  // @@protoc_insertion_point(field_list:valhalla.Info.errors)
  return errors_;
}

// repeated .valhalla.CodedDescription warnings = 3;
inline int Info::warnings_size() const {
  return warnings_.size();
}
inline void Info::clear_warnings() {
  warnings_.Clear();
}
inline const ::valhalla::CodedDescription& Info::warnings(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Info.warnings)
  return warnings_.Get(index);
}
inline ::valhalla::CodedDescription* Info::mutable_warnings(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Info.warnings)
  return warnings_.Mutable(index);
}
inline ::valhalla::CodedDescription* Info::add_warnings() {
  // @@protoc_insertion_point(field_add:valhalla.Info.warnings)
  return warnings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::CodedDescription >*
Info::mutable_warnings() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Info.warnings)
  return &warnings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::CodedDescription >&
Info::warnings() const {
  // @@protoc_insertion_point(field_list:valhalla.Info.warnings)
  return warnings_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::valhalla::StatisticType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_info_2eproto__INCLUDED
