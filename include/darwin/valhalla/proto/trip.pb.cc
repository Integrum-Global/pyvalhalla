// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trip.proto

#include "trip.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/io/zero_copy_stream_impl_lite.h"
#include "google/protobuf/generated_message_tctable_impl.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace valhalla {
        template <typename>
PROTOBUF_CONSTEXPR TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.from_lanes_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.to_lanes_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.from_way_id_)*/ ::uint64_t{0u},
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct TripLeg_LaneConnectivityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_LaneConnectivityDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_LaneConnectivityDefaultTypeInternal() {}
  union {
    TripLeg_LaneConnectivity _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_LaneConnectivityDefaultTypeInternal _TripLeg_LaneConnectivity_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR TripLeg_TrafficSegment::TripLeg_TrafficSegment(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.segment_id_)*/ ::uint64_t{0u},
      /*decltype(_impl_.begin_percent_)*/ 0,
      /*decltype(_impl_.end_percent_)*/ 0,
      /*decltype(_impl_.starts_segment_)*/ false,
      /*decltype(_impl_.ends_segment_)*/ false,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct TripLeg_TrafficSegmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_TrafficSegmentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_TrafficSegmentDefaultTypeInternal() {}
  union {
    TripLeg_TrafficSegment _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_TrafficSegmentDefaultTypeInternal _TripLeg_TrafficSegment_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR TripLeg_Restriction::TripLeg_Restriction(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.type_)*/ 0u,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct TripLeg_RestrictionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_RestrictionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_RestrictionDefaultTypeInternal() {}
  union {
    TripLeg_Restriction _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_RestrictionDefaultTypeInternal _TripLeg_Restriction_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR TripLeg_Edge::TripLeg_Edge(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.name_)*/ {},
      /*decltype(_impl_.lane_connectivity_)*/ {},
      /*decltype(_impl_.traffic_segment_)*/ {},
      /*decltype(_impl_.turn_lanes_)*/ {},
      /*decltype(_impl_.tagged_value_)*/ {},
      /*decltype(_impl_.sign_)*/ nullptr,
      /*decltype(_impl_.transit_route_info_)*/ nullptr,
      /*decltype(_impl_.restriction_)*/ nullptr,
      /*decltype(_impl_.length_km_)*/ 0,
      /*decltype(_impl_.speed_)*/ 0,
      /*decltype(_impl_.road_class_)*/ 0,
      /*decltype(_impl_.begin_heading_)*/ 0u,
      /*decltype(_impl_.end_heading_)*/ 0u,
      /*decltype(_impl_.begin_shape_index_)*/ 0u,
      /*decltype(_impl_.end_shape_index_)*/ 0u,
      /*decltype(_impl_.traversability_)*/ 0,
      /*decltype(_impl_.use_)*/ 0,
      /*decltype(_impl_.toll_)*/ false,
      /*decltype(_impl_.unpaved_)*/ false,
      /*decltype(_impl_.tunnel_)*/ false,
      /*decltype(_impl_.bridge_)*/ false,
      /*decltype(_impl_.surface_)*/ 0,
      /*decltype(_impl_.travel_mode_)*/ 0,
      /*decltype(_impl_.roundabout_)*/ false,
      /*decltype(_impl_.internal_intersection_)*/ false,
      /*decltype(_impl_.drive_on_left_)*/ false,
      /*decltype(_impl_.bicycle_network_)*/ false,
      /*decltype(_impl_.vehicle_type_)*/ 0,
      /*decltype(_impl_.pedestrian_type_)*/ 0,
      /*decltype(_impl_.bicycle_type_)*/ 0,
      /*decltype(_impl_.id_)*/ ::uint64_t{0u},
      /*decltype(_impl_.transit_type_)*/ 0,
      /*decltype(_impl_.weighted_grade_)*/ 0,
      /*decltype(_impl_.way_id_)*/ ::uint64_t{0u},
      /*decltype(_impl_.max_upward_grade_)*/ 0,
      /*decltype(_impl_.max_downward_grade_)*/ 0,
      /*decltype(_impl_.lane_count_)*/ 0u,
      /*decltype(_impl_.cycle_lane_)*/ 0,
      /*decltype(_impl_.sidewalk_)*/ 0,
      /*decltype(_impl_.density_)*/ 0u,
      /*decltype(_impl_.speed_limit_)*/ 0u,
      /*decltype(_impl_.truck_speed_)*/ 0,
      /*decltype(_impl_.mean_elevation_)*/ 0,
      /*decltype(_impl_.truck_route_)*/ false,
      /*decltype(_impl_.has_time_restrictions_)*/ false,
      /*decltype(_impl_.destination_only_)*/ false,
      /*decltype(_impl_.is_urban_)*/ false,
      /*decltype(_impl_.default_speed_)*/ 0,
      /*decltype(_impl_.source_along_edge_)*/ 0,
      /*decltype(_impl_.target_along_edge_)*/ 0,
      /*decltype(_impl_.sac_scale_)*/ 0,
      /*decltype(_impl_.shoulder_)*/ false,
      /*decltype(_impl_.indoor_)*/ false,
    } {}
struct TripLeg_EdgeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_EdgeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_EdgeDefaultTypeInternal() {}
  union {
    TripLeg_Edge _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_EdgeDefaultTypeInternal _TripLeg_Edge_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.sign_)*/ nullptr,
      /*decltype(_impl_.begin_heading_)*/ 0u,
      /*decltype(_impl_.prev_name_consistency_)*/ false,
      /*decltype(_impl_.curr_name_consistency_)*/ false,
      /*decltype(_impl_.driveability_)*/ 0,
      /*decltype(_impl_.cyclability_)*/ 0,
      /*decltype(_impl_.walkability_)*/ 0,
      /*decltype(_impl_.use_)*/ 0,
      /*decltype(_impl_.road_class_)*/ 0,
      /*decltype(_impl_.lane_count_)*/ 0u,
    } {}
struct TripLeg_IntersectingEdgeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_IntersectingEdgeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_IntersectingEdgeDefaultTypeInternal() {}
  union {
    TripLeg_IntersectingEdge _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_IntersectingEdgeDefaultTypeInternal _TripLeg_IntersectingEdge_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR TripLeg_Cost::TripLeg_Cost(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.seconds_)*/ 0,
      /*decltype(_impl_.cost_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct TripLeg_CostDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_CostDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_CostDefaultTypeInternal() {}
  union {
    TripLeg_Cost _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_CostDefaultTypeInternal _TripLeg_Cost_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR TripLeg_PathCost::TripLeg_PathCost(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.elapsed_cost_)*/ nullptr,
      /*decltype(_impl_.transition_cost_)*/ nullptr,
    } {}
struct TripLeg_PathCostDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_PathCostDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_PathCostDefaultTypeInternal() {}
  union {
    TripLeg_PathCost _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_PathCostDefaultTypeInternal _TripLeg_PathCost_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR TripLeg_Node::TripLeg_Node(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.intersecting_edge_)*/ {},
      /*decltype(_impl_.recosts_)*/ {},
      /*decltype(_impl_.time_zone_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.edge_)*/ nullptr,
      /*decltype(_impl_.transit_platform_info_)*/ nullptr,
      /*decltype(_impl_.transit_station_info_)*/ nullptr,
      /*decltype(_impl_.transit_egress_info_)*/ nullptr,
      /*decltype(_impl_.cost_)*/ nullptr,
      /*decltype(_impl_.bss_info_)*/ nullptr,
      /*decltype(_impl_.admin_index_)*/ 0u,
      /*decltype(_impl_.type_)*/ 0,
      /*decltype(_impl_.fork_)*/ false,
    } {}
struct TripLeg_NodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_NodeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_NodeDefaultTypeInternal() {}
  union {
    TripLeg_Node _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_NodeDefaultTypeInternal _TripLeg_Node_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR TripLeg_Admin::TripLeg_Admin(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.country_code_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.country_text_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.state_code_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.state_text_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct TripLeg_AdminDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_AdminDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_AdminDefaultTypeInternal() {}
  union {
    TripLeg_Admin _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_AdminDefaultTypeInternal _TripLeg_Admin_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.time_)*/ {},
      /* _impl_._time_cached_byte_size_ = */ {0},
      /*decltype(_impl_.length_)*/ {},
      /* _impl_._length_cached_byte_size_ = */ {0},
      /*decltype(_impl_.speed_)*/ {},
      /* _impl_._speed_cached_byte_size_ = */ {0},
      /*decltype(_impl_.speed_limit_)*/ {},
      /* _impl_._speed_limit_cached_byte_size_ = */ {0},
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct TripLeg_ShapeAttributesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_ShapeAttributesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_ShapeAttributesDefaultTypeInternal() {}
  union {
    TripLeg_ShapeAttributes _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_ShapeAttributesDefaultTypeInternal _TripLeg_ShapeAttributes_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR TripLeg_Incident::TripLeg_Incident(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.metadata_)*/ nullptr,
      /*decltype(_impl_.begin_shape_index_)*/ 0u,
      /*decltype(_impl_.end_shape_index_)*/ 0u,
    } {}
struct TripLeg_IncidentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_IncidentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_IncidentDefaultTypeInternal() {}
  union {
    TripLeg_Incident _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_IncidentDefaultTypeInternal _TripLeg_Incident_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR TripLeg_Closure::TripLeg_Closure(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.has_begin_shape_index_)*/ {},
      /*decltype(_impl_.has_end_shape_index_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct TripLeg_ClosureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_ClosureDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_ClosureDefaultTypeInternal() {}
  union {
    TripLeg_Closure _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_ClosureDefaultTypeInternal _TripLeg_Closure_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR TripLeg::TripLeg(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.location_)*/ {},
      /*decltype(_impl_.node_)*/ {},
      /*decltype(_impl_.admin_)*/ {},
      /*decltype(_impl_.incidents_)*/ {},
      /*decltype(_impl_.algorithms_)*/ {},
      /*decltype(_impl_.closures_)*/ {},
      /*decltype(_impl_.shape_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.bbox_)*/ nullptr,
      /*decltype(_impl_.shape_attributes_)*/ nullptr,
      /*decltype(_impl_.osm_changeset_)*/ ::uint64_t{0u},
      /*decltype(_impl_.trip_id_)*/ ::uint64_t{0u},
      /*decltype(_impl_.leg_id_)*/ 0u,
      /*decltype(_impl_.leg_count_)*/ 0u,
    } {}
struct TripLegDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLegDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLegDefaultTypeInternal() {}
  union {
    TripLeg _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLegDefaultTypeInternal _TripLeg_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR TripRoute::TripRoute(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.legs_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct TripRouteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripRouteDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripRouteDefaultTypeInternal() {}
  union {
    TripRoute _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripRouteDefaultTypeInternal _TripRoute_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Trip::Trip(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.routes_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct TripDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripDefaultTypeInternal() {}
  union {
    Trip _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripDefaultTypeInternal _Trip_default_instance_;
}  // namespace valhalla
namespace valhalla {
bool TripLeg_Node_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TripLeg_Node_Type_strings[15] = {};

static const char TripLeg_Node_Type_names[] = {
    "kBikeShare"
    "kBollard"
    "kBorderControl"
    "kBuildingEntrance"
    "kElevator"
    "kGate"
    "kMotorwayJunction"
    "kParking"
    "kStreetIntersection"
    "kSumpBuster"
    "kTollBooth"
    "kTollGantry"
    "kTransitEgress"
    "kTransitPlatform"
    "kTransitStation"
};

static const ::google::protobuf::internal::EnumEntry TripLeg_Node_Type_entries[] =
    {
        {{&TripLeg_Node_Type_names[0], 10}, 7},
        {{&TripLeg_Node_Type_names[10], 8}, 2},
        {{&TripLeg_Node_Type_names[18], 14}, 10},
        {{&TripLeg_Node_Type_names[32], 17}, 13},
        {{&TripLeg_Node_Type_names[49], 9}, 14},
        {{&TripLeg_Node_Type_names[58], 5}, 1},
        {{&TripLeg_Node_Type_names[63], 17}, 9},
        {{&TripLeg_Node_Type_names[80], 8}, 8},
        {{&TripLeg_Node_Type_names[88], 19}, 0},
        {{&TripLeg_Node_Type_names[107], 11}, 12},
        {{&TripLeg_Node_Type_names[118], 10}, 3},
        {{&TripLeg_Node_Type_names[128], 11}, 11},
        {{&TripLeg_Node_Type_names[139], 14}, 4},
        {{&TripLeg_Node_Type_names[153], 16}, 6},
        {{&TripLeg_Node_Type_names[169], 15}, 5},
};

static const int TripLeg_Node_Type_entries_by_number[] = {
    8,  // 0 -> kStreetIntersection
    5,  // 1 -> kGate
    1,  // 2 -> kBollard
    10,  // 3 -> kTollBooth
    12,  // 4 -> kTransitEgress
    14,  // 5 -> kTransitStation
    13,  // 6 -> kTransitPlatform
    0,  // 7 -> kBikeShare
    7,  // 8 -> kParking
    6,  // 9 -> kMotorwayJunction
    2,  // 10 -> kBorderControl
    11,  // 11 -> kTollGantry
    9,  // 12 -> kSumpBuster
    3,  // 13 -> kBuildingEntrance
    4,  // 14 -> kElevator
};

const std::string& TripLeg_Node_Type_Name(TripLeg_Node_Type value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TripLeg_Node_Type_entries, TripLeg_Node_Type_entries_by_number,
          15, TripLeg_Node_Type_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TripLeg_Node_Type_entries, TripLeg_Node_Type_entries_by_number, 15,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TripLeg_Node_Type_strings[idx].get();
}

bool TripLeg_Node_Type_Parse(absl::string_view name, TripLeg_Node_Type* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TripLeg_Node_Type_entries, 15, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Node_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TripLeg_Node_Type TripLeg_Node::kStreetIntersection;
constexpr TripLeg_Node_Type TripLeg_Node::kGate;
constexpr TripLeg_Node_Type TripLeg_Node::kBollard;
constexpr TripLeg_Node_Type TripLeg_Node::kTollBooth;
constexpr TripLeg_Node_Type TripLeg_Node::kTransitEgress;
constexpr TripLeg_Node_Type TripLeg_Node::kTransitStation;
constexpr TripLeg_Node_Type TripLeg_Node::kTransitPlatform;
constexpr TripLeg_Node_Type TripLeg_Node::kBikeShare;
constexpr TripLeg_Node_Type TripLeg_Node::kParking;
constexpr TripLeg_Node_Type TripLeg_Node::kMotorwayJunction;
constexpr TripLeg_Node_Type TripLeg_Node::kBorderControl;
constexpr TripLeg_Node_Type TripLeg_Node::kTollGantry;
constexpr TripLeg_Node_Type TripLeg_Node::kSumpBuster;
constexpr TripLeg_Node_Type TripLeg_Node::kBuildingEntrance;
constexpr TripLeg_Node_Type TripLeg_Node::kElevator;
constexpr TripLeg_Node_Type TripLeg_Node::Type_MIN;
constexpr TripLeg_Node_Type TripLeg_Node::Type_MAX;
constexpr int TripLeg_Node::Type_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_Traversability_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TripLeg_Traversability_strings[4] = {};

static const char TripLeg_Traversability_names[] = {
    "kBackward"
    "kBoth"
    "kForward"
    "kNone"
};

static const ::google::protobuf::internal::EnumEntry TripLeg_Traversability_entries[] =
    {
        {{&TripLeg_Traversability_names[0], 9}, 2},
        {{&TripLeg_Traversability_names[9], 5}, 3},
        {{&TripLeg_Traversability_names[14], 8}, 1},
        {{&TripLeg_Traversability_names[22], 5}, 0},
};

static const int TripLeg_Traversability_entries_by_number[] = {
    3,  // 0 -> kNone
    2,  // 1 -> kForward
    0,  // 2 -> kBackward
    1,  // 3 -> kBoth
};

const std::string& TripLeg_Traversability_Name(TripLeg_Traversability value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TripLeg_Traversability_entries, TripLeg_Traversability_entries_by_number,
          4, TripLeg_Traversability_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TripLeg_Traversability_entries, TripLeg_Traversability_entries_by_number, 4,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TripLeg_Traversability_strings[idx].get();
}

bool TripLeg_Traversability_Parse(absl::string_view name, TripLeg_Traversability* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TripLeg_Traversability_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Traversability>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TripLeg_Traversability TripLeg::kNone;
constexpr TripLeg_Traversability TripLeg::kForward;
constexpr TripLeg_Traversability TripLeg::kBackward;
constexpr TripLeg_Traversability TripLeg::kBoth;
constexpr TripLeg_Traversability TripLeg::Traversability_MIN;
constexpr TripLeg_Traversability TripLeg::Traversability_MAX;
constexpr int TripLeg::Traversability_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_Use_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 20:
    case 21:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 40:
    case 41:
    case 42:
    case 43:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
      return true;
    default:
      return false;
  }
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TripLeg_Use_strings[34] = {};

static const char TripLeg_Use_names[] = {
    "kAlleyUse"
    "kBridlewayUse"
    "kBusUse"
    "kConstructionUse"
    "kCuldesacUse"
    "kCyclewayUse"
    "kDriveThruUse"
    "kDrivewayUse"
    "kEgressConnectionUse"
    "kElevatorUse"
    "kEmergencyAccessUse"
    "kEscalatorUse"
    "kFerryUse"
    "kFootwayUse"
    "kLivingStreetUse"
    "kMountainBikeUse"
    "kOtherUse"
    "kParkingAisleUse"
    "kPathUse"
    "kPedestrianCrossingUse"
    "kPedestrianUse"
    "kPlatformConnectionUse"
    "kRailFerryUse"
    "kRailUse"
    "kRampUse"
    "kRestAreaUse"
    "kRoadUse"
    "kServiceAreaUse"
    "kServiceRoadUse"
    "kSidewalkUse"
    "kStepsUse"
    "kTrackUse"
    "kTransitConnectionUse"
    "kTurnChannelUse"
};

static const ::google::protobuf::internal::EnumEntry TripLeg_Use_entries[] =
    {
        {{&TripLeg_Use_names[0], 9}, 5},
        {{&TripLeg_Use_names[9], 13}, 29},
        {{&TripLeg_Use_names[22], 7}, 51},
        {{&TripLeg_Use_names[29], 16}, 43},
        {{&TripLeg_Use_names[45], 12}, 9},
        {{&TripLeg_Use_names[57], 12}, 20},
        {{&TripLeg_Use_names[69], 13}, 8},
        {{&TripLeg_Use_names[82], 12}, 4},
        {{&TripLeg_Use_names[94], 20}, 52},
        {{&TripLeg_Use_names[114], 12}, 33},
        {{&TripLeg_Use_names[126], 19}, 7},
        {{&TripLeg_Use_names[145], 13}, 34},
        {{&TripLeg_Use_names[158], 9}, 41},
        {{&TripLeg_Use_names[167], 11}, 25},
        {{&TripLeg_Use_names[178], 16}, 10},
        {{&TripLeg_Use_names[194], 16}, 21},
        {{&TripLeg_Use_names[210], 9}, 40},
        {{&TripLeg_Use_names[219], 16}, 6},
        {{&TripLeg_Use_names[235], 8}, 27},
        {{&TripLeg_Use_names[243], 22}, 32},
        {{&TripLeg_Use_names[265], 14}, 28},
        {{&TripLeg_Use_names[279], 22}, 53},
        {{&TripLeg_Use_names[301], 13}, 42},
        {{&TripLeg_Use_names[314], 8}, 50},
        {{&TripLeg_Use_names[322], 8}, 1},
        {{&TripLeg_Use_names[330], 12}, 30},
        {{&TripLeg_Use_names[342], 8}, 0},
        {{&TripLeg_Use_names[350], 15}, 31},
        {{&TripLeg_Use_names[365], 15}, 11},
        {{&TripLeg_Use_names[380], 12}, 24},
        {{&TripLeg_Use_names[392], 9}, 26},
        {{&TripLeg_Use_names[401], 9}, 3},
        {{&TripLeg_Use_names[410], 21}, 54},
        {{&TripLeg_Use_names[431], 15}, 2},
};

static const int TripLeg_Use_entries_by_number[] = {
    26,  // 0 -> kRoadUse
    24,  // 1 -> kRampUse
    33,  // 2 -> kTurnChannelUse
    31,  // 3 -> kTrackUse
    7,  // 4 -> kDrivewayUse
    0,  // 5 -> kAlleyUse
    17,  // 6 -> kParkingAisleUse
    10,  // 7 -> kEmergencyAccessUse
    6,  // 8 -> kDriveThruUse
    4,  // 9 -> kCuldesacUse
    14,  // 10 -> kLivingStreetUse
    28,  // 11 -> kServiceRoadUse
    5,  // 20 -> kCyclewayUse
    15,  // 21 -> kMountainBikeUse
    29,  // 24 -> kSidewalkUse
    13,  // 25 -> kFootwayUse
    30,  // 26 -> kStepsUse
    18,  // 27 -> kPathUse
    20,  // 28 -> kPedestrianUse
    1,  // 29 -> kBridlewayUse
    25,  // 30 -> kRestAreaUse
    27,  // 31 -> kServiceAreaUse
    19,  // 32 -> kPedestrianCrossingUse
    9,  // 33 -> kElevatorUse
    11,  // 34 -> kEscalatorUse
    16,  // 40 -> kOtherUse
    12,  // 41 -> kFerryUse
    22,  // 42 -> kRailFerryUse
    3,  // 43 -> kConstructionUse
    23,  // 50 -> kRailUse
    2,  // 51 -> kBusUse
    8,  // 52 -> kEgressConnectionUse
    21,  // 53 -> kPlatformConnectionUse
    32,  // 54 -> kTransitConnectionUse
};

const std::string& TripLeg_Use_Name(TripLeg_Use value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TripLeg_Use_entries, TripLeg_Use_entries_by_number,
          34, TripLeg_Use_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TripLeg_Use_entries, TripLeg_Use_entries_by_number, 34,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TripLeg_Use_strings[idx].get();
}

bool TripLeg_Use_Parse(absl::string_view name, TripLeg_Use* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TripLeg_Use_entries, 34, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Use>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TripLeg_Use TripLeg::kRoadUse;
constexpr TripLeg_Use TripLeg::kRampUse;
constexpr TripLeg_Use TripLeg::kTurnChannelUse;
constexpr TripLeg_Use TripLeg::kTrackUse;
constexpr TripLeg_Use TripLeg::kDrivewayUse;
constexpr TripLeg_Use TripLeg::kAlleyUse;
constexpr TripLeg_Use TripLeg::kParkingAisleUse;
constexpr TripLeg_Use TripLeg::kEmergencyAccessUse;
constexpr TripLeg_Use TripLeg::kDriveThruUse;
constexpr TripLeg_Use TripLeg::kCuldesacUse;
constexpr TripLeg_Use TripLeg::kLivingStreetUse;
constexpr TripLeg_Use TripLeg::kServiceRoadUse;
constexpr TripLeg_Use TripLeg::kCyclewayUse;
constexpr TripLeg_Use TripLeg::kMountainBikeUse;
constexpr TripLeg_Use TripLeg::kSidewalkUse;
constexpr TripLeg_Use TripLeg::kFootwayUse;
constexpr TripLeg_Use TripLeg::kStepsUse;
constexpr TripLeg_Use TripLeg::kPathUse;
constexpr TripLeg_Use TripLeg::kPedestrianUse;
constexpr TripLeg_Use TripLeg::kBridlewayUse;
constexpr TripLeg_Use TripLeg::kPedestrianCrossingUse;
constexpr TripLeg_Use TripLeg::kElevatorUse;
constexpr TripLeg_Use TripLeg::kEscalatorUse;
constexpr TripLeg_Use TripLeg::kRestAreaUse;
constexpr TripLeg_Use TripLeg::kServiceAreaUse;
constexpr TripLeg_Use TripLeg::kOtherUse;
constexpr TripLeg_Use TripLeg::kFerryUse;
constexpr TripLeg_Use TripLeg::kRailFerryUse;
constexpr TripLeg_Use TripLeg::kConstructionUse;
constexpr TripLeg_Use TripLeg::kRailUse;
constexpr TripLeg_Use TripLeg::kBusUse;
constexpr TripLeg_Use TripLeg::kEgressConnectionUse;
constexpr TripLeg_Use TripLeg::kPlatformConnectionUse;
constexpr TripLeg_Use TripLeg::kTransitConnectionUse;
constexpr TripLeg_Use TripLeg::Use_MIN;
constexpr TripLeg_Use TripLeg::Use_MAX;
constexpr int TripLeg::Use_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_Surface_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TripLeg_Surface_strings[8] = {};

static const char TripLeg_Surface_names[] = {
    "kCompacted"
    "kDirt"
    "kGravel"
    "kImpassable"
    "kPath"
    "kPaved"
    "kPavedRough"
    "kPavedSmooth"
};

static const ::google::protobuf::internal::EnumEntry TripLeg_Surface_entries[] =
    {
        {{&TripLeg_Surface_names[0], 10}, 3},
        {{&TripLeg_Surface_names[10], 5}, 4},
        {{&TripLeg_Surface_names[15], 7}, 5},
        {{&TripLeg_Surface_names[22], 11}, 7},
        {{&TripLeg_Surface_names[33], 5}, 6},
        {{&TripLeg_Surface_names[38], 6}, 1},
        {{&TripLeg_Surface_names[44], 11}, 2},
        {{&TripLeg_Surface_names[55], 12}, 0},
};

static const int TripLeg_Surface_entries_by_number[] = {
    7,  // 0 -> kPavedSmooth
    5,  // 1 -> kPaved
    6,  // 2 -> kPavedRough
    0,  // 3 -> kCompacted
    1,  // 4 -> kDirt
    2,  // 5 -> kGravel
    4,  // 6 -> kPath
    3,  // 7 -> kImpassable
};

const std::string& TripLeg_Surface_Name(TripLeg_Surface value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TripLeg_Surface_entries, TripLeg_Surface_entries_by_number,
          8, TripLeg_Surface_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TripLeg_Surface_entries, TripLeg_Surface_entries_by_number, 8,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TripLeg_Surface_strings[idx].get();
}

bool TripLeg_Surface_Parse(absl::string_view name, TripLeg_Surface* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TripLeg_Surface_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Surface>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TripLeg_Surface TripLeg::kPavedSmooth;
constexpr TripLeg_Surface TripLeg::kPaved;
constexpr TripLeg_Surface TripLeg::kPavedRough;
constexpr TripLeg_Surface TripLeg::kCompacted;
constexpr TripLeg_Surface TripLeg::kDirt;
constexpr TripLeg_Surface TripLeg::kGravel;
constexpr TripLeg_Surface TripLeg::kPath;
constexpr TripLeg_Surface TripLeg::kImpassable;
constexpr TripLeg_Surface TripLeg::Surface_MIN;
constexpr TripLeg_Surface TripLeg::Surface_MAX;
constexpr int TripLeg::Surface_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_CycleLane_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TripLeg_CycleLane_strings[4] = {};

static const char TripLeg_CycleLane_names[] = {
    "kDedicated"
    "kNoCycleLane"
    "kSeparated"
    "kShared"
};

static const ::google::protobuf::internal::EnumEntry TripLeg_CycleLane_entries[] =
    {
        {{&TripLeg_CycleLane_names[0], 10}, 2},
        {{&TripLeg_CycleLane_names[10], 12}, 0},
        {{&TripLeg_CycleLane_names[22], 10}, 3},
        {{&TripLeg_CycleLane_names[32], 7}, 1},
};

static const int TripLeg_CycleLane_entries_by_number[] = {
    1,  // 0 -> kNoCycleLane
    3,  // 1 -> kShared
    0,  // 2 -> kDedicated
    2,  // 3 -> kSeparated
};

const std::string& TripLeg_CycleLane_Name(TripLeg_CycleLane value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TripLeg_CycleLane_entries, TripLeg_CycleLane_entries_by_number,
          4, TripLeg_CycleLane_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TripLeg_CycleLane_entries, TripLeg_CycleLane_entries_by_number, 4,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TripLeg_CycleLane_strings[idx].get();
}

bool TripLeg_CycleLane_Parse(absl::string_view name, TripLeg_CycleLane* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TripLeg_CycleLane_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_CycleLane>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TripLeg_CycleLane TripLeg::kNoCycleLane;
constexpr TripLeg_CycleLane TripLeg::kShared;
constexpr TripLeg_CycleLane TripLeg::kDedicated;
constexpr TripLeg_CycleLane TripLeg::kSeparated;
constexpr TripLeg_CycleLane TripLeg::CycleLane_MIN;
constexpr TripLeg_CycleLane TripLeg::CycleLane_MAX;
constexpr int TripLeg::CycleLane_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_SacScale_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TripLeg_SacScale_strings[7] = {};

static const char TripLeg_SacScale_names[] = {
    "kAlpineHiking"
    "kDemandingAlpineHiking"
    "kDemandingMountainHiking"
    "kDifficultAlpineHiking"
    "kHiking"
    "kMountainHiking"
    "kNoSacScale"
};

static const ::google::protobuf::internal::EnumEntry TripLeg_SacScale_entries[] =
    {
        {{&TripLeg_SacScale_names[0], 13}, 4},
        {{&TripLeg_SacScale_names[13], 22}, 5},
        {{&TripLeg_SacScale_names[35], 24}, 3},
        {{&TripLeg_SacScale_names[59], 22}, 6},
        {{&TripLeg_SacScale_names[81], 7}, 1},
        {{&TripLeg_SacScale_names[88], 15}, 2},
        {{&TripLeg_SacScale_names[103], 11}, 0},
};

static const int TripLeg_SacScale_entries_by_number[] = {
    6,  // 0 -> kNoSacScale
    4,  // 1 -> kHiking
    5,  // 2 -> kMountainHiking
    2,  // 3 -> kDemandingMountainHiking
    0,  // 4 -> kAlpineHiking
    1,  // 5 -> kDemandingAlpineHiking
    3,  // 6 -> kDifficultAlpineHiking
};

const std::string& TripLeg_SacScale_Name(TripLeg_SacScale value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TripLeg_SacScale_entries, TripLeg_SacScale_entries_by_number,
          7, TripLeg_SacScale_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TripLeg_SacScale_entries, TripLeg_SacScale_entries_by_number, 7,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TripLeg_SacScale_strings[idx].get();
}

bool TripLeg_SacScale_Parse(absl::string_view name, TripLeg_SacScale* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TripLeg_SacScale_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_SacScale>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TripLeg_SacScale TripLeg::kNoSacScale;
constexpr TripLeg_SacScale TripLeg::kHiking;
constexpr TripLeg_SacScale TripLeg::kMountainHiking;
constexpr TripLeg_SacScale TripLeg::kDemandingMountainHiking;
constexpr TripLeg_SacScale TripLeg::kAlpineHiking;
constexpr TripLeg_SacScale TripLeg::kDemandingAlpineHiking;
constexpr TripLeg_SacScale TripLeg::kDifficultAlpineHiking;
constexpr TripLeg_SacScale TripLeg::SacScale_MIN;
constexpr TripLeg_SacScale TripLeg::SacScale_MAX;
constexpr int TripLeg::SacScale_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_Sidewalk_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TripLeg_Sidewalk_strings[4] = {};

static const char TripLeg_Sidewalk_names[] = {
    "kBothSides"
    "kLeft"
    "kNoSidewalk"
    "kRight"
};

static const ::google::protobuf::internal::EnumEntry TripLeg_Sidewalk_entries[] =
    {
        {{&TripLeg_Sidewalk_names[0], 10}, 3},
        {{&TripLeg_Sidewalk_names[10], 5}, 1},
        {{&TripLeg_Sidewalk_names[15], 11}, 0},
        {{&TripLeg_Sidewalk_names[26], 6}, 2},
};

static const int TripLeg_Sidewalk_entries_by_number[] = {
    2,  // 0 -> kNoSidewalk
    1,  // 1 -> kLeft
    3,  // 2 -> kRight
    0,  // 3 -> kBothSides
};

const std::string& TripLeg_Sidewalk_Name(TripLeg_Sidewalk value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TripLeg_Sidewalk_entries, TripLeg_Sidewalk_entries_by_number,
          4, TripLeg_Sidewalk_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TripLeg_Sidewalk_entries, TripLeg_Sidewalk_entries_by_number, 4,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TripLeg_Sidewalk_strings[idx].get();
}

bool TripLeg_Sidewalk_Parse(absl::string_view name, TripLeg_Sidewalk* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TripLeg_Sidewalk_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Sidewalk>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TripLeg_Sidewalk TripLeg::kNoSidewalk;
constexpr TripLeg_Sidewalk TripLeg::kLeft;
constexpr TripLeg_Sidewalk TripLeg::kRight;
constexpr TripLeg_Sidewalk TripLeg::kBothSides;
constexpr TripLeg_Sidewalk TripLeg::Sidewalk_MIN;
constexpr TripLeg_Sidewalk TripLeg::Sidewalk_MAX;
constexpr int TripLeg::Sidewalk_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

class TripLeg_LaneConnectivity::_Internal {
 public:
};

TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.LaneConnectivity)
}
TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(const TripLeg_LaneConnectivity& from) : ::google::protobuf::MessageLite() {
  TripLeg_LaneConnectivity* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.from_lanes_){},
      decltype(_impl_.to_lanes_){},
      decltype(_impl_.from_way_id_){},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  _impl_.from_lanes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.from_lanes_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_from_lanes().empty()) {
    _this->_impl_.from_lanes_.Set(from._internal_from_lanes(), _this->GetArenaForAllocation());
  }
  _impl_.to_lanes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.to_lanes_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_to_lanes().empty()) {
    _this->_impl_.to_lanes_.Set(from._internal_to_lanes(), _this->GetArenaForAllocation());
  }
  _this->_impl_.from_way_id_ = from._impl_.from_way_id_;

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.LaneConnectivity)
}
inline void TripLeg_LaneConnectivity::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.from_lanes_){},
      decltype(_impl_.to_lanes_){},
      decltype(_impl_.from_way_id_){::uint64_t{0u}},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _impl_.from_lanes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.from_lanes_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.to_lanes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.to_lanes_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
TripLeg_LaneConnectivity::~TripLeg_LaneConnectivity() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.LaneConnectivity)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void TripLeg_LaneConnectivity::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.from_lanes_.Destroy();
  _impl_.to_lanes_.Destroy();
}
void TripLeg_LaneConnectivity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void TripLeg_LaneConnectivity::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.LaneConnectivity)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.from_lanes_.ClearToEmpty();
  _impl_.to_lanes_.ClearToEmpty();
  _impl_.from_way_id_ = ::uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_LaneConnectivity::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 60, 2> TripLeg_LaneConnectivity::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_TripLeg_LaneConnectivity_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // uint64 from_way_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_LaneConnectivity, _impl_.from_way_id_)}},
    // string from_lanes = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_LaneConnectivity, _impl_.from_lanes_)}},
    // string to_lanes = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_LaneConnectivity, _impl_.to_lanes_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint64 from_way_id = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_LaneConnectivity, _impl_.from_way_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // string from_lanes = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_LaneConnectivity, _impl_.from_lanes_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string to_lanes = 3;
    {PROTOBUF_FIELD_OFFSET(TripLeg_LaneConnectivity, _impl_.to_lanes_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\41\0\12\10\0\0\0\0"
    "valhalla.TripLeg.LaneConnectivity"
    "from_lanes"
    "to_lanes"
  }},
};

::uint8_t* TripLeg_LaneConnectivity::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.LaneConnectivity)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint64 from_way_id = 1;
  if (this->_internal_from_way_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_from_way_id(), target);
  }

  // string from_lanes = 2;
  if (!this->_internal_from_lanes().empty()) {
    const std::string& _s = this->_internal_from_lanes();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TripLeg.LaneConnectivity.from_lanes");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string to_lanes = 3;
  if (!this->_internal_to_lanes().empty()) {
    const std::string& _s = this->_internal_to_lanes();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TripLeg.LaneConnectivity.to_lanes");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.LaneConnectivity)
  return target;
}

::size_t TripLeg_LaneConnectivity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.LaneConnectivity)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string from_lanes = 2;
  if (!this->_internal_from_lanes().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_from_lanes());
  }

  // string to_lanes = 3;
  if (!this->_internal_to_lanes().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_to_lanes());
  }

  // uint64 from_way_id = 1;
  if (this->_internal_from_way_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_from_way_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_LaneConnectivity::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_LaneConnectivity*>(
      &from));
}

void TripLeg_LaneConnectivity::MergeFrom(const TripLeg_LaneConnectivity& from) {
  TripLeg_LaneConnectivity* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.LaneConnectivity)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_from_lanes().empty()) {
    _this->_internal_set_from_lanes(from._internal_from_lanes());
  }
  if (!from._internal_to_lanes().empty()) {
    _this->_internal_set_to_lanes(from._internal_to_lanes());
  }
  if (from._internal_from_way_id() != 0) {
    _this->_internal_set_from_way_id(from._internal_from_way_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_LaneConnectivity::CopyFrom(const TripLeg_LaneConnectivity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.LaneConnectivity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TripLeg_LaneConnectivity::IsInitialized() const {
  return true;
}

void TripLeg_LaneConnectivity::InternalSwap(TripLeg_LaneConnectivity* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.from_lanes_, lhs_arena,
                                       &other->_impl_.from_lanes_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.to_lanes_, lhs_arena,
                                       &other->_impl_.to_lanes_, rhs_arena);
        swap(_impl_.from_way_id_, other->_impl_.from_way_id_);
}

std::string TripLeg_LaneConnectivity::GetTypeName() const {
  return "valhalla.TripLeg.LaneConnectivity";
}

// ===================================================================

class TripLeg_TrafficSegment::_Internal {
 public:
};

TripLeg_TrafficSegment::TripLeg_TrafficSegment(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.TrafficSegment)
}
TripLeg_TrafficSegment::TripLeg_TrafficSegment(const TripLeg_TrafficSegment& from)
    : ::google::protobuf::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.TrafficSegment)
}
inline void TripLeg_TrafficSegment::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.segment_id_){::uint64_t{0u}},
      decltype(_impl_.begin_percent_){0},
      decltype(_impl_.end_percent_){0},
      decltype(_impl_.starts_segment_){false},
      decltype(_impl_.ends_segment_){false},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
TripLeg_TrafficSegment::~TripLeg_TrafficSegment() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.TrafficSegment)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void TripLeg_TrafficSegment::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void TripLeg_TrafficSegment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void TripLeg_TrafficSegment::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.TrafficSegment)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.segment_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.ends_segment_) -
      reinterpret_cast<char*>(&_impl_.segment_id_)) + sizeof(_impl_.ends_segment_));
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_TrafficSegment::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2> TripLeg_TrafficSegment::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_TripLeg_TrafficSegment_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // uint64 segment_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.segment_id_)}},
    // float begin_percent = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.begin_percent_)}},
    // float end_percent = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.end_percent_)}},
    // bool starts_segment = 4;
    {::_pbi::TcParser::FastV8S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.starts_segment_)}},
    // bool ends_segment = 5;
    {::_pbi::TcParser::FastV8S1,
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.ends_segment_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // uint64 segment_id = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.segment_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // float begin_percent = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.begin_percent_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float end_percent = 3;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.end_percent_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // bool starts_segment = 4;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.starts_segment_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool ends_segment = 5;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.ends_segment_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* TripLeg_TrafficSegment::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.TrafficSegment)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint64 segment_id = 1;
  if (this->_internal_segment_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_segment_id(), target);
  }

  // float begin_percent = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_begin_percent = this->_internal_begin_percent();
  ::uint32_t raw_begin_percent;
  memcpy(&raw_begin_percent, &tmp_begin_percent, sizeof(tmp_begin_percent));
  if (raw_begin_percent != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_begin_percent(), target);
  }

  // float end_percent = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_end_percent = this->_internal_end_percent();
  ::uint32_t raw_end_percent;
  memcpy(&raw_end_percent, &tmp_end_percent, sizeof(tmp_end_percent));
  if (raw_end_percent != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_end_percent(), target);
  }

  // bool starts_segment = 4;
  if (this->_internal_starts_segment() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_starts_segment(), target);
  }

  // bool ends_segment = 5;
  if (this->_internal_ends_segment() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_ends_segment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.TrafficSegment)
  return target;
}

::size_t TripLeg_TrafficSegment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.TrafficSegment)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 segment_id = 1;
  if (this->_internal_segment_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_segment_id());
  }

  // float begin_percent = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_begin_percent = this->_internal_begin_percent();
  ::uint32_t raw_begin_percent;
  memcpy(&raw_begin_percent, &tmp_begin_percent, sizeof(tmp_begin_percent));
  if (raw_begin_percent != 0) {
    total_size += 5;
  }

  // float end_percent = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_end_percent = this->_internal_end_percent();
  ::uint32_t raw_end_percent;
  memcpy(&raw_end_percent, &tmp_end_percent, sizeof(tmp_end_percent));
  if (raw_end_percent != 0) {
    total_size += 5;
  }

  // bool starts_segment = 4;
  if (this->_internal_starts_segment() != 0) {
    total_size += 2;
  }

  // bool ends_segment = 5;
  if (this->_internal_ends_segment() != 0) {
    total_size += 2;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_TrafficSegment::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_TrafficSegment*>(
      &from));
}

void TripLeg_TrafficSegment::MergeFrom(const TripLeg_TrafficSegment& from) {
  TripLeg_TrafficSegment* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.TrafficSegment)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_segment_id() != 0) {
    _this->_internal_set_segment_id(from._internal_segment_id());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_begin_percent = from._internal_begin_percent();
  ::uint32_t raw_begin_percent;
  memcpy(&raw_begin_percent, &tmp_begin_percent, sizeof(tmp_begin_percent));
  if (raw_begin_percent != 0) {
    _this->_internal_set_begin_percent(from._internal_begin_percent());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_end_percent = from._internal_end_percent();
  ::uint32_t raw_end_percent;
  memcpy(&raw_end_percent, &tmp_end_percent, sizeof(tmp_end_percent));
  if (raw_end_percent != 0) {
    _this->_internal_set_end_percent(from._internal_end_percent());
  }
  if (from._internal_starts_segment() != 0) {
    _this->_internal_set_starts_segment(from._internal_starts_segment());
  }
  if (from._internal_ends_segment() != 0) {
    _this->_internal_set_ends_segment(from._internal_ends_segment());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_TrafficSegment::CopyFrom(const TripLeg_TrafficSegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.TrafficSegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TripLeg_TrafficSegment::IsInitialized() const {
  return true;
}

void TripLeg_TrafficSegment::InternalSwap(TripLeg_TrafficSegment* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.ends_segment_)
      + sizeof(TripLeg_TrafficSegment::_impl_.ends_segment_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.segment_id_)>(
          reinterpret_cast<char*>(&_impl_.segment_id_),
          reinterpret_cast<char*>(&other->_impl_.segment_id_));
}

std::string TripLeg_TrafficSegment::GetTypeName() const {
  return "valhalla.TripLeg.TrafficSegment";
}

// ===================================================================

class TripLeg_Restriction::_Internal {
 public:
};

TripLeg_Restriction::TripLeg_Restriction(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Restriction)
}
TripLeg_Restriction::TripLeg_Restriction(const TripLeg_Restriction& from)
    : ::google::protobuf::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Restriction)
}
inline void TripLeg_Restriction::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){0u},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
TripLeg_Restriction::~TripLeg_Restriction() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Restriction)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void TripLeg_Restriction::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void TripLeg_Restriction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void TripLeg_Restriction::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Restriction)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Restriction::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> TripLeg_Restriction::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_TripLeg_Restriction_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // uint32 type = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Restriction, _impl_.type_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 type = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Restriction, _impl_.type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* TripLeg_Restriction::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Restriction)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint32 type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Restriction)
  return target;
}

::size_t TripLeg_Restriction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Restriction)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 type = 1;
  if (this->_internal_type() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Restriction::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Restriction*>(
      &from));
}

void TripLeg_Restriction::MergeFrom(const TripLeg_Restriction& from) {
  TripLeg_Restriction* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Restriction)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Restriction::CopyFrom(const TripLeg_Restriction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Restriction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TripLeg_Restriction::IsInitialized() const {
  return true;
}

void TripLeg_Restriction::InternalSwap(TripLeg_Restriction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
        swap(_impl_.type_, other->_impl_.type_);
}

std::string TripLeg_Restriction::GetTypeName() const {
  return "valhalla.TripLeg.Restriction";
}

// ===================================================================

class TripLeg_Edge::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_Edge>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_._has_bits_);
  static const ::valhalla::TripSign& sign(const TripLeg_Edge* msg);
  static void set_has_sign(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::valhalla::TransitRouteInfo& transit_route_info(const TripLeg_Edge* msg);
  static void set_has_transit_route_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::valhalla::TripLeg_Restriction& restriction(const TripLeg_Edge* msg);
  static void set_has_restriction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::valhalla::TripSign& TripLeg_Edge::_Internal::sign(const TripLeg_Edge* msg) {
  return *msg->_impl_.sign_;
}
const ::valhalla::TransitRouteInfo& TripLeg_Edge::_Internal::transit_route_info(const TripLeg_Edge* msg) {
  return *msg->_impl_.transit_route_info_;
}
const ::valhalla::TripLeg_Restriction& TripLeg_Edge::_Internal::restriction(const TripLeg_Edge* msg) {
  return *msg->_impl_.restriction_;
}
void TripLeg_Edge::clear_name() {
  _internal_mutable_name()->Clear();
}
void TripLeg_Edge::clear_sign() {
  if (_impl_.sign_ != nullptr) _impl_.sign_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TripLeg_Edge::clear_transit_route_info() {
  if (_impl_.transit_route_info_ != nullptr) _impl_.transit_route_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TripLeg_Edge::clear_turn_lanes() {
  _internal_mutable_turn_lanes()->Clear();
}
void TripLeg_Edge::clear_tagged_value() {
  _internal_mutable_tagged_value()->Clear();
}
TripLeg_Edge::TripLeg_Edge(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Edge)
}
TripLeg_Edge::TripLeg_Edge(const TripLeg_Edge& from) : ::google::protobuf::MessageLite() {
  TripLeg_Edge* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.name_){from._impl_.name_},
      decltype(_impl_.lane_connectivity_){from._impl_.lane_connectivity_},
      decltype(_impl_.traffic_segment_){from._impl_.traffic_segment_},
      decltype(_impl_.turn_lanes_){from._impl_.turn_lanes_},
      decltype(_impl_.tagged_value_){from._impl_.tagged_value_},
      decltype(_impl_.sign_){nullptr},
      decltype(_impl_.transit_route_info_){nullptr},
      decltype(_impl_.restriction_){nullptr},
      decltype(_impl_.length_km_){},
      decltype(_impl_.speed_){},
      decltype(_impl_.road_class_){},
      decltype(_impl_.begin_heading_){},
      decltype(_impl_.end_heading_){},
      decltype(_impl_.begin_shape_index_){},
      decltype(_impl_.end_shape_index_){},
      decltype(_impl_.traversability_){},
      decltype(_impl_.use_){},
      decltype(_impl_.toll_){},
      decltype(_impl_.unpaved_){},
      decltype(_impl_.tunnel_){},
      decltype(_impl_.bridge_){},
      decltype(_impl_.surface_){},
      decltype(_impl_.travel_mode_){},
      decltype(_impl_.roundabout_){},
      decltype(_impl_.internal_intersection_){},
      decltype(_impl_.drive_on_left_){},
      decltype(_impl_.bicycle_network_){},
      decltype(_impl_.vehicle_type_){},
      decltype(_impl_.pedestrian_type_){},
      decltype(_impl_.bicycle_type_){},
      decltype(_impl_.id_){},
      decltype(_impl_.transit_type_){},
      decltype(_impl_.weighted_grade_){},
      decltype(_impl_.way_id_){},
      decltype(_impl_.max_upward_grade_){},
      decltype(_impl_.max_downward_grade_){},
      decltype(_impl_.lane_count_){},
      decltype(_impl_.cycle_lane_){},
      decltype(_impl_.sidewalk_){},
      decltype(_impl_.density_){},
      decltype(_impl_.speed_limit_){},
      decltype(_impl_.truck_speed_){},
      decltype(_impl_.mean_elevation_){},
      decltype(_impl_.truck_route_){},
      decltype(_impl_.has_time_restrictions_){},
      decltype(_impl_.destination_only_){},
      decltype(_impl_.is_urban_){},
      decltype(_impl_.default_speed_){},
      decltype(_impl_.source_along_edge_){},
      decltype(_impl_.target_along_edge_){},
      decltype(_impl_.sac_scale_){},
      decltype(_impl_.shoulder_){},
      decltype(_impl_.indoor_){},
  };
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.sign_ = new ::valhalla::TripSign(*from._impl_.sign_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.transit_route_info_ = new ::valhalla::TransitRouteInfo(*from._impl_.transit_route_info_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.restriction_ = new ::valhalla::TripLeg_Restriction(*from._impl_.restriction_);
  }
  ::memcpy(&_impl_.length_km_, &from._impl_.length_km_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.indoor_) -
    reinterpret_cast<char*>(&_impl_.length_km_)) + sizeof(_impl_.indoor_));

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Edge)
}
inline void TripLeg_Edge::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.name_){arena},
      decltype(_impl_.lane_connectivity_){arena},
      decltype(_impl_.traffic_segment_){arena},
      decltype(_impl_.turn_lanes_){arena},
      decltype(_impl_.tagged_value_){arena},
      decltype(_impl_.sign_){nullptr},
      decltype(_impl_.transit_route_info_){nullptr},
      decltype(_impl_.restriction_){nullptr},
      decltype(_impl_.length_km_){0},
      decltype(_impl_.speed_){0},
      decltype(_impl_.road_class_){0},
      decltype(_impl_.begin_heading_){0u},
      decltype(_impl_.end_heading_){0u},
      decltype(_impl_.begin_shape_index_){0u},
      decltype(_impl_.end_shape_index_){0u},
      decltype(_impl_.traversability_){0},
      decltype(_impl_.use_){0},
      decltype(_impl_.toll_){false},
      decltype(_impl_.unpaved_){false},
      decltype(_impl_.tunnel_){false},
      decltype(_impl_.bridge_){false},
      decltype(_impl_.surface_){0},
      decltype(_impl_.travel_mode_){0},
      decltype(_impl_.roundabout_){false},
      decltype(_impl_.internal_intersection_){false},
      decltype(_impl_.drive_on_left_){false},
      decltype(_impl_.bicycle_network_){false},
      decltype(_impl_.vehicle_type_){0},
      decltype(_impl_.pedestrian_type_){0},
      decltype(_impl_.bicycle_type_){0},
      decltype(_impl_.id_){::uint64_t{0u}},
      decltype(_impl_.transit_type_){0},
      decltype(_impl_.weighted_grade_){0},
      decltype(_impl_.way_id_){::uint64_t{0u}},
      decltype(_impl_.max_upward_grade_){0},
      decltype(_impl_.max_downward_grade_){0},
      decltype(_impl_.lane_count_){0u},
      decltype(_impl_.cycle_lane_){0},
      decltype(_impl_.sidewalk_){0},
      decltype(_impl_.density_){0u},
      decltype(_impl_.speed_limit_){0u},
      decltype(_impl_.truck_speed_){0},
      decltype(_impl_.mean_elevation_){0},
      decltype(_impl_.truck_route_){false},
      decltype(_impl_.has_time_restrictions_){false},
      decltype(_impl_.destination_only_){false},
      decltype(_impl_.is_urban_){false},
      decltype(_impl_.default_speed_){0},
      decltype(_impl_.source_along_edge_){0},
      decltype(_impl_.target_along_edge_){0},
      decltype(_impl_.sac_scale_){0},
      decltype(_impl_.shoulder_){false},
      decltype(_impl_.indoor_){false},
  };
}
TripLeg_Edge::~TripLeg_Edge() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Edge)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void TripLeg_Edge::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.~RepeatedPtrField();
  _impl_.lane_connectivity_.~RepeatedPtrField();
  _impl_.traffic_segment_.~RepeatedPtrField();
  _impl_.turn_lanes_.~RepeatedPtrField();
  _impl_.tagged_value_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.sign_;
  if (this != internal_default_instance()) delete _impl_.transit_route_info_;
  if (this != internal_default_instance()) delete _impl_.restriction_;
}
void TripLeg_Edge::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void TripLeg_Edge::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Edge)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_name()->Clear();
  _internal_mutable_lane_connectivity()->Clear();
  _internal_mutable_traffic_segment()->Clear();
  _internal_mutable_turn_lanes()->Clear();
  _internal_mutable_tagged_value()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.sign_ != nullptr);
      _impl_.sign_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.transit_route_info_ != nullptr);
      _impl_.transit_route_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.restriction_ != nullptr);
      _impl_.restriction_->Clear();
    }
  }
  ::memset(&_impl_.length_km_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.indoor_) -
      reinterpret_cast<char*>(&_impl_.length_km_)) + sizeof(_impl_.indoor_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Edge::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 53, 8, 0, 9> TripLeg_Edge::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_._has_bits_),
    0, // no _extensions_
    53, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    0,  // skipmap
    offsetof(decltype(_table_), field_entries),
    53,  // num_field_entries
    8,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_TripLeg_Edge_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .valhalla.StreetName name = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.name_)}},
    // float length_km = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.length_km_)}},
    // float speed = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.speed_)}},
    // .valhalla.RoadClass road_class = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.road_class_)}},
    // uint32 begin_heading = 5;
    {::_pbi::TcParser::FastV32S1,
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.begin_heading_)}},
    // uint32 end_heading = 6;
    {::_pbi::TcParser::FastV32S1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.end_heading_)}},
    // uint32 begin_shape_index = 7;
    {::_pbi::TcParser::FastV32S1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.begin_shape_index_)}},
    // uint32 end_shape_index = 8;
    {::_pbi::TcParser::FastV32S1,
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.end_shape_index_)}},
    // .valhalla.TripLeg.Traversability traversability = 9;
    {::_pbi::TcParser::FastV32S1,
     {72, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.traversability_)}},
    // .valhalla.TripLeg.Use use = 10;
    {::_pbi::TcParser::FastV32S1,
     {80, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.use_)}},
    // bool toll = 11;
    {::_pbi::TcParser::FastV8S1,
     {88, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.toll_)}},
    // bool unpaved = 12;
    {::_pbi::TcParser::FastV8S1,
     {96, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.unpaved_)}},
    // bool tunnel = 13;
    {::_pbi::TcParser::FastV8S1,
     {104, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.tunnel_)}},
    // bool bridge = 14;
    {::_pbi::TcParser::FastV8S1,
     {112, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.bridge_)}},
    // bool roundabout = 15;
    {::_pbi::TcParser::FastV8S1,
     {120, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.roundabout_)}},
    // bool internal_intersection = 16;
    {::_pbi::TcParser::FastV8S2,
     {384, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.internal_intersection_)}},
    // bool drive_on_left = 17;
    {::_pbi::TcParser::FastV8S2,
     {392, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.drive_on_left_)}},
    // .valhalla.TripLeg.Surface surface = 18;
    {::_pbi::TcParser::FastV32S2,
     {400, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.surface_)}},
    // .valhalla.TripSign sign = 19;
    {::_pbi::TcParser::FastMtS2,
     {410, 0, 1, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.sign_)}},
    // .valhalla.TravelMode travel_mode = 20;
    {::_pbi::TcParser::FastV32S2,
     {416, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.travel_mode_)}},
    // .valhalla.VehicleType vehicle_type = 21;
    {::_pbi::TcParser::FastV32S2,
     {424, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.vehicle_type_)}},
    // .valhalla.PedestrianType pedestrian_type = 22;
    {::_pbi::TcParser::FastV32S2,
     {432, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.pedestrian_type_)}},
    // .valhalla.BicycleType bicycle_type = 23;
    {::_pbi::TcParser::FastV32S2,
     {440, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.bicycle_type_)}},
    // .valhalla.TransitType transit_type = 24;
    {::_pbi::TcParser::FastV32S2,
     {448, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.transit_type_)}},
    // .valhalla.TransitRouteInfo transit_route_info = 25;
    {::_pbi::TcParser::FastMtS2,
     {458, 1, 2, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.transit_route_info_)}},
    // uint64 id = 26;
    {::_pbi::TcParser::FastV64S2,
     {464, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.id_)}},
    // uint64 way_id = 27;
    {::_pbi::TcParser::FastV64S2,
     {472, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.way_id_)}},
    // float weighted_grade = 28;
    {::_pbi::TcParser::FastF32S2,
     {485, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.weighted_grade_)}},
    // int32 max_upward_grade = 29;
    {::_pbi::TcParser::FastV32S2,
     {488, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.max_upward_grade_)}},
    // int32 max_downward_grade = 30;
    {::_pbi::TcParser::FastV32S2,
     {496, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.max_downward_grade_)}},
    // uint32 lane_count = 31;
    {::_pbi::TcParser::FastV32S2,
     {504, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.lane_count_)}},
  }}, {{
    33, 0, 2,
    0, 32, 65504, 48,
    65535, 65535
  }}, {{
    // repeated .valhalla.StreetName name = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.name_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // float length_km = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.length_km_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float speed = 3;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.speed_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // .valhalla.RoadClass road_class = 4;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.road_class_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // uint32 begin_heading = 5;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.begin_heading_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 end_heading = 6;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.end_heading_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 begin_shape_index = 7;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.begin_shape_index_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 end_shape_index = 8;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.end_shape_index_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // .valhalla.TripLeg.Traversability traversability = 9;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.traversability_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.TripLeg.Use use = 10;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.use_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // bool toll = 11;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.toll_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool unpaved = 12;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.unpaved_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool tunnel = 13;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.tunnel_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool bridge = 14;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.bridge_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool roundabout = 15;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.roundabout_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool internal_intersection = 16;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.internal_intersection_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool drive_on_left = 17;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.drive_on_left_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // .valhalla.TripLeg.Surface surface = 18;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.surface_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.TripSign sign = 19;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.sign_), _Internal::kHasBitsOffset + 0, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.TravelMode travel_mode = 20;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.travel_mode_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.VehicleType vehicle_type = 21;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.vehicle_type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.PedestrianType pedestrian_type = 22;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.pedestrian_type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.BicycleType bicycle_type = 23;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.bicycle_type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.TransitType transit_type = 24;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.transit_type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.TransitRouteInfo transit_route_info = 25;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.transit_route_info_), _Internal::kHasBitsOffset + 1, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // uint64 id = 26;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // uint64 way_id = 27;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.way_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // float weighted_grade = 28;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.weighted_grade_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // int32 max_upward_grade = 29;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.max_upward_grade_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 max_downward_grade = 30;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.max_downward_grade_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // uint32 lane_count = 31;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.lane_count_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // .valhalla.TripLeg.CycleLane cycle_lane = 32;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.cycle_lane_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // bool bicycle_network = 33;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.bicycle_network_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // .valhalla.TripLeg.Sidewalk sidewalk = 34;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.sidewalk_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // uint32 density = 35;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.density_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 speed_limit = 36;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.speed_limit_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // float truck_speed = 37;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.truck_speed_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // bool truck_route = 38;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.truck_route_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.lane_connectivity_), -1, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // int32 mean_elevation = 40;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.mean_elevation_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.traffic_segment_), -1, 4,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.TurnLane turn_lanes = 42;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.turn_lanes_), -1, 5,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool has_time_restrictions = 43;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.has_time_restrictions_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // float default_speed = 44;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.default_speed_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // .valhalla.TripLeg.Restriction restriction = 45;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.restriction_), _Internal::kHasBitsOffset + 2, 6,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool destination_only = 46;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.destination_only_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool is_urban = 47;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.is_urban_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // repeated .valhalla.TaggedValue tagged_value = 48;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.tagged_value_), -1, 7,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // float source_along_edge = 49;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.source_along_edge_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float target_along_edge = 50;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.target_along_edge_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // .valhalla.TripLeg.SacScale sac_scale = 51;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.sac_scale_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // bool shoulder = 52;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.shoulder_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool indoor = 53;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.indoor_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::StreetName>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripSign>()},
    {::_pbi::TcParser::GetTable<::valhalla::TransitRouteInfo>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_LaneConnectivity>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_TrafficSegment>()},
    {::_pbi::TcParser::GetTable<::valhalla::TurnLane>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_Restriction>()},
    {::_pbi::TcParser::GetTable<::valhalla::TaggedValue>()},
  }}, {{
  }},
};

::uint8_t* TripLeg_Edge::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Edge)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .valhalla.StreetName name = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_name_size()); i < n; i++) {
    const auto& repfield = this->_internal_name().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // float length_km = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_length_km = this->_internal_length_km();
  ::uint32_t raw_length_km;
  memcpy(&raw_length_km, &tmp_length_km, sizeof(tmp_length_km));
  if (raw_length_km != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_length_km(), target);
  }

  // float speed = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_speed = this->_internal_speed();
  ::uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_speed(), target);
  }

  // .valhalla.RoadClass road_class = 4;
  if (this->_internal_road_class() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_road_class(), target);
  }

  // uint32 begin_heading = 5;
  if (this->_internal_begin_heading() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_begin_heading(), target);
  }

  // uint32 end_heading = 6;
  if (this->_internal_end_heading() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_end_heading(), target);
  }

  // uint32 begin_shape_index = 7;
  if (this->_internal_begin_shape_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_begin_shape_index(), target);
  }

  // uint32 end_shape_index = 8;
  if (this->_internal_end_shape_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        8, this->_internal_end_shape_index(), target);
  }

  // .valhalla.TripLeg.Traversability traversability = 9;
  if (this->_internal_traversability() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        9, this->_internal_traversability(), target);
  }

  // .valhalla.TripLeg.Use use = 10;
  if (this->_internal_use() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        10, this->_internal_use(), target);
  }

  // bool toll = 11;
  if (this->_internal_toll() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        11, this->_internal_toll(), target);
  }

  // bool unpaved = 12;
  if (this->_internal_unpaved() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        12, this->_internal_unpaved(), target);
  }

  // bool tunnel = 13;
  if (this->_internal_tunnel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        13, this->_internal_tunnel(), target);
  }

  // bool bridge = 14;
  if (this->_internal_bridge() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        14, this->_internal_bridge(), target);
  }

  // bool roundabout = 15;
  if (this->_internal_roundabout() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        15, this->_internal_roundabout(), target);
  }

  // bool internal_intersection = 16;
  if (this->_internal_internal_intersection() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        16, this->_internal_internal_intersection(), target);
  }

  // bool drive_on_left = 17;
  if (this->_internal_drive_on_left() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        17, this->_internal_drive_on_left(), target);
  }

  // .valhalla.TripLeg.Surface surface = 18;
  if (this->_internal_surface() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        18, this->_internal_surface(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .valhalla.TripSign sign = 19;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::sign(this),
        _Internal::sign(this).GetCachedSize(), target, stream);
  }

  // .valhalla.TravelMode travel_mode = 20;
  if (this->_internal_travel_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        20, this->_internal_travel_mode(), target);
  }

  // .valhalla.VehicleType vehicle_type = 21;
  if (this->_internal_vehicle_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        21, this->_internal_vehicle_type(), target);
  }

  // .valhalla.PedestrianType pedestrian_type = 22;
  if (this->_internal_pedestrian_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        22, this->_internal_pedestrian_type(), target);
  }

  // .valhalla.BicycleType bicycle_type = 23;
  if (this->_internal_bicycle_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        23, this->_internal_bicycle_type(), target);
  }

  // .valhalla.TransitType transit_type = 24;
  if (this->_internal_transit_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        24, this->_internal_transit_type(), target);
  }

  // .valhalla.TransitRouteInfo transit_route_info = 25;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::transit_route_info(this),
        _Internal::transit_route_info(this).GetCachedSize(), target, stream);
  }

  // uint64 id = 26;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        26, this->_internal_id(), target);
  }

  // uint64 way_id = 27;
  if (this->_internal_way_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        27, this->_internal_way_id(), target);
  }

  // float weighted_grade = 28;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_weighted_grade = this->_internal_weighted_grade();
  ::uint32_t raw_weighted_grade;
  memcpy(&raw_weighted_grade, &tmp_weighted_grade, sizeof(tmp_weighted_grade));
  if (raw_weighted_grade != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        28, this->_internal_weighted_grade(), target);
  }

  // int32 max_upward_grade = 29;
  if (this->_internal_max_upward_grade() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        29, this->_internal_max_upward_grade(), target);
  }

  // int32 max_downward_grade = 30;
  if (this->_internal_max_downward_grade() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        30, this->_internal_max_downward_grade(), target);
  }

  // uint32 lane_count = 31;
  if (this->_internal_lane_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        31, this->_internal_lane_count(), target);
  }

  // .valhalla.TripLeg.CycleLane cycle_lane = 32;
  if (this->_internal_cycle_lane() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        32, this->_internal_cycle_lane(), target);
  }

  // bool bicycle_network = 33;
  if (this->_internal_bicycle_network() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        33, this->_internal_bicycle_network(), target);
  }

  // .valhalla.TripLeg.Sidewalk sidewalk = 34;
  if (this->_internal_sidewalk() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        34, this->_internal_sidewalk(), target);
  }

  // uint32 density = 35;
  if (this->_internal_density() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        35, this->_internal_density(), target);
  }

  // uint32 speed_limit = 36;
  if (this->_internal_speed_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        36, this->_internal_speed_limit(), target);
  }

  // float truck_speed = 37;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_truck_speed = this->_internal_truck_speed();
  ::uint32_t raw_truck_speed;
  memcpy(&raw_truck_speed, &tmp_truck_speed, sizeof(tmp_truck_speed));
  if (raw_truck_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        37, this->_internal_truck_speed(), target);
  }

  // bool truck_route = 38;
  if (this->_internal_truck_route() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        38, this->_internal_truck_route(), target);
  }

  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_lane_connectivity_size()); i < n; i++) {
    const auto& repfield = this->_internal_lane_connectivity().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(39, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 mean_elevation = 40;
  if (this->_internal_mean_elevation() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        40, this->_internal_mean_elevation(), target);
  }

  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_traffic_segment_size()); i < n; i++) {
    const auto& repfield = this->_internal_traffic_segment().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(41, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .valhalla.TurnLane turn_lanes = 42;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_turn_lanes_size()); i < n; i++) {
    const auto& repfield = this->_internal_turn_lanes().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(42, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool has_time_restrictions = 43;
  if (this->_internal_has_time_restrictions() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        43, this->_internal_has_time_restrictions(), target);
  }

  // float default_speed = 44;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_default_speed = this->_internal_default_speed();
  ::uint32_t raw_default_speed;
  memcpy(&raw_default_speed, &tmp_default_speed, sizeof(tmp_default_speed));
  if (raw_default_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        44, this->_internal_default_speed(), target);
  }

  // .valhalla.TripLeg.Restriction restriction = 45;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(45, _Internal::restriction(this),
        _Internal::restriction(this).GetCachedSize(), target, stream);
  }

  // bool destination_only = 46;
  if (this->_internal_destination_only() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        46, this->_internal_destination_only(), target);
  }

  // bool is_urban = 47;
  if (this->_internal_is_urban() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        47, this->_internal_is_urban(), target);
  }

  // repeated .valhalla.TaggedValue tagged_value = 48;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tagged_value_size()); i < n; i++) {
    const auto& repfield = this->_internal_tagged_value().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(48, repfield, repfield.GetCachedSize(), target, stream);
  }

  // float source_along_edge = 49;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_source_along_edge = this->_internal_source_along_edge();
  ::uint32_t raw_source_along_edge;
  memcpy(&raw_source_along_edge, &tmp_source_along_edge, sizeof(tmp_source_along_edge));
  if (raw_source_along_edge != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        49, this->_internal_source_along_edge(), target);
  }

  // float target_along_edge = 50;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_target_along_edge = this->_internal_target_along_edge();
  ::uint32_t raw_target_along_edge;
  memcpy(&raw_target_along_edge, &tmp_target_along_edge, sizeof(tmp_target_along_edge));
  if (raw_target_along_edge != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        50, this->_internal_target_along_edge(), target);
  }

  // .valhalla.TripLeg.SacScale sac_scale = 51;
  if (this->_internal_sac_scale() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        51, this->_internal_sac_scale(), target);
  }

  // bool shoulder = 52;
  if (this->_internal_shoulder() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        52, this->_internal_shoulder(), target);
  }

  // bool indoor = 53;
  if (this->_internal_indoor() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        53, this->_internal_indoor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Edge)
  return target;
}

::size_t TripLeg_Edge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Edge)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.StreetName name = 1;
  total_size += 1UL * this->_internal_name_size();
  for (const auto& msg : this->_internal_name()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  total_size += 2UL * this->_internal_lane_connectivity_size();
  for (const auto& msg : this->_internal_lane_connectivity()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  total_size += 2UL * this->_internal_traffic_segment_size();
  for (const auto& msg : this->_internal_traffic_segment()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .valhalla.TurnLane turn_lanes = 42;
  total_size += 2UL * this->_internal_turn_lanes_size();
  for (const auto& msg : this->_internal_turn_lanes()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .valhalla.TaggedValue tagged_value = 48;
  total_size += 2UL * this->_internal_tagged_value_size();
  for (const auto& msg : this->_internal_tagged_value()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .valhalla.TripSign sign = 19;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.sign_);
    }

    // .valhalla.TransitRouteInfo transit_route_info = 25;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.transit_route_info_);
    }

    // .valhalla.TripLeg.Restriction restriction = 45;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.restriction_);
    }

  }
  // float length_km = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_length_km = this->_internal_length_km();
  ::uint32_t raw_length_km;
  memcpy(&raw_length_km, &tmp_length_km, sizeof(tmp_length_km));
  if (raw_length_km != 0) {
    total_size += 5;
  }

  // float speed = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_speed = this->_internal_speed();
  ::uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    total_size += 5;
  }

  // .valhalla.RoadClass road_class = 4;
  if (this->_internal_road_class() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_road_class());
  }

  // uint32 begin_heading = 5;
  if (this->_internal_begin_heading() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_begin_heading());
  }

  // uint32 end_heading = 6;
  if (this->_internal_end_heading() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_end_heading());
  }

  // uint32 begin_shape_index = 7;
  if (this->_internal_begin_shape_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_begin_shape_index());
  }

  // uint32 end_shape_index = 8;
  if (this->_internal_end_shape_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_end_shape_index());
  }

  // .valhalla.TripLeg.Traversability traversability = 9;
  if (this->_internal_traversability() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_traversability());
  }

  // .valhalla.TripLeg.Use use = 10;
  if (this->_internal_use() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_use());
  }

  // bool toll = 11;
  if (this->_internal_toll() != 0) {
    total_size += 2;
  }

  // bool unpaved = 12;
  if (this->_internal_unpaved() != 0) {
    total_size += 2;
  }

  // bool tunnel = 13;
  if (this->_internal_tunnel() != 0) {
    total_size += 2;
  }

  // bool bridge = 14;
  if (this->_internal_bridge() != 0) {
    total_size += 2;
  }

  // .valhalla.TripLeg.Surface surface = 18;
  if (this->_internal_surface() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_surface());
  }

  // .valhalla.TravelMode travel_mode = 20;
  if (this->_internal_travel_mode() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_travel_mode());
  }

  // bool roundabout = 15;
  if (this->_internal_roundabout() != 0) {
    total_size += 2;
  }

  // bool internal_intersection = 16;
  if (this->_internal_internal_intersection() != 0) {
    total_size += 3;
  }

  // bool drive_on_left = 17;
  if (this->_internal_drive_on_left() != 0) {
    total_size += 3;
  }

  // bool bicycle_network = 33;
  if (this->_internal_bicycle_network() != 0) {
    total_size += 3;
  }

  // .valhalla.VehicleType vehicle_type = 21;
  if (this->_internal_vehicle_type() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_vehicle_type());
  }

  // .valhalla.PedestrianType pedestrian_type = 22;
  if (this->_internal_pedestrian_type() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_pedestrian_type());
  }

  // .valhalla.BicycleType bicycle_type = 23;
  if (this->_internal_bicycle_type() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_bicycle_type());
  }

  // uint64 id = 26;
  if (this->_internal_id() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                    this->_internal_id());
  }

  // .valhalla.TransitType transit_type = 24;
  if (this->_internal_transit_type() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_transit_type());
  }

  // float weighted_grade = 28;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_weighted_grade = this->_internal_weighted_grade();
  ::uint32_t raw_weighted_grade;
  memcpy(&raw_weighted_grade, &tmp_weighted_grade, sizeof(tmp_weighted_grade));
  if (raw_weighted_grade != 0) {
    total_size += 6;
  }

  // uint64 way_id = 27;
  if (this->_internal_way_id() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                    this->_internal_way_id());
  }

  // int32 max_upward_grade = 29;
  if (this->_internal_max_upward_grade() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_max_upward_grade());
  }

  // int32 max_downward_grade = 30;
  if (this->_internal_max_downward_grade() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_max_downward_grade());
  }

  // uint32 lane_count = 31;
  if (this->_internal_lane_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                    this->_internal_lane_count());
  }

  // .valhalla.TripLeg.CycleLane cycle_lane = 32;
  if (this->_internal_cycle_lane() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_cycle_lane());
  }

  // .valhalla.TripLeg.Sidewalk sidewalk = 34;
  if (this->_internal_sidewalk() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_sidewalk());
  }

  // uint32 density = 35;
  if (this->_internal_density() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                    this->_internal_density());
  }

  // uint32 speed_limit = 36;
  if (this->_internal_speed_limit() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                    this->_internal_speed_limit());
  }

  // float truck_speed = 37;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_truck_speed = this->_internal_truck_speed();
  ::uint32_t raw_truck_speed;
  memcpy(&raw_truck_speed, &tmp_truck_speed, sizeof(tmp_truck_speed));
  if (raw_truck_speed != 0) {
    total_size += 6;
  }

  // int32 mean_elevation = 40;
  if (this->_internal_mean_elevation() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_mean_elevation());
  }

  // bool truck_route = 38;
  if (this->_internal_truck_route() != 0) {
    total_size += 3;
  }

  // bool has_time_restrictions = 43;
  if (this->_internal_has_time_restrictions() != 0) {
    total_size += 3;
  }

  // bool destination_only = 46;
  if (this->_internal_destination_only() != 0) {
    total_size += 3;
  }

  // bool is_urban = 47;
  if (this->_internal_is_urban() != 0) {
    total_size += 3;
  }

  // float default_speed = 44;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_default_speed = this->_internal_default_speed();
  ::uint32_t raw_default_speed;
  memcpy(&raw_default_speed, &tmp_default_speed, sizeof(tmp_default_speed));
  if (raw_default_speed != 0) {
    total_size += 6;
  }

  // float source_along_edge = 49;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_source_along_edge = this->_internal_source_along_edge();
  ::uint32_t raw_source_along_edge;
  memcpy(&raw_source_along_edge, &tmp_source_along_edge, sizeof(tmp_source_along_edge));
  if (raw_source_along_edge != 0) {
    total_size += 6;
  }

  // float target_along_edge = 50;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_target_along_edge = this->_internal_target_along_edge();
  ::uint32_t raw_target_along_edge;
  memcpy(&raw_target_along_edge, &tmp_target_along_edge, sizeof(tmp_target_along_edge));
  if (raw_target_along_edge != 0) {
    total_size += 6;
  }

  // .valhalla.TripLeg.SacScale sac_scale = 51;
  if (this->_internal_sac_scale() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_sac_scale());
  }

  // bool shoulder = 52;
  if (this->_internal_shoulder() != 0) {
    total_size += 3;
  }

  // bool indoor = 53;
  if (this->_internal_indoor() != 0) {
    total_size += 3;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Edge::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Edge*>(
      &from));
}

void TripLeg_Edge::MergeFrom(const TripLeg_Edge& from) {
  TripLeg_Edge* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Edge)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_name()->MergeFrom(from._internal_name());
  _this->_internal_mutable_lane_connectivity()->MergeFrom(from._internal_lane_connectivity());
  _this->_internal_mutable_traffic_segment()->MergeFrom(from._internal_traffic_segment());
  _this->_internal_mutable_turn_lanes()->MergeFrom(from._internal_turn_lanes());
  _this->_internal_mutable_tagged_value()->MergeFrom(from._internal_tagged_value());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_sign()->::valhalla::TripSign::MergeFrom(
          from._internal_sign());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_transit_route_info()->::valhalla::TransitRouteInfo::MergeFrom(
          from._internal_transit_route_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_restriction()->::valhalla::TripLeg_Restriction::MergeFrom(
          from._internal_restriction());
    }
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_length_km = from._internal_length_km();
  ::uint32_t raw_length_km;
  memcpy(&raw_length_km, &tmp_length_km, sizeof(tmp_length_km));
  if (raw_length_km != 0) {
    _this->_internal_set_length_km(from._internal_length_km());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_speed = from._internal_speed();
  ::uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    _this->_internal_set_speed(from._internal_speed());
  }
  if (from._internal_road_class() != 0) {
    _this->_internal_set_road_class(from._internal_road_class());
  }
  if (from._internal_begin_heading() != 0) {
    _this->_internal_set_begin_heading(from._internal_begin_heading());
  }
  if (from._internal_end_heading() != 0) {
    _this->_internal_set_end_heading(from._internal_end_heading());
  }
  if (from._internal_begin_shape_index() != 0) {
    _this->_internal_set_begin_shape_index(from._internal_begin_shape_index());
  }
  if (from._internal_end_shape_index() != 0) {
    _this->_internal_set_end_shape_index(from._internal_end_shape_index());
  }
  if (from._internal_traversability() != 0) {
    _this->_internal_set_traversability(from._internal_traversability());
  }
  if (from._internal_use() != 0) {
    _this->_internal_set_use(from._internal_use());
  }
  if (from._internal_toll() != 0) {
    _this->_internal_set_toll(from._internal_toll());
  }
  if (from._internal_unpaved() != 0) {
    _this->_internal_set_unpaved(from._internal_unpaved());
  }
  if (from._internal_tunnel() != 0) {
    _this->_internal_set_tunnel(from._internal_tunnel());
  }
  if (from._internal_bridge() != 0) {
    _this->_internal_set_bridge(from._internal_bridge());
  }
  if (from._internal_surface() != 0) {
    _this->_internal_set_surface(from._internal_surface());
  }
  if (from._internal_travel_mode() != 0) {
    _this->_internal_set_travel_mode(from._internal_travel_mode());
  }
  if (from._internal_roundabout() != 0) {
    _this->_internal_set_roundabout(from._internal_roundabout());
  }
  if (from._internal_internal_intersection() != 0) {
    _this->_internal_set_internal_intersection(from._internal_internal_intersection());
  }
  if (from._internal_drive_on_left() != 0) {
    _this->_internal_set_drive_on_left(from._internal_drive_on_left());
  }
  if (from._internal_bicycle_network() != 0) {
    _this->_internal_set_bicycle_network(from._internal_bicycle_network());
  }
  if (from._internal_vehicle_type() != 0) {
    _this->_internal_set_vehicle_type(from._internal_vehicle_type());
  }
  if (from._internal_pedestrian_type() != 0) {
    _this->_internal_set_pedestrian_type(from._internal_pedestrian_type());
  }
  if (from._internal_bicycle_type() != 0) {
    _this->_internal_set_bicycle_type(from._internal_bicycle_type());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_transit_type() != 0) {
    _this->_internal_set_transit_type(from._internal_transit_type());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_weighted_grade = from._internal_weighted_grade();
  ::uint32_t raw_weighted_grade;
  memcpy(&raw_weighted_grade, &tmp_weighted_grade, sizeof(tmp_weighted_grade));
  if (raw_weighted_grade != 0) {
    _this->_internal_set_weighted_grade(from._internal_weighted_grade());
  }
  if (from._internal_way_id() != 0) {
    _this->_internal_set_way_id(from._internal_way_id());
  }
  if (from._internal_max_upward_grade() != 0) {
    _this->_internal_set_max_upward_grade(from._internal_max_upward_grade());
  }
  if (from._internal_max_downward_grade() != 0) {
    _this->_internal_set_max_downward_grade(from._internal_max_downward_grade());
  }
  if (from._internal_lane_count() != 0) {
    _this->_internal_set_lane_count(from._internal_lane_count());
  }
  if (from._internal_cycle_lane() != 0) {
    _this->_internal_set_cycle_lane(from._internal_cycle_lane());
  }
  if (from._internal_sidewalk() != 0) {
    _this->_internal_set_sidewalk(from._internal_sidewalk());
  }
  if (from._internal_density() != 0) {
    _this->_internal_set_density(from._internal_density());
  }
  if (from._internal_speed_limit() != 0) {
    _this->_internal_set_speed_limit(from._internal_speed_limit());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_truck_speed = from._internal_truck_speed();
  ::uint32_t raw_truck_speed;
  memcpy(&raw_truck_speed, &tmp_truck_speed, sizeof(tmp_truck_speed));
  if (raw_truck_speed != 0) {
    _this->_internal_set_truck_speed(from._internal_truck_speed());
  }
  if (from._internal_mean_elevation() != 0) {
    _this->_internal_set_mean_elevation(from._internal_mean_elevation());
  }
  if (from._internal_truck_route() != 0) {
    _this->_internal_set_truck_route(from._internal_truck_route());
  }
  if (from._internal_has_time_restrictions() != 0) {
    _this->_internal_set_has_time_restrictions(from._internal_has_time_restrictions());
  }
  if (from._internal_destination_only() != 0) {
    _this->_internal_set_destination_only(from._internal_destination_only());
  }
  if (from._internal_is_urban() != 0) {
    _this->_internal_set_is_urban(from._internal_is_urban());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_default_speed = from._internal_default_speed();
  ::uint32_t raw_default_speed;
  memcpy(&raw_default_speed, &tmp_default_speed, sizeof(tmp_default_speed));
  if (raw_default_speed != 0) {
    _this->_internal_set_default_speed(from._internal_default_speed());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_source_along_edge = from._internal_source_along_edge();
  ::uint32_t raw_source_along_edge;
  memcpy(&raw_source_along_edge, &tmp_source_along_edge, sizeof(tmp_source_along_edge));
  if (raw_source_along_edge != 0) {
    _this->_internal_set_source_along_edge(from._internal_source_along_edge());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_target_along_edge = from._internal_target_along_edge();
  ::uint32_t raw_target_along_edge;
  memcpy(&raw_target_along_edge, &tmp_target_along_edge, sizeof(tmp_target_along_edge));
  if (raw_target_along_edge != 0) {
    _this->_internal_set_target_along_edge(from._internal_target_along_edge());
  }
  if (from._internal_sac_scale() != 0) {
    _this->_internal_set_sac_scale(from._internal_sac_scale());
  }
  if (from._internal_shoulder() != 0) {
    _this->_internal_set_shoulder(from._internal_shoulder());
  }
  if (from._internal_indoor() != 0) {
    _this->_internal_set_indoor(from._internal_indoor());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Edge::CopyFrom(const TripLeg_Edge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Edge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TripLeg_Edge::IsInitialized() const {
  return true;
}

void TripLeg_Edge::InternalSwap(TripLeg_Edge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.name_.InternalSwap(&other->_impl_.name_);
  _impl_.lane_connectivity_.InternalSwap(&other->_impl_.lane_connectivity_);
  _impl_.traffic_segment_.InternalSwap(&other->_impl_.traffic_segment_);
  _impl_.turn_lanes_.InternalSwap(&other->_impl_.turn_lanes_);
  _impl_.tagged_value_.InternalSwap(&other->_impl_.tagged_value_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.indoor_)
      + sizeof(TripLeg_Edge::_impl_.indoor_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.sign_)>(
          reinterpret_cast<char*>(&_impl_.sign_),
          reinterpret_cast<char*>(&other->_impl_.sign_));
}

std::string TripLeg_Edge::GetTypeName() const {
  return "valhalla.TripLeg.Edge";
}

// ===================================================================

class TripLeg_IntersectingEdge::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_IntersectingEdge>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_._has_bits_);
  static const ::valhalla::TripSign& sign(const TripLeg_IntersectingEdge* msg);
  static void set_has_sign(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::valhalla::TripSign& TripLeg_IntersectingEdge::_Internal::sign(const TripLeg_IntersectingEdge* msg) {
  return *msg->_impl_.sign_;
}
void TripLeg_IntersectingEdge::clear_sign() {
  if (_impl_.sign_ != nullptr) _impl_.sign_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.IntersectingEdge)
}
TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(const TripLeg_IntersectingEdge& from) : ::google::protobuf::MessageLite() {
  TripLeg_IntersectingEdge* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.sign_){nullptr},
      decltype(_impl_.begin_heading_){},
      decltype(_impl_.prev_name_consistency_){},
      decltype(_impl_.curr_name_consistency_){},
      decltype(_impl_.driveability_){},
      decltype(_impl_.cyclability_){},
      decltype(_impl_.walkability_){},
      decltype(_impl_.use_){},
      decltype(_impl_.road_class_){},
      decltype(_impl_.lane_count_){},
  };
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.sign_ = new ::valhalla::TripSign(*from._impl_.sign_);
  }
  ::memcpy(&_impl_.begin_heading_, &from._impl_.begin_heading_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.lane_count_) -
    reinterpret_cast<char*>(&_impl_.begin_heading_)) + sizeof(_impl_.lane_count_));

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.IntersectingEdge)
}
inline void TripLeg_IntersectingEdge::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.sign_){nullptr},
      decltype(_impl_.begin_heading_){0u},
      decltype(_impl_.prev_name_consistency_){false},
      decltype(_impl_.curr_name_consistency_){false},
      decltype(_impl_.driveability_){0},
      decltype(_impl_.cyclability_){0},
      decltype(_impl_.walkability_){0},
      decltype(_impl_.use_){0},
      decltype(_impl_.road_class_){0},
      decltype(_impl_.lane_count_){0u},
  };
}
TripLeg_IntersectingEdge::~TripLeg_IntersectingEdge() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.IntersectingEdge)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void TripLeg_IntersectingEdge::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.sign_;
}
void TripLeg_IntersectingEdge::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void TripLeg_IntersectingEdge::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.IntersectingEdge)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.sign_ != nullptr);
    _impl_.sign_->Clear();
  }
  ::memset(&_impl_.begin_heading_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.lane_count_) -
      reinterpret_cast<char*>(&_impl_.begin_heading_)) + sizeof(_impl_.lane_count_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_IntersectingEdge::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 10, 1, 0, 2> TripLeg_IntersectingEdge::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_._has_bits_),
    0, // no _extensions_
    10, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966272,  // skipmap
    offsetof(decltype(_table_), field_entries),
    10,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_TripLeg_IntersectingEdge_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // uint32 begin_heading = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.begin_heading_)}},
    // bool prev_name_consistency = 2;
    {::_pbi::TcParser::FastV8S1,
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.prev_name_consistency_)}},
    // bool curr_name_consistency = 3;
    {::_pbi::TcParser::FastV8S1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.curr_name_consistency_)}},
    // .valhalla.TripLeg.Traversability driveability = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.driveability_)}},
    // .valhalla.TripLeg.Traversability cyclability = 5;
    {::_pbi::TcParser::FastV32S1,
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.cyclability_)}},
    // .valhalla.TripLeg.Traversability walkability = 6;
    {::_pbi::TcParser::FastV32S1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.walkability_)}},
    // .valhalla.TripLeg.Use use = 7;
    {::_pbi::TcParser::FastV32S1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.use_)}},
    // .valhalla.RoadClass road_class = 8;
    {::_pbi::TcParser::FastV32S1,
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.road_class_)}},
    // uint32 lane_count = 9;
    {::_pbi::TcParser::FastV32S1,
     {72, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.lane_count_)}},
    // .valhalla.TripSign sign = 10;
    {::_pbi::TcParser::FastMtS1,
     {82, 0, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.sign_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 begin_heading = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.begin_heading_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // bool prev_name_consistency = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.prev_name_consistency_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool curr_name_consistency = 3;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.curr_name_consistency_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // .valhalla.TripLeg.Traversability driveability = 4;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.driveability_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.TripLeg.Traversability cyclability = 5;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.cyclability_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.TripLeg.Traversability walkability = 6;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.walkability_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.TripLeg.Use use = 7;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.use_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.RoadClass road_class = 8;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.road_class_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // uint32 lane_count = 9;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.lane_count_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // .valhalla.TripSign sign = 10;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.sign_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::TripSign>()},
  }}, {{
  }},
};

::uint8_t* TripLeg_IntersectingEdge::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.IntersectingEdge)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint32 begin_heading = 1;
  if (this->_internal_begin_heading() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_begin_heading(), target);
  }

  // bool prev_name_consistency = 2;
  if (this->_internal_prev_name_consistency() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_prev_name_consistency(), target);
  }

  // bool curr_name_consistency = 3;
  if (this->_internal_curr_name_consistency() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_curr_name_consistency(), target);
  }

  // .valhalla.TripLeg.Traversability driveability = 4;
  if (this->_internal_driveability() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_driveability(), target);
  }

  // .valhalla.TripLeg.Traversability cyclability = 5;
  if (this->_internal_cyclability() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_cyclability(), target);
  }

  // .valhalla.TripLeg.Traversability walkability = 6;
  if (this->_internal_walkability() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        6, this->_internal_walkability(), target);
  }

  // .valhalla.TripLeg.Use use = 7;
  if (this->_internal_use() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        7, this->_internal_use(), target);
  }

  // .valhalla.RoadClass road_class = 8;
  if (this->_internal_road_class() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        8, this->_internal_road_class(), target);
  }

  // uint32 lane_count = 9;
  if (this->_internal_lane_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        9, this->_internal_lane_count(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .valhalla.TripSign sign = 10;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::sign(this),
        _Internal::sign(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.IntersectingEdge)
  return target;
}

::size_t TripLeg_IntersectingEdge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.IntersectingEdge)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .valhalla.TripSign sign = 10;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *_impl_.sign_);
  }

  // uint32 begin_heading = 1;
  if (this->_internal_begin_heading() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_begin_heading());
  }

  // bool prev_name_consistency = 2;
  if (this->_internal_prev_name_consistency() != 0) {
    total_size += 2;
  }

  // bool curr_name_consistency = 3;
  if (this->_internal_curr_name_consistency() != 0) {
    total_size += 2;
  }

  // .valhalla.TripLeg.Traversability driveability = 4;
  if (this->_internal_driveability() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_driveability());
  }

  // .valhalla.TripLeg.Traversability cyclability = 5;
  if (this->_internal_cyclability() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_cyclability());
  }

  // .valhalla.TripLeg.Traversability walkability = 6;
  if (this->_internal_walkability() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_walkability());
  }

  // .valhalla.TripLeg.Use use = 7;
  if (this->_internal_use() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_use());
  }

  // .valhalla.RoadClass road_class = 8;
  if (this->_internal_road_class() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_road_class());
  }

  // uint32 lane_count = 9;
  if (this->_internal_lane_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_lane_count());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_IntersectingEdge::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_IntersectingEdge*>(
      &from));
}

void TripLeg_IntersectingEdge::MergeFrom(const TripLeg_IntersectingEdge& from) {
  TripLeg_IntersectingEdge* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.IntersectingEdge)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_sign()->::valhalla::TripSign::MergeFrom(
        from._internal_sign());
  }
  if (from._internal_begin_heading() != 0) {
    _this->_internal_set_begin_heading(from._internal_begin_heading());
  }
  if (from._internal_prev_name_consistency() != 0) {
    _this->_internal_set_prev_name_consistency(from._internal_prev_name_consistency());
  }
  if (from._internal_curr_name_consistency() != 0) {
    _this->_internal_set_curr_name_consistency(from._internal_curr_name_consistency());
  }
  if (from._internal_driveability() != 0) {
    _this->_internal_set_driveability(from._internal_driveability());
  }
  if (from._internal_cyclability() != 0) {
    _this->_internal_set_cyclability(from._internal_cyclability());
  }
  if (from._internal_walkability() != 0) {
    _this->_internal_set_walkability(from._internal_walkability());
  }
  if (from._internal_use() != 0) {
    _this->_internal_set_use(from._internal_use());
  }
  if (from._internal_road_class() != 0) {
    _this->_internal_set_road_class(from._internal_road_class());
  }
  if (from._internal_lane_count() != 0) {
    _this->_internal_set_lane_count(from._internal_lane_count());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_IntersectingEdge::CopyFrom(const TripLeg_IntersectingEdge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.IntersectingEdge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TripLeg_IntersectingEdge::IsInitialized() const {
  return true;
}

void TripLeg_IntersectingEdge::InternalSwap(TripLeg_IntersectingEdge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.lane_count_)
      + sizeof(TripLeg_IntersectingEdge::_impl_.lane_count_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.sign_)>(
          reinterpret_cast<char*>(&_impl_.sign_),
          reinterpret_cast<char*>(&other->_impl_.sign_));
}

std::string TripLeg_IntersectingEdge::GetTypeName() const {
  return "valhalla.TripLeg.IntersectingEdge";
}

// ===================================================================

class TripLeg_Cost::_Internal {
 public:
};

TripLeg_Cost::TripLeg_Cost(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Cost)
}
TripLeg_Cost::TripLeg_Cost(const TripLeg_Cost& from)
    : ::google::protobuf::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Cost)
}
inline void TripLeg_Cost::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.seconds_){0},
      decltype(_impl_.cost_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
TripLeg_Cost::~TripLeg_Cost() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Cost)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void TripLeg_Cost::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void TripLeg_Cost::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void TripLeg_Cost::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Cost)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.seconds_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.cost_) -
      reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.cost_));
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Cost::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> TripLeg_Cost::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_TripLeg_Cost_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // double cost = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Cost, _impl_.cost_)}},
    // double seconds = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Cost, _impl_.seconds_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double seconds = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Cost, _impl_.seconds_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double cost = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Cost, _impl_.cost_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* TripLeg_Cost::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Cost)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double seconds = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_seconds = this->_internal_seconds();
  ::uint64_t raw_seconds;
  memcpy(&raw_seconds, &tmp_seconds, sizeof(tmp_seconds));
  if (raw_seconds != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_seconds(), target);
  }

  // double cost = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_cost = this->_internal_cost();
  ::uint64_t raw_cost;
  memcpy(&raw_cost, &tmp_cost, sizeof(tmp_cost));
  if (raw_cost != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_cost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Cost)
  return target;
}

::size_t TripLeg_Cost::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Cost)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double seconds = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_seconds = this->_internal_seconds();
  ::uint64_t raw_seconds;
  memcpy(&raw_seconds, &tmp_seconds, sizeof(tmp_seconds));
  if (raw_seconds != 0) {
    total_size += 9;
  }

  // double cost = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_cost = this->_internal_cost();
  ::uint64_t raw_cost;
  memcpy(&raw_cost, &tmp_cost, sizeof(tmp_cost));
  if (raw_cost != 0) {
    total_size += 9;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Cost::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Cost*>(
      &from));
}

void TripLeg_Cost::MergeFrom(const TripLeg_Cost& from) {
  TripLeg_Cost* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Cost)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_seconds = from._internal_seconds();
  ::uint64_t raw_seconds;
  memcpy(&raw_seconds, &tmp_seconds, sizeof(tmp_seconds));
  if (raw_seconds != 0) {
    _this->_internal_set_seconds(from._internal_seconds());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_cost = from._internal_cost();
  ::uint64_t raw_cost;
  memcpy(&raw_cost, &tmp_cost, sizeof(tmp_cost));
  if (raw_cost != 0) {
    _this->_internal_set_cost(from._internal_cost());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Cost::CopyFrom(const TripLeg_Cost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Cost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TripLeg_Cost::IsInitialized() const {
  return true;
}

void TripLeg_Cost::InternalSwap(TripLeg_Cost* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Cost, _impl_.cost_)
      + sizeof(TripLeg_Cost::_impl_.cost_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Cost, _impl_.seconds_)>(
          reinterpret_cast<char*>(&_impl_.seconds_),
          reinterpret_cast<char*>(&other->_impl_.seconds_));
}

std::string TripLeg_Cost::GetTypeName() const {
  return "valhalla.TripLeg.Cost";
}

// ===================================================================

class TripLeg_PathCost::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_PathCost>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_._has_bits_);
  static const ::valhalla::TripLeg_Cost& elapsed_cost(const TripLeg_PathCost* msg);
  static void set_has_elapsed_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::valhalla::TripLeg_Cost& transition_cost(const TripLeg_PathCost* msg);
  static void set_has_transition_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::valhalla::TripLeg_Cost& TripLeg_PathCost::_Internal::elapsed_cost(const TripLeg_PathCost* msg) {
  return *msg->_impl_.elapsed_cost_;
}
const ::valhalla::TripLeg_Cost& TripLeg_PathCost::_Internal::transition_cost(const TripLeg_PathCost* msg) {
  return *msg->_impl_.transition_cost_;
}
TripLeg_PathCost::TripLeg_PathCost(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.PathCost)
}
TripLeg_PathCost::TripLeg_PathCost(const TripLeg_PathCost& from) : ::google::protobuf::MessageLite() {
  TripLeg_PathCost* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.elapsed_cost_){nullptr},
      decltype(_impl_.transition_cost_){nullptr},
  };
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.elapsed_cost_ = new ::valhalla::TripLeg_Cost(*from._impl_.elapsed_cost_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.transition_cost_ = new ::valhalla::TripLeg_Cost(*from._impl_.transition_cost_);
  }

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.PathCost)
}
inline void TripLeg_PathCost::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.elapsed_cost_){nullptr},
      decltype(_impl_.transition_cost_){nullptr},
  };
}
TripLeg_PathCost::~TripLeg_PathCost() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.PathCost)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void TripLeg_PathCost::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.elapsed_cost_;
  if (this != internal_default_instance()) delete _impl_.transition_cost_;
}
void TripLeg_PathCost::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void TripLeg_PathCost::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.PathCost)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.elapsed_cost_ != nullptr);
      _impl_.elapsed_cost_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.transition_cost_ != nullptr);
      _impl_.transition_cost_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_PathCost::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2> TripLeg_PathCost::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_TripLeg_PathCost_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // .valhalla.TripLeg.Cost transition_cost = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_.transition_cost_)}},
    // .valhalla.TripLeg.Cost elapsed_cost = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_.elapsed_cost_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .valhalla.TripLeg.Cost elapsed_cost = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_.elapsed_cost_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.TripLeg.Cost transition_cost = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_.transition_cost_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_Cost>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_Cost>()},
  }}, {{
  }},
};

::uint8_t* TripLeg_PathCost::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.PathCost)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .valhalla.TripLeg.Cost elapsed_cost = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::elapsed_cost(this),
        _Internal::elapsed_cost(this).GetCachedSize(), target, stream);
  }

  // .valhalla.TripLeg.Cost transition_cost = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::transition_cost(this),
        _Internal::transition_cost(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.PathCost)
  return target;
}

::size_t TripLeg_PathCost::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.PathCost)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .valhalla.TripLeg.Cost elapsed_cost = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.elapsed_cost_);
    }

    // .valhalla.TripLeg.Cost transition_cost = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.transition_cost_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_PathCost::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_PathCost*>(
      &from));
}

void TripLeg_PathCost::MergeFrom(const TripLeg_PathCost& from) {
  TripLeg_PathCost* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.PathCost)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_elapsed_cost()->::valhalla::TripLeg_Cost::MergeFrom(
          from._internal_elapsed_cost());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_transition_cost()->::valhalla::TripLeg_Cost::MergeFrom(
          from._internal_transition_cost());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_PathCost::CopyFrom(const TripLeg_PathCost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.PathCost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TripLeg_PathCost::IsInitialized() const {
  return true;
}

void TripLeg_PathCost::InternalSwap(TripLeg_PathCost* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_.transition_cost_)
      + sizeof(TripLeg_PathCost::_impl_.transition_cost_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_.elapsed_cost_)>(
          reinterpret_cast<char*>(&_impl_.elapsed_cost_),
          reinterpret_cast<char*>(&other->_impl_.elapsed_cost_));
}

std::string TripLeg_PathCost::GetTypeName() const {
  return "valhalla.TripLeg.PathCost";
}

// ===================================================================

class TripLeg_Node::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_Node>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_._has_bits_);
  static const ::valhalla::TripLeg_Edge& edge(const TripLeg_Node* msg);
  static void set_has_edge(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::valhalla::TransitPlatformInfo& transit_platform_info(const TripLeg_Node* msg);
  static void set_has_transit_platform_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::valhalla::TransitStationInfo& transit_station_info(const TripLeg_Node* msg);
  static void set_has_transit_station_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::valhalla::TransitEgressInfo& transit_egress_info(const TripLeg_Node* msg);
  static void set_has_transit_egress_info(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::valhalla::TripLeg_PathCost& cost(const TripLeg_Node* msg);
  static void set_has_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::valhalla::BikeShareStationInfo& bss_info(const TripLeg_Node* msg);
  static void set_has_bss_info(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::valhalla::TripLeg_Edge& TripLeg_Node::_Internal::edge(const TripLeg_Node* msg) {
  return *msg->_impl_.edge_;
}
const ::valhalla::TransitPlatformInfo& TripLeg_Node::_Internal::transit_platform_info(const TripLeg_Node* msg) {
  return *msg->_impl_.transit_platform_info_;
}
const ::valhalla::TransitStationInfo& TripLeg_Node::_Internal::transit_station_info(const TripLeg_Node* msg) {
  return *msg->_impl_.transit_station_info_;
}
const ::valhalla::TransitEgressInfo& TripLeg_Node::_Internal::transit_egress_info(const TripLeg_Node* msg) {
  return *msg->_impl_.transit_egress_info_;
}
const ::valhalla::TripLeg_PathCost& TripLeg_Node::_Internal::cost(const TripLeg_Node* msg) {
  return *msg->_impl_.cost_;
}
const ::valhalla::BikeShareStationInfo& TripLeg_Node::_Internal::bss_info(const TripLeg_Node* msg) {
  return *msg->_impl_.bss_info_;
}
void TripLeg_Node::clear_transit_platform_info() {
  if (_impl_.transit_platform_info_ != nullptr) _impl_.transit_platform_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TripLeg_Node::clear_transit_station_info() {
  if (_impl_.transit_station_info_ != nullptr) _impl_.transit_station_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void TripLeg_Node::clear_transit_egress_info() {
  if (_impl_.transit_egress_info_ != nullptr) _impl_.transit_egress_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void TripLeg_Node::clear_bss_info() {
  if (_impl_.bss_info_ != nullptr) _impl_.bss_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
TripLeg_Node::TripLeg_Node(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Node)
}
TripLeg_Node::TripLeg_Node(const TripLeg_Node& from) : ::google::protobuf::MessageLite() {
  TripLeg_Node* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.intersecting_edge_){from._impl_.intersecting_edge_},
      decltype(_impl_.recosts_){from._impl_.recosts_},
      decltype(_impl_.time_zone_){},
      decltype(_impl_.edge_){nullptr},
      decltype(_impl_.transit_platform_info_){nullptr},
      decltype(_impl_.transit_station_info_){nullptr},
      decltype(_impl_.transit_egress_info_){nullptr},
      decltype(_impl_.cost_){nullptr},
      decltype(_impl_.bss_info_){nullptr},
      decltype(_impl_.admin_index_){},
      decltype(_impl_.type_){},
      decltype(_impl_.fork_){},
  };
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  _impl_.time_zone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.time_zone_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_time_zone().empty()) {
    _this->_impl_.time_zone_.Set(from._internal_time_zone(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.edge_ = new ::valhalla::TripLeg_Edge(*from._impl_.edge_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.transit_platform_info_ = new ::valhalla::TransitPlatformInfo(*from._impl_.transit_platform_info_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.transit_station_info_ = new ::valhalla::TransitStationInfo(*from._impl_.transit_station_info_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.transit_egress_info_ = new ::valhalla::TransitEgressInfo(*from._impl_.transit_egress_info_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.cost_ = new ::valhalla::TripLeg_PathCost(*from._impl_.cost_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000020u) != 0) {
    _this->_impl_.bss_info_ = new ::valhalla::BikeShareStationInfo(*from._impl_.bss_info_);
  }
  ::memcpy(&_impl_.admin_index_, &from._impl_.admin_index_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.fork_) -
    reinterpret_cast<char*>(&_impl_.admin_index_)) + sizeof(_impl_.fork_));

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Node)
}
inline void TripLeg_Node::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.intersecting_edge_){arena},
      decltype(_impl_.recosts_){arena},
      decltype(_impl_.time_zone_){},
      decltype(_impl_.edge_){nullptr},
      decltype(_impl_.transit_platform_info_){nullptr},
      decltype(_impl_.transit_station_info_){nullptr},
      decltype(_impl_.transit_egress_info_){nullptr},
      decltype(_impl_.cost_){nullptr},
      decltype(_impl_.bss_info_){nullptr},
      decltype(_impl_.admin_index_){0u},
      decltype(_impl_.type_){0},
      decltype(_impl_.fork_){false},
  };
  _impl_.time_zone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.time_zone_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
TripLeg_Node::~TripLeg_Node() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Node)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void TripLeg_Node::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.intersecting_edge_.~RepeatedPtrField();
  _impl_.recosts_.~RepeatedPtrField();
  _impl_.time_zone_.Destroy();
  if (this != internal_default_instance()) delete _impl_.edge_;
  if (this != internal_default_instance()) delete _impl_.transit_platform_info_;
  if (this != internal_default_instance()) delete _impl_.transit_station_info_;
  if (this != internal_default_instance()) delete _impl_.transit_egress_info_;
  if (this != internal_default_instance()) delete _impl_.cost_;
  if (this != internal_default_instance()) delete _impl_.bss_info_;
}
void TripLeg_Node::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void TripLeg_Node::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Node)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_intersecting_edge()->Clear();
  _internal_mutable_recosts()->Clear();
  _impl_.time_zone_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.edge_ != nullptr);
      _impl_.edge_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.transit_platform_info_ != nullptr);
      _impl_.transit_platform_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.transit_station_info_ != nullptr);
      _impl_.transit_station_info_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.transit_egress_info_ != nullptr);
      _impl_.transit_egress_info_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.cost_ != nullptr);
      _impl_.cost_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.bss_info_ != nullptr);
      _impl_.bss_info_->Clear();
    }
  }
  ::memset(&_impl_.admin_index_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.fork_) -
      reinterpret_cast<char*>(&_impl_.admin_index_)) + sizeof(_impl_.fork_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Node::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 12, 8, 47, 2> TripLeg_Node::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_._has_bits_),
    0, // no _extensions_
    14, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294951296,  // skipmap
    offsetof(decltype(_table_), field_entries),
    12,  // num_field_entries
    8,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_TripLeg_Node_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .valhalla.TripLeg.Edge edge = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.edge_)}},
    // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 1, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.intersecting_edge_)}},
    // uint32 admin_index = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.admin_index_)}},
    // .valhalla.TripLeg.Node.Type type = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.type_)}},
    // bool fork = 5;
    {::_pbi::TcParser::FastV8S1,
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.fork_)}},
    // .valhalla.TransitPlatformInfo transit_platform_info = 6;
    {::_pbi::TcParser::FastMtS1,
     {50, 1, 2, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.transit_platform_info_)}},
    // .valhalla.TransitStationInfo transit_station_info = 7;
    {::_pbi::TcParser::FastMtS1,
     {58, 2, 3, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.transit_station_info_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // .valhalla.TransitEgressInfo transit_egress_info = 10;
    {::_pbi::TcParser::FastMtS1,
     {82, 3, 4, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.transit_egress_info_)}},
    // string time_zone = 11;
    {::_pbi::TcParser::FastUS1,
     {90, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.time_zone_)}},
    // .valhalla.TripLeg.PathCost cost = 12;
    {::_pbi::TcParser::FastMtS1,
     {98, 4, 5, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.cost_)}},
    // repeated .valhalla.TripLeg.PathCost recosts = 13;
    {::_pbi::TcParser::FastMtR1,
     {106, 63, 6, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.recosts_)}},
    // .valhalla.BikeShareStationInfo bss_info = 14;
    {::_pbi::TcParser::FastMtS1,
     {114, 5, 7, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.bss_info_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .valhalla.TripLeg.Edge edge = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.edge_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.intersecting_edge_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // uint32 admin_index = 3;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.admin_index_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // .valhalla.TripLeg.Node.Type type = 4;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // bool fork = 5;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.fork_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // .valhalla.TransitPlatformInfo transit_platform_info = 6;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.transit_platform_info_), _Internal::kHasBitsOffset + 1, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.TransitStationInfo transit_station_info = 7;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.transit_station_info_), _Internal::kHasBitsOffset + 2, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.TransitEgressInfo transit_egress_info = 10;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.transit_egress_info_), _Internal::kHasBitsOffset + 3, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // string time_zone = 11;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.time_zone_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .valhalla.TripLeg.PathCost cost = 12;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.cost_), _Internal::kHasBitsOffset + 4, 5,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.TripLeg.PathCost recosts = 13;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.recosts_), -1, 6,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.BikeShareStationInfo bss_info = 14;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.bss_info_), _Internal::kHasBitsOffset + 5, 7,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_Edge>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_IntersectingEdge>()},
    {::_pbi::TcParser::GetTable<::valhalla::TransitPlatformInfo>()},
    {::_pbi::TcParser::GetTable<::valhalla::TransitStationInfo>()},
    {::_pbi::TcParser::GetTable<::valhalla::TransitEgressInfo>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_PathCost>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_PathCost>()},
    {::_pbi::TcParser::GetTable<::valhalla::BikeShareStationInfo>()},
  }}, {{
    "\25\0\0\0\0\0\0\0\0\11\0\0\0\0\0\0"
    "valhalla.TripLeg.Node"
    "time_zone"
  }},
};

::uint8_t* TripLeg_Node::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Node)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .valhalla.TripLeg.Edge edge = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::edge(this),
        _Internal::edge(this).GetCachedSize(), target, stream);
  }

  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_intersecting_edge_size()); i < n; i++) {
    const auto& repfield = this->_internal_intersecting_edge().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // uint32 admin_index = 3;
  if (this->_internal_admin_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_admin_index(), target);
  }

  // .valhalla.TripLeg.Node.Type type = 4;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_type(), target);
  }

  // bool fork = 5;
  if (this->_internal_fork() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_fork(), target);
  }

  // .valhalla.TransitPlatformInfo transit_platform_info = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::transit_platform_info(this),
        _Internal::transit_platform_info(this).GetCachedSize(), target, stream);
  }

  // .valhalla.TransitStationInfo transit_station_info = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::transit_station_info(this),
        _Internal::transit_station_info(this).GetCachedSize(), target, stream);
  }

  // .valhalla.TransitEgressInfo transit_egress_info = 10;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::transit_egress_info(this),
        _Internal::transit_egress_info(this).GetCachedSize(), target, stream);
  }

  // string time_zone = 11;
  if (!this->_internal_time_zone().empty()) {
    const std::string& _s = this->_internal_time_zone();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TripLeg.Node.time_zone");
    target = stream->WriteStringMaybeAliased(11, _s, target);
  }

  // .valhalla.TripLeg.PathCost cost = 12;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::cost(this),
        _Internal::cost(this).GetCachedSize(), target, stream);
  }

  // repeated .valhalla.TripLeg.PathCost recosts = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_recosts_size()); i < n; i++) {
    const auto& repfield = this->_internal_recosts().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .valhalla.BikeShareStationInfo bss_info = 14;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::bss_info(this),
        _Internal::bss_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Node)
  return target;
}

::size_t TripLeg_Node::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Node)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  total_size += 1UL * this->_internal_intersecting_edge_size();
  for (const auto& msg : this->_internal_intersecting_edge()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .valhalla.TripLeg.PathCost recosts = 13;
  total_size += 1UL * this->_internal_recosts_size();
  for (const auto& msg : this->_internal_recosts()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // string time_zone = 11;
  if (!this->_internal_time_zone().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_time_zone());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // .valhalla.TripLeg.Edge edge = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.edge_);
    }

    // .valhalla.TransitPlatformInfo transit_platform_info = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.transit_platform_info_);
    }

    // .valhalla.TransitStationInfo transit_station_info = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.transit_station_info_);
    }

    // .valhalla.TransitEgressInfo transit_egress_info = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.transit_egress_info_);
    }

    // .valhalla.TripLeg.PathCost cost = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.cost_);
    }

    // .valhalla.BikeShareStationInfo bss_info = 14;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.bss_info_);
    }

  }
  // uint32 admin_index = 3;
  if (this->_internal_admin_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_admin_index());
  }

  // .valhalla.TripLeg.Node.Type type = 4;
  if (this->_internal_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // bool fork = 5;
  if (this->_internal_fork() != 0) {
    total_size += 2;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Node::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Node*>(
      &from));
}

void TripLeg_Node::MergeFrom(const TripLeg_Node& from) {
  TripLeg_Node* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Node)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_intersecting_edge()->MergeFrom(from._internal_intersecting_edge());
  _this->_internal_mutable_recosts()->MergeFrom(from._internal_recosts());
  if (!from._internal_time_zone().empty()) {
    _this->_internal_set_time_zone(from._internal_time_zone());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_edge()->::valhalla::TripLeg_Edge::MergeFrom(
          from._internal_edge());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_transit_platform_info()->::valhalla::TransitPlatformInfo::MergeFrom(
          from._internal_transit_platform_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_transit_station_info()->::valhalla::TransitStationInfo::MergeFrom(
          from._internal_transit_station_info());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_transit_egress_info()->::valhalla::TransitEgressInfo::MergeFrom(
          from._internal_transit_egress_info());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_cost()->::valhalla::TripLeg_PathCost::MergeFrom(
          from._internal_cost());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_bss_info()->::valhalla::BikeShareStationInfo::MergeFrom(
          from._internal_bss_info());
    }
  }
  if (from._internal_admin_index() != 0) {
    _this->_internal_set_admin_index(from._internal_admin_index());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_fork() != 0) {
    _this->_internal_set_fork(from._internal_fork());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Node::CopyFrom(const TripLeg_Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TripLeg_Node::IsInitialized() const {
  return true;
}

void TripLeg_Node::InternalSwap(TripLeg_Node* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.intersecting_edge_.InternalSwap(&other->_impl_.intersecting_edge_);
  _impl_.recosts_.InternalSwap(&other->_impl_.recosts_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.time_zone_, lhs_arena,
                                       &other->_impl_.time_zone_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.fork_)
      + sizeof(TripLeg_Node::_impl_.fork_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.edge_)>(
          reinterpret_cast<char*>(&_impl_.edge_),
          reinterpret_cast<char*>(&other->_impl_.edge_));
}

std::string TripLeg_Node::GetTypeName() const {
  return "valhalla.TripLeg.Node";
}

// ===================================================================

class TripLeg_Admin::_Internal {
 public:
};

TripLeg_Admin::TripLeg_Admin(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Admin)
}
TripLeg_Admin::TripLeg_Admin(const TripLeg_Admin& from) : ::google::protobuf::MessageLite() {
  TripLeg_Admin* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.country_code_){},
      decltype(_impl_.country_text_){},
      decltype(_impl_.state_code_){},
      decltype(_impl_.state_text_){},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  _impl_.country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.country_code_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_country_code().empty()) {
    _this->_impl_.country_code_.Set(from._internal_country_code(), _this->GetArenaForAllocation());
  }
  _impl_.country_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.country_text_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_country_text().empty()) {
    _this->_impl_.country_text_.Set(from._internal_country_text(), _this->GetArenaForAllocation());
  }
  _impl_.state_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.state_code_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_state_code().empty()) {
    _this->_impl_.state_code_.Set(from._internal_state_code(), _this->GetArenaForAllocation());
  }
  _impl_.state_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.state_text_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_state_text().empty()) {
    _this->_impl_.state_text_.Set(from._internal_state_text(), _this->GetArenaForAllocation());
  }

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Admin)
}
inline void TripLeg_Admin::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.country_code_){},
      decltype(_impl_.country_text_){},
      decltype(_impl_.state_code_){},
      decltype(_impl_.state_text_){},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _impl_.country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.country_code_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.country_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.country_text_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.state_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.state_code_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.state_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.state_text_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
TripLeg_Admin::~TripLeg_Admin() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Admin)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void TripLeg_Admin::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.country_code_.Destroy();
  _impl_.country_text_.Destroy();
  _impl_.state_code_.Destroy();
  _impl_.state_text_.Destroy();
}
void TripLeg_Admin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void TripLeg_Admin::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Admin)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.country_code_.ClearToEmpty();
  _impl_.country_text_.ClearToEmpty();
  _impl_.state_code_.ClearToEmpty();
  _impl_.state_text_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Admin::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 75, 2> TripLeg_Admin::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_TripLeg_Admin_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // string state_text = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Admin, _impl_.state_text_)}},
    // string country_code = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Admin, _impl_.country_code_)}},
    // string country_text = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Admin, _impl_.country_text_)}},
    // string state_code = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Admin, _impl_.state_code_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string country_code = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Admin, _impl_.country_code_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string country_text = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Admin, _impl_.country_text_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string state_code = 3;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Admin, _impl_.state_code_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string state_text = 4;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Admin, _impl_.state_text_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\26\14\14\12\12\0\0\0"
    "valhalla.TripLeg.Admin"
    "country_code"
    "country_text"
    "state_code"
    "state_text"
  }},
};

::uint8_t* TripLeg_Admin::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Admin)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string country_code = 1;
  if (!this->_internal_country_code().empty()) {
    const std::string& _s = this->_internal_country_code();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TripLeg.Admin.country_code");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string country_text = 2;
  if (!this->_internal_country_text().empty()) {
    const std::string& _s = this->_internal_country_text();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TripLeg.Admin.country_text");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string state_code = 3;
  if (!this->_internal_state_code().empty()) {
    const std::string& _s = this->_internal_state_code();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TripLeg.Admin.state_code");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string state_text = 4;
  if (!this->_internal_state_text().empty()) {
    const std::string& _s = this->_internal_state_text();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TripLeg.Admin.state_text");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Admin)
  return target;
}

::size_t TripLeg_Admin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Admin)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string country_code = 1;
  if (!this->_internal_country_code().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_country_code());
  }

  // string country_text = 2;
  if (!this->_internal_country_text().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_country_text());
  }

  // string state_code = 3;
  if (!this->_internal_state_code().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_state_code());
  }

  // string state_text = 4;
  if (!this->_internal_state_text().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_state_text());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Admin::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Admin*>(
      &from));
}

void TripLeg_Admin::MergeFrom(const TripLeg_Admin& from) {
  TripLeg_Admin* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Admin)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_country_code().empty()) {
    _this->_internal_set_country_code(from._internal_country_code());
  }
  if (!from._internal_country_text().empty()) {
    _this->_internal_set_country_text(from._internal_country_text());
  }
  if (!from._internal_state_code().empty()) {
    _this->_internal_set_state_code(from._internal_state_code());
  }
  if (!from._internal_state_text().empty()) {
    _this->_internal_set_state_text(from._internal_state_text());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Admin::CopyFrom(const TripLeg_Admin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Admin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TripLeg_Admin::IsInitialized() const {
  return true;
}

void TripLeg_Admin::InternalSwap(TripLeg_Admin* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.country_code_, lhs_arena,
                                       &other->_impl_.country_code_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.country_text_, lhs_arena,
                                       &other->_impl_.country_text_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.state_code_, lhs_arena,
                                       &other->_impl_.state_code_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.state_text_, lhs_arena,
                                       &other->_impl_.state_text_, rhs_arena);
}

std::string TripLeg_Admin::GetTypeName() const {
  return "valhalla.TripLeg.Admin";
}

// ===================================================================

class TripLeg_ShapeAttributes::_Internal {
 public:
};

TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.ShapeAttributes)
}
TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(const TripLeg_ShapeAttributes& from) : ::google::protobuf::MessageLite() {
  TripLeg_ShapeAttributes* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.time_){from._impl_.time_},
      /* _impl_._time_cached_byte_size_ = */ {0},
      decltype(_impl_.length_){from._impl_.length_},
      /* _impl_._length_cached_byte_size_ = */ {0},
      decltype(_impl_.speed_){from._impl_.speed_},
      /* _impl_._speed_cached_byte_size_ = */ {0},
      decltype(_impl_.speed_limit_){from._impl_.speed_limit_},
      /* _impl_._speed_limit_cached_byte_size_ = */ {0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.ShapeAttributes)
}
inline void TripLeg_ShapeAttributes::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.time_){arena},
      /* _impl_._time_cached_byte_size_ = */ {0},
      decltype(_impl_.length_){arena},
      /* _impl_._length_cached_byte_size_ = */ {0},
      decltype(_impl_.speed_){arena},
      /* _impl_._speed_cached_byte_size_ = */ {0},
      decltype(_impl_.speed_limit_){arena},
      /* _impl_._speed_limit_cached_byte_size_ = */ {0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
TripLeg_ShapeAttributes::~TripLeg_ShapeAttributes() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.ShapeAttributes)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void TripLeg_ShapeAttributes::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.time_.~RepeatedField();
  _impl_.length_.~RepeatedField();
  _impl_.speed_.~RepeatedField();
  _impl_.speed_limit_.~RepeatedField();
}
void TripLeg_ShapeAttributes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void TripLeg_ShapeAttributes::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.ShapeAttributes)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_time()->Clear();
  _internal_mutable_length()->Clear();
  _internal_mutable_speed()->Clear();
  _internal_mutable_speed_limit()->Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_ShapeAttributes::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 4, 0, 0, 2> TripLeg_ShapeAttributes::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967272,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_TripLeg_ShapeAttributes_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated uint32 time = 1 [packed = true];
    {::_pbi::TcParser::FastV32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.time_)}},
    // repeated uint32 length = 2 [packed = true];
    {::_pbi::TcParser::FastV32P1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.length_)}},
    // repeated uint32 speed = 3 [packed = true];
    {::_pbi::TcParser::FastV32P1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.speed_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated uint32 speed_limit = 5 [packed = true];
    {::_pbi::TcParser::FastV32P1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.speed_limit_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated uint32 time = 1 [packed = true];
    {PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.time_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedUInt32)},
    // repeated uint32 length = 2 [packed = true];
    {PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.length_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedUInt32)},
    // repeated uint32 speed = 3 [packed = true];
    {PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.speed_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedUInt32)},
    // repeated uint32 speed_limit = 5 [packed = true];
    {PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.speed_limit_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* TripLeg_ShapeAttributes::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.ShapeAttributes)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated uint32 time = 1 [packed = true];
  {
    int byte_size = _impl_._time_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(1, _internal_time(),
                                                 byte_size, target);
    }
  }

  // repeated uint32 length = 2 [packed = true];
  {
    int byte_size = _impl_._length_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(2, _internal_length(),
                                                 byte_size, target);
    }
  }

  // repeated uint32 speed = 3 [packed = true];
  {
    int byte_size = _impl_._speed_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(3, _internal_speed(),
                                                 byte_size, target);
    }
  }

  // repeated uint32 speed_limit = 5 [packed = true];
  {
    int byte_size = _impl_._speed_limit_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(5, _internal_speed_limit(),
                                                 byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.ShapeAttributes)
  return target;
}

::size_t TripLeg_ShapeAttributes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.ShapeAttributes)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 time = 1 [packed = true];
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_time())
    ;
    _impl_._time_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // repeated uint32 length = 2 [packed = true];
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_length())
    ;
    _impl_._length_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // repeated uint32 speed = 3 [packed = true];
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_speed())
    ;
    _impl_._speed_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // repeated uint32 speed_limit = 5 [packed = true];
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_speed_limit())
    ;
    _impl_._speed_limit_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_ShapeAttributes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_ShapeAttributes*>(
      &from));
}

void TripLeg_ShapeAttributes::MergeFrom(const TripLeg_ShapeAttributes& from) {
  TripLeg_ShapeAttributes* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.ShapeAttributes)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_time()->MergeFrom(from._internal_time());
  _this->_internal_mutable_length()->MergeFrom(from._internal_length());
  _this->_internal_mutable_speed()->MergeFrom(from._internal_speed());
  _this->_internal_mutable_speed_limit()->MergeFrom(from._internal_speed_limit());
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_ShapeAttributes::CopyFrom(const TripLeg_ShapeAttributes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.ShapeAttributes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TripLeg_ShapeAttributes::IsInitialized() const {
  return true;
}

void TripLeg_ShapeAttributes::InternalSwap(TripLeg_ShapeAttributes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.time_.InternalSwap(&other->_impl_.time_);
  _impl_.length_.InternalSwap(&other->_impl_.length_);
  _impl_.speed_.InternalSwap(&other->_impl_.speed_);
  _impl_.speed_limit_.InternalSwap(&other->_impl_.speed_limit_);
}

std::string TripLeg_ShapeAttributes::GetTypeName() const {
  return "valhalla.TripLeg.ShapeAttributes";
}

// ===================================================================

class TripLeg_Incident::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_Incident>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_._has_bits_);
  static const ::valhalla::IncidentsTile_Metadata& metadata(const TripLeg_Incident* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::valhalla::IncidentsTile_Metadata& TripLeg_Incident::_Internal::metadata(const TripLeg_Incident* msg) {
  return *msg->_impl_.metadata_;
}
void TripLeg_Incident::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
TripLeg_Incident::TripLeg_Incident(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Incident)
}
TripLeg_Incident::TripLeg_Incident(const TripLeg_Incident& from) : ::google::protobuf::MessageLite() {
  TripLeg_Incident* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.metadata_){nullptr},
      decltype(_impl_.begin_shape_index_){},
      decltype(_impl_.end_shape_index_){},
  };
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.metadata_ = new ::valhalla::IncidentsTile_Metadata(*from._impl_.metadata_);
  }
  ::memcpy(&_impl_.begin_shape_index_, &from._impl_.begin_shape_index_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.end_shape_index_) -
    reinterpret_cast<char*>(&_impl_.begin_shape_index_)) + sizeof(_impl_.end_shape_index_));

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Incident)
}
inline void TripLeg_Incident::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.metadata_){nullptr},
      decltype(_impl_.begin_shape_index_){0u},
      decltype(_impl_.end_shape_index_){0u},
  };
}
TripLeg_Incident::~TripLeg_Incident() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Incident)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void TripLeg_Incident::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
}
void TripLeg_Incident::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void TripLeg_Incident::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Incident)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  ::memset(&_impl_.begin_shape_index_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.end_shape_index_) -
      reinterpret_cast<char*>(&_impl_.begin_shape_index_)) + sizeof(_impl_.end_shape_index_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Incident::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> TripLeg_Incident::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967282,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_TripLeg_Incident_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // uint32 end_shape_index = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_.end_shape_index_)}},
    // .valhalla.IncidentsTile.Metadata metadata = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_.metadata_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // uint32 begin_shape_index = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_.begin_shape_index_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .valhalla.IncidentsTile.Metadata metadata = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_.metadata_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // uint32 begin_shape_index = 3;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_.begin_shape_index_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 end_shape_index = 4;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_.end_shape_index_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::IncidentsTile_Metadata>()},
  }}, {{
  }},
};

::uint8_t* TripLeg_Incident::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Incident)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .valhalla.IncidentsTile.Metadata metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // uint32 begin_shape_index = 3;
  if (this->_internal_begin_shape_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_begin_shape_index(), target);
  }

  // uint32 end_shape_index = 4;
  if (this->_internal_end_shape_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_end_shape_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Incident)
  return target;
}

::size_t TripLeg_Incident::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Incident)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .valhalla.IncidentsTile.Metadata metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  // uint32 begin_shape_index = 3;
  if (this->_internal_begin_shape_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_begin_shape_index());
  }

  // uint32 end_shape_index = 4;
  if (this->_internal_end_shape_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_end_shape_index());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Incident::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Incident*>(
      &from));
}

void TripLeg_Incident::MergeFrom(const TripLeg_Incident& from) {
  TripLeg_Incident* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Incident)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_metadata()->::valhalla::IncidentsTile_Metadata::MergeFrom(
        from._internal_metadata());
  }
  if (from._internal_begin_shape_index() != 0) {
    _this->_internal_set_begin_shape_index(from._internal_begin_shape_index());
  }
  if (from._internal_end_shape_index() != 0) {
    _this->_internal_set_end_shape_index(from._internal_end_shape_index());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Incident::CopyFrom(const TripLeg_Incident& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Incident)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TripLeg_Incident::IsInitialized() const {
  return true;
}

void TripLeg_Incident::InternalSwap(TripLeg_Incident* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_.end_shape_index_)
      + sizeof(TripLeg_Incident::_impl_.end_shape_index_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

std::string TripLeg_Incident::GetTypeName() const {
  return "valhalla.TripLeg.Incident";
}

// ===================================================================

class TripLeg_Closure::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::valhalla::TripLeg_Closure, _impl_._oneof_case_);
};

TripLeg_Closure::TripLeg_Closure(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Closure)
}
TripLeg_Closure::TripLeg_Closure(const TripLeg_Closure& from) : ::google::protobuf::MessageLite() {
  TripLeg_Closure* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.has_begin_shape_index_){},
      decltype(_impl_.has_end_shape_index_){},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  clear_has_has_begin_shape_index();
  switch (from.has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      _this->_internal_set_begin_shape_index(from._internal_begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  clear_has_has_end_shape_index();
  switch (from.has_end_shape_index_case()) {
    case kEndShapeIndex: {
      _this->_internal_set_end_shape_index(from._internal_end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Closure)
}
inline void TripLeg_Closure::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.has_begin_shape_index_){},
      decltype(_impl_.has_end_shape_index_){},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_has_begin_shape_index();
  clear_has_has_end_shape_index();
}
TripLeg_Closure::~TripLeg_Closure() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Closure)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void TripLeg_Closure::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_has_begin_shape_index()) {
    clear_has_begin_shape_index();
  }
  if (has_has_end_shape_index()) {
    clear_has_end_shape_index();
  }
}
void TripLeg_Closure::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_Closure::clear_has_begin_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Closure)
  switch (has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}

void TripLeg_Closure::clear_has_end_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Closure)
  switch (has_end_shape_index_case()) {
    case kEndShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_END_SHAPE_INDEX_NOT_SET;
}


PROTOBUF_NOINLINE void TripLeg_Closure::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Closure)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_has_begin_shape_index();
  clear_has_end_shape_index();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Closure::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 2, 0, 0, 2> TripLeg_Closure::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_TripLeg_Closure_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 begin_shape_index = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Closure, _impl_.has_begin_shape_index_.begin_shape_index_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // uint32 end_shape_index = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Closure, _impl_.has_end_shape_index_.end_shape_index_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* TripLeg_Closure::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Closure)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint32 begin_shape_index = 1;
  if (has_begin_shape_index_case() == kBeginShapeIndex) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_begin_shape_index(), target);
  }

  // uint32 end_shape_index = 2;
  if (has_end_shape_index_case() == kEndShapeIndex) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_end_shape_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Closure)
  return target;
}

::size_t TripLeg_Closure::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Closure)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (has_begin_shape_index_case()) {
    // uint32 begin_shape_index = 1;
    case kBeginShapeIndex: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (has_end_shape_index_case()) {
    // uint32 end_shape_index = 2;
    case kEndShapeIndex: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Closure::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Closure*>(
      &from));
}

void TripLeg_Closure::MergeFrom(const TripLeg_Closure& from) {
  TripLeg_Closure* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Closure)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      _this->_internal_set_begin_shape_index(from._internal_begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (from.has_end_shape_index_case()) {
    case kEndShapeIndex: {
      _this->_internal_set_end_shape_index(from._internal_end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Closure::CopyFrom(const TripLeg_Closure& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Closure)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TripLeg_Closure::IsInitialized() const {
  return true;
}

void TripLeg_Closure::InternalSwap(TripLeg_Closure* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.has_begin_shape_index_, other->_impl_.has_begin_shape_index_);
  swap(_impl_.has_end_shape_index_, other->_impl_.has_end_shape_index_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

std::string TripLeg_Closure::GetTypeName() const {
  return "valhalla.TripLeg.Closure";
}

// ===================================================================

class TripLeg::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TripLeg, _impl_._has_bits_);
  static const ::valhalla::BoundingBox& bbox(const TripLeg* msg);
  static void set_has_bbox(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::valhalla::TripLeg_ShapeAttributes& shape_attributes(const TripLeg* msg);
  static void set_has_shape_attributes(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::valhalla::BoundingBox& TripLeg::_Internal::bbox(const TripLeg* msg) {
  return *msg->_impl_.bbox_;
}
const ::valhalla::TripLeg_ShapeAttributes& TripLeg::_Internal::shape_attributes(const TripLeg* msg) {
  return *msg->_impl_.shape_attributes_;
}
void TripLeg::clear_location() {
  _internal_mutable_location()->Clear();
}
void TripLeg::clear_bbox() {
  if (_impl_.bbox_ != nullptr) _impl_.bbox_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
TripLeg::TripLeg(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg)
}
TripLeg::TripLeg(const TripLeg& from) : ::google::protobuf::MessageLite() {
  TripLeg* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.location_){from._impl_.location_},
      decltype(_impl_.node_){from._impl_.node_},
      decltype(_impl_.admin_){from._impl_.admin_},
      decltype(_impl_.incidents_){from._impl_.incidents_},
      decltype(_impl_.algorithms_){from._impl_.algorithms_},
      decltype(_impl_.closures_){from._impl_.closures_},
      decltype(_impl_.shape_){},
      decltype(_impl_.bbox_){nullptr},
      decltype(_impl_.shape_attributes_){nullptr},
      decltype(_impl_.osm_changeset_){},
      decltype(_impl_.trip_id_){},
      decltype(_impl_.leg_id_){},
      decltype(_impl_.leg_count_){},
  };
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  _impl_.shape_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.shape_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_shape().empty()) {
    _this->_impl_.shape_.Set(from._internal_shape(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.bbox_ = new ::valhalla::BoundingBox(*from._impl_.bbox_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.shape_attributes_ = new ::valhalla::TripLeg_ShapeAttributes(*from._impl_.shape_attributes_);
  }
  ::memcpy(&_impl_.osm_changeset_, &from._impl_.osm_changeset_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.leg_count_) -
    reinterpret_cast<char*>(&_impl_.osm_changeset_)) + sizeof(_impl_.leg_count_));

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg)
}
inline void TripLeg::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.location_){arena},
      decltype(_impl_.node_){arena},
      decltype(_impl_.admin_){arena},
      decltype(_impl_.incidents_){arena},
      decltype(_impl_.algorithms_){arena},
      decltype(_impl_.closures_){arena},
      decltype(_impl_.shape_){},
      decltype(_impl_.bbox_){nullptr},
      decltype(_impl_.shape_attributes_){nullptr},
      decltype(_impl_.osm_changeset_){::uint64_t{0u}},
      decltype(_impl_.trip_id_){::uint64_t{0u}},
      decltype(_impl_.leg_id_){0u},
      decltype(_impl_.leg_count_){0u},
  };
  _impl_.shape_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.shape_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
TripLeg::~TripLeg() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void TripLeg::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.location_.~RepeatedPtrField();
  _impl_.node_.~RepeatedPtrField();
  _impl_.admin_.~RepeatedPtrField();
  _impl_.incidents_.~RepeatedPtrField();
  _internal_mutable_algorithms()->~RepeatedPtrField();
  _impl_.closures_.~RepeatedPtrField();
  _impl_.shape_.Destroy();
  if (this != internal_default_instance()) delete _impl_.bbox_;
  if (this != internal_default_instance()) delete _impl_.shape_attributes_;
}
void TripLeg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void TripLeg::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_location()->Clear();
  _internal_mutable_node()->Clear();
  _internal_mutable_admin()->Clear();
  _internal_mutable_incidents()->Clear();
  _internal_mutable_algorithms()->Clear();
  _internal_mutable_closures()->Clear();
  _impl_.shape_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.bbox_ != nullptr);
      _impl_.bbox_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.shape_attributes_ != nullptr);
      _impl_.shape_attributes_->Clear();
    }
  }
  ::memset(&_impl_.osm_changeset_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.leg_count_) -
      reinterpret_cast<char*>(&_impl_.osm_changeset_)) + sizeof(_impl_.leg_count_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 13, 7, 48, 2> TripLeg::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TripLeg, _impl_._has_bits_),
    0, // no _extensions_
    13, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294959104,  // skipmap
    offsetof(decltype(_table_), field_entries),
    13,  // num_field_entries
    7,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_TripLeg_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // uint64 osm_changeset = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.osm_changeset_)}},
    // uint64 trip_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.trip_id_)}},
    // uint32 leg_id = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.leg_id_)}},
    // uint32 leg_count = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.leg_count_)}},
    // repeated .valhalla.Location location = 5;
    {::_pbi::TcParser::FastMtR1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.location_)}},
    // repeated .valhalla.TripLeg.Node node = 6;
    {::_pbi::TcParser::FastMtR1,
     {50, 63, 1, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.node_)}},
    // repeated .valhalla.TripLeg.Admin admin = 7;
    {::_pbi::TcParser::FastMtR1,
     {58, 63, 2, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.admin_)}},
    // string shape = 8;
    {::_pbi::TcParser::FastUS1,
     {66, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.shape_)}},
    // .valhalla.BoundingBox bbox = 9;
    {::_pbi::TcParser::FastMtS1,
     {74, 0, 3, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.bbox_)}},
    // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
    {::_pbi::TcParser::FastMtS1,
     {82, 1, 4, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.shape_attributes_)}},
    // repeated .valhalla.TripLeg.Incident incidents = 11;
    {::_pbi::TcParser::FastMtR1,
     {90, 63, 5, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.incidents_)}},
    // repeated string algorithms = 12;
    {::_pbi::TcParser::FastUR1,
     {98, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.algorithms_)}},
    // repeated .valhalla.TripLeg.Closure closures = 13;
    {::_pbi::TcParser::FastMtR1,
     {106, 63, 6, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.closures_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // uint64 osm_changeset = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.osm_changeset_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // uint64 trip_id = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.trip_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // uint32 leg_id = 3;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.leg_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 leg_count = 4;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.leg_count_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // repeated .valhalla.Location location = 5;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.location_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.TripLeg.Node node = 6;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.node_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.TripLeg.Admin admin = 7;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.admin_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // string shape = 8;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.shape_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .valhalla.BoundingBox bbox = 9;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.bbox_), _Internal::kHasBitsOffset + 0, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.shape_attributes_), _Internal::kHasBitsOffset + 1, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.TripLeg.Incident incidents = 11;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.incidents_), -1, 5,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated string algorithms = 12;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.algorithms_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // repeated .valhalla.TripLeg.Closure closures = 13;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.closures_), -1, 6,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::Location>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_Node>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_Admin>()},
    {::_pbi::TcParser::GetTable<::valhalla::BoundingBox>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_ShapeAttributes>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_Incident>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_Closure>()},
  }}, {{
    "\20\0\0\0\0\0\0\0\5\0\0\0\12\0\0\0"
    "valhalla.TripLeg"
    "shape"
    "algorithms"
  }},
};

::uint8_t* TripLeg::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint64 osm_changeset = 1;
  if (this->_internal_osm_changeset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_osm_changeset(), target);
  }

  // uint64 trip_id = 2;
  if (this->_internal_trip_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_trip_id(), target);
  }

  // uint32 leg_id = 3;
  if (this->_internal_leg_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_leg_id(), target);
  }

  // uint32 leg_count = 4;
  if (this->_internal_leg_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_leg_count(), target);
  }

  // repeated .valhalla.Location location = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_location_size()); i < n; i++) {
    const auto& repfield = this->_internal_location().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .valhalla.TripLeg.Node node = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_node_size()); i < n; i++) {
    const auto& repfield = this->_internal_node().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .valhalla.TripLeg.Admin admin = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_admin_size()); i < n; i++) {
    const auto& repfield = this->_internal_admin().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string shape = 8;
  if (!this->_internal_shape().empty()) {
    const std::string& _s = this->_internal_shape();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TripLeg.shape");
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .valhalla.BoundingBox bbox = 9;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::bbox(this),
        _Internal::bbox(this).GetCachedSize(), target, stream);
  }

  // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::shape_attributes(this),
        _Internal::shape_attributes(this).GetCachedSize(), target, stream);
  }

  // repeated .valhalla.TripLeg.Incident incidents = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_incidents_size()); i < n; i++) {
    const auto& repfield = this->_internal_incidents().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string algorithms = 12;
  for (int i = 0, n = this->_internal_algorithms_size(); i < n; ++i) {
    const auto& s = this->_internal_algorithms().Get(i);
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TripLeg.algorithms");
    target = stream->WriteString(12, s, target);
  }

  // repeated .valhalla.TripLeg.Closure closures = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_closures_size()); i < n; i++) {
    const auto& repfield = this->_internal_closures().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg)
  return target;
}

::size_t TripLeg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.Location location = 5;
  total_size += 1UL * this->_internal_location_size();
  for (const auto& msg : this->_internal_location()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .valhalla.TripLeg.Node node = 6;
  total_size += 1UL * this->_internal_node_size();
  for (const auto& msg : this->_internal_node()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .valhalla.TripLeg.Admin admin = 7;
  total_size += 1UL * this->_internal_admin_size();
  for (const auto& msg : this->_internal_admin()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .valhalla.TripLeg.Incident incidents = 11;
  total_size += 1UL * this->_internal_incidents_size();
  for (const auto& msg : this->_internal_incidents()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated string algorithms = 12;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_algorithms().size());
  for (int i = 0, n = _internal_algorithms().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_algorithms().Get(i));
  }
  // repeated .valhalla.TripLeg.Closure closures = 13;
  total_size += 1UL * this->_internal_closures_size();
  for (const auto& msg : this->_internal_closures()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // string shape = 8;
  if (!this->_internal_shape().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_shape());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .valhalla.BoundingBox bbox = 9;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.bbox_);
    }

    // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.shape_attributes_);
    }

  }
  // uint64 osm_changeset = 1;
  if (this->_internal_osm_changeset() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_osm_changeset());
  }

  // uint64 trip_id = 2;
  if (this->_internal_trip_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_trip_id());
  }

  // uint32 leg_id = 3;
  if (this->_internal_leg_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_leg_id());
  }

  // uint32 leg_count = 4;
  if (this->_internal_leg_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_leg_count());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg*>(
      &from));
}

void TripLeg::MergeFrom(const TripLeg& from) {
  TripLeg* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_location()->MergeFrom(from._internal_location());
  _this->_internal_mutable_node()->MergeFrom(from._internal_node());
  _this->_internal_mutable_admin()->MergeFrom(from._internal_admin());
  _this->_internal_mutable_incidents()->MergeFrom(from._internal_incidents());
  _this->_internal_mutable_algorithms()->MergeFrom(from._internal_algorithms());
  _this->_internal_mutable_closures()->MergeFrom(from._internal_closures());
  if (!from._internal_shape().empty()) {
    _this->_internal_set_shape(from._internal_shape());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_bbox()->::valhalla::BoundingBox::MergeFrom(
          from._internal_bbox());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_shape_attributes()->::valhalla::TripLeg_ShapeAttributes::MergeFrom(
          from._internal_shape_attributes());
    }
  }
  if (from._internal_osm_changeset() != 0) {
    _this->_internal_set_osm_changeset(from._internal_osm_changeset());
  }
  if (from._internal_trip_id() != 0) {
    _this->_internal_set_trip_id(from._internal_trip_id());
  }
  if (from._internal_leg_id() != 0) {
    _this->_internal_set_leg_id(from._internal_leg_id());
  }
  if (from._internal_leg_count() != 0) {
    _this->_internal_set_leg_count(from._internal_leg_count());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg::CopyFrom(const TripLeg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TripLeg::IsInitialized() const {
  return true;
}

void TripLeg::InternalSwap(TripLeg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.location_.InternalSwap(&other->_impl_.location_);
  _impl_.node_.InternalSwap(&other->_impl_.node_);
  _impl_.admin_.InternalSwap(&other->_impl_.admin_);
  _impl_.incidents_.InternalSwap(&other->_impl_.incidents_);
  _impl_.algorithms_.InternalSwap(&other->_impl_.algorithms_);
  _impl_.closures_.InternalSwap(&other->_impl_.closures_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.shape_, lhs_arena,
                                       &other->_impl_.shape_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.leg_count_)
      + sizeof(TripLeg::_impl_.leg_count_)
      - PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.bbox_)>(
          reinterpret_cast<char*>(&_impl_.bbox_),
          reinterpret_cast<char*>(&other->_impl_.bbox_));
}

std::string TripLeg::GetTypeName() const {
  return "valhalla.TripLeg";
}

// ===================================================================

class TripRoute::_Internal {
 public:
};

TripRoute::TripRoute(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripRoute)
}
TripRoute::TripRoute(const TripRoute& from) : ::google::protobuf::MessageLite() {
  TripRoute* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.legs_){from._impl_.legs_},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);

  // @@protoc_insertion_point(copy_constructor:valhalla.TripRoute)
}
inline void TripRoute::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.legs_){arena},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
TripRoute::~TripRoute() {
  // @@protoc_insertion_point(destructor:valhalla.TripRoute)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void TripRoute::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.legs_.~RepeatedPtrField();
}
void TripRoute::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void TripRoute::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripRoute)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_legs()->Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripRoute::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2> TripRoute::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_TripRoute_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // repeated .valhalla.TripLeg legs = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(TripRoute, _impl_.legs_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .valhalla.TripLeg legs = 1;
    {PROTOBUF_FIELD_OFFSET(TripRoute, _impl_.legs_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg>()},
  }}, {{
  }},
};

::uint8_t* TripRoute::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripRoute)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .valhalla.TripLeg legs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_legs_size()); i < n; i++) {
    const auto& repfield = this->_internal_legs().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripRoute)
  return target;
}

::size_t TripRoute::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripRoute)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.TripLeg legs = 1;
  total_size += 1UL * this->_internal_legs_size();
  for (const auto& msg : this->_internal_legs()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripRoute::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripRoute*>(
      &from));
}

void TripRoute::MergeFrom(const TripRoute& from) {
  TripRoute* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripRoute)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_legs()->MergeFrom(from._internal_legs());
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripRoute::CopyFrom(const TripRoute& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripRoute)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TripRoute::IsInitialized() const {
  return true;
}

void TripRoute::InternalSwap(TripRoute* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.legs_.InternalSwap(&other->_impl_.legs_);
}

std::string TripRoute::GetTypeName() const {
  return "valhalla.TripRoute";
}

// ===================================================================

class Trip::_Internal {
 public:
};

Trip::Trip(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.Trip)
}
Trip::Trip(const Trip& from) : ::google::protobuf::MessageLite() {
  Trip* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.routes_){from._impl_.routes_},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);

  // @@protoc_insertion_point(copy_constructor:valhalla.Trip)
}
inline void Trip::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.routes_){arena},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
Trip::~Trip() {
  // @@protoc_insertion_point(destructor:valhalla.Trip)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void Trip::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.routes_.~RepeatedPtrField();
}
void Trip::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Trip::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Trip)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_routes()->Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Trip::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2> Trip::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Trip_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // repeated .valhalla.TripRoute routes = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Trip, _impl_.routes_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .valhalla.TripRoute routes = 1;
    {PROTOBUF_FIELD_OFFSET(Trip, _impl_.routes_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::TripRoute>()},
  }}, {{
  }},
};

::uint8_t* Trip::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.Trip)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .valhalla.TripRoute routes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_routes_size()); i < n; i++) {
    const auto& repfield = this->_internal_routes().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.Trip)
  return target;
}

::size_t Trip::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.Trip)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.TripRoute routes = 1;
  total_size += 1UL * this->_internal_routes_size();
  for (const auto& msg : this->_internal_routes()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Trip::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Trip*>(
      &from));
}

void Trip::MergeFrom(const Trip& from) {
  Trip* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Trip)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_routes()->MergeFrom(from._internal_routes());
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Trip::CopyFrom(const Trip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Trip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Trip::IsInitialized() const {
  return true;
}

void Trip::InternalSwap(Trip* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.routes_.InternalSwap(&other->_impl_.routes_);
}

std::string Trip::GetTypeName() const {
  return "valhalla.Trip";
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace valhalla
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
